//! OTLP MMap definitions.

// This file is @generated by prost-build.
/// SpanEvent represents a lifecycle event for a span.
///
/// Rationale: SpanEvent contains trace_id and span_id directly (rather than
/// using a nested SpanContext message) because the SpanEvent is the primary
/// source of these IDs for the span it describes.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SpanEvent {
    /// InstrumentationScope from which this was recorded.
    #[prost(int64, tag = "20")]
    pub scope_ref: i64,
    /// A unique identifier for a trace. All spans from the same trace share
    /// the same `trace_id`. The ID is a 16-byte array. An ID with all zeroes OR
    /// of length other than 16 bytes is considered invalid (empty string in OTLP/JSON
    /// is zero-length and thus is also invalid).
    ///
    /// This field is required.
    #[prost(bytes = "vec", tag = "1")]
    pub trace_id: ::prost::alloc::vec::Vec<u8>,
    /// A unique identifier for a span within a trace, assigned when the span
    /// is created. The ID is an 8-byte array. An ID with all zeroes OR of length
    /// other than 8 bytes is considered invalid (empty string in OTLP/JSON
    /// is zero-length and thus is also invalid).
    ///
    /// This field is required.
    #[prost(bytes = "vec", tag = "2")]
    pub span_id: ::prost::alloc::vec::Vec<u8>,
    /// The actual event data.
    #[prost(oneof = "span_event::Event", tags = "11, 12, 13, 14, 15")]
    pub event: ::core::option::Option<span_event::Event>,
}
/// Nested message and enum types in `SpanEvent`.
pub mod span_event {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct StartSpan {
        /// The `span_id` of this span's parent span. If this is a root span, then this
        /// field must be empty. The ID is an 8-byte array.
        #[prost(bytes = "vec", tag = "4")]
        pub parent_span_id: ::prost::alloc::vec::Vec<u8>,
        /// Flags, a bit field.
        ///
        /// Bits 0-7 (8 least significant bits) are the trace flags as defined in W3C Trace
        /// Context specification. To read the 8-bit W3C trace flag, use
        /// `flags & SPAN_FLAGS_TRACE_FLAGS_MASK`.
        ///
        /// See <https://www.w3.org/TR/trace-context-2/#trace-flags> for the flag definitions.
        ///
        /// Bits 8 and 9 represent the 3 states of whether a span's parent
        /// is remote. The states are (unknown, is not remote, is remote).
        /// To read whether the value is known, use `(flags & SPAN_FLAGS_CONTEXT_HAS_IS_REMOTE_MASK) != 0`.
        /// To read whether the span is remote, use `(flags & SPAN_FLAGS_CONTEXT_IS_REMOTE_MASK) != 0`.
        ///
        /// When creating span messages, if the message is logically forwarded from another source
        /// with an equivalent flags fields (i.e., usually another OTLP span message), the field SHOULD
        /// be copied as-is. If creating from a source that does not have an equivalent flags field
        /// (such as a runtime representation of an OpenTelemetry span), the high 22 bits MUST
        /// be set to zero.
        /// Readers MUST NOT assume that bits 10-31 (22 most significant bits) will be zero.
        ///
        /// \[Optional\].
        #[prost(fixed32, tag = "16")]
        pub flags: u32,
        /// A description of the span's operation.
        ///
        /// For example, the name can be a qualified method name or a file name
        /// and a line number where the operation is called. A best practice is to use
        /// the same display name at the same call point in an application.
        /// This makes it easier to correlate spans in different traces.
        ///
        /// This field is semantically required to be set to non-empty string.
        /// Empty value is equivalent to an unknown span name.
        ///
        /// This field is required.
        #[prost(string, tag = "5")]
        pub name: ::prost::alloc::string::String,
        /// Distinguishes between spans generated in a particular context. For example,
        /// two spans with the same name may be distinguished using `CLIENT` (caller)
        /// and `SERVER` (callee) to identify queueing latency associated with the span.
        #[prost(enumeration = "start_span::SpanKind", tag = "6")]
        pub kind: i32,
        /// The start time of the span. On the client side, this is the time
        /// kept by the local machine where the span execution starts. On the server side, this
        /// is the time when the server's application handler starts running.
        /// Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January 1970.
        ///
        /// This field is semantically required and it is expected that end_time >= start_time.
        #[prost(fixed64, tag = "7")]
        pub start_time_unix_nano: u64,
        /// A collection of key/value pairs. Note, global attributes
        /// like server name can be set using the resource API. Examples of attributes:
        ///
        ///      "/http/user_agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"
        ///      "/http/server_latency": 300
        ///      "example.com/myattribute": true
        ///      "example.com/score": 10.239
        ///
        /// Attribute keys MUST be unique (it is not allowed to have more than one
        /// attribute with the same key).
        ///
        /// The attribute values SHOULD NOT contain empty values.
        /// The attribute values SHOULD NOT contain bytes values.
        /// The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
        /// double values.
        /// The attribute values SHOULD NOT contain kvlist values.
        /// The behavior of software that receives attributes containing such values can be unpredictable.
        /// These restrictions can change in a minor release.
        /// The restrictions take origin from the OpenTelemetry specification:
        /// <https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.>
        #[prost(message, repeated, tag = "9")]
        pub attributes: ::prost::alloc::vec::Vec<super::KeyValueRef>,
    }
    /// Nested message and enum types in `StartSpan`.
    pub mod start_span {
        /// SpanKind is the type of span. Can be used to specify additional relationships between spans
        /// in addition to a parent/child relationship.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum SpanKind {
            /// Unspecified. Do NOT use as default.
            /// Implementations MAY assume SpanKind to be INTERNAL when receiving UNSPECIFIED.
            Unspecified = 0,
            /// Indicates that the span represents an internal operation within an application,
            /// as opposed to an operation happening at the boundaries. Default value.
            Internal = 1,
            /// Indicates that the span covers server-side handling of an RPC or other
            /// remote network request.
            Server = 2,
            /// Indicates that the span describes a request to some remote service.
            Client = 3,
            /// Indicates that the span describes a producer sending a message to a broker.
            /// Unlike CLIENT and SERVER, there is often no direct critical path latency relationship
            /// between producer and consumer spans. A PRODUCER span ends when the message was accepted
            /// by the broker while the logical processing of the message might span a much longer time.
            Producer = 4,
            /// Indicates that the span describes consumer receiving a message from a broker.
            /// Like the PRODUCER kind, there is often no direct critical path latency relationship
            /// between producer and consumer spans.
            Consumer = 5,
        }
        impl SpanKind {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "SPAN_KIND_UNSPECIFIED",
                    Self::Internal => "SPAN_KIND_INTERNAL",
                    Self::Server => "SPAN_KIND_SERVER",
                    Self::Client => "SPAN_KIND_CLIENT",
                    Self::Producer => "SPAN_KIND_PRODUCER",
                    Self::Consumer => "SPAN_KIND_CONSUMER",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "SPAN_KIND_UNSPECIFIED" => Some(Self::Unspecified),
                    "SPAN_KIND_INTERNAL" => Some(Self::Internal),
                    "SPAN_KIND_SERVER" => Some(Self::Server),
                    "SPAN_KIND_CLIENT" => Some(Self::Client),
                    "SPAN_KIND_PRODUCER" => Some(Self::Producer),
                    "SPAN_KIND_CONSUMER" => Some(Self::Consumer),
                    _ => None,
                }
            }
        }
    }
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct EndSpan {
        /// The end time of the span. On the client side, this is the time
        /// kept by the local machine where the span execution ends. On the server side, this
        /// is the time when the server application handler stops running.
        /// Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January 1970.
        ///
        /// This field is semantically required and it is expected that end_time >= start_time.
        #[prost(fixed64, tag = "8")]
        pub end_time_unix_nano: u64,
        /// An optional final status for this span. Semantically when Status isn't set, it means
        /// span's status code is unset, i.e. assume STATUS_CODE_UNSET (code = 0).
        #[prost(message, optional, tag = "15")]
        pub status: ::core::option::Option<super::Status>,
    }
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct ChangeSpanName {
        /// A description of the span's operation.
        ///
        /// For example, the name can be a qualified method name or a file name
        /// and a line number where the operation is called. A best practice is to use
        /// the same display name at the same call point in an application.
        /// This makes it easier to correlate spans in different traces.
        ///
        /// This field is semantically required to be set to non-empty string.
        /// Empty value is equivalent to an unknown span name.
        ///
        /// This field is required.
        #[prost(string, tag = "5")]
        pub name: ::prost::alloc::string::String,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct UpdateAttributes {
        /// A collection of key/value pairs. Note, global attributes
        /// like server name can be set using the resource API. Examples of attributes:
        ///
        ///      "/http/user_agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"
        ///      "/http/server_latency": 300
        ///      "example.com/myattribute": true
        ///      "example.com/score": 10.239
        ///
        /// Attribute keys MUST be unique (it is not allowed to have more than one
        /// attribute with the same key).
        ///
        /// The attribute values SHOULD NOT contain empty values.
        /// The attribute values SHOULD NOT contain bytes values.
        /// The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
        /// double values.
        /// The attribute values SHOULD NOT contain kvlist values.
        /// The behavior of software that receives attributes containing such values can be unpredictable.
        /// These restrictions can change in a minor release.
        /// The restrictions take origin from the OpenTelemetry specification:
        /// <https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.>
        #[prost(message, repeated, tag = "9")]
        pub attributes: ::prost::alloc::vec::Vec<super::KeyValueRef>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AddLink {
        /// A collection of Links, which are references from this span to a span
        /// in the same or different trace.
        #[prost(message, repeated, tag = "13")]
        pub links: ::prost::alloc::vec::Vec<add_link::Link>,
    }
    /// Nested message and enum types in `AddLink`.
    pub mod add_link {
        /// A pointer from the current span to another span in the same trace or in a
        /// different trace. For example, this can be used in batching operations,
        /// where a single batch handler processes multiple requests from different
        /// traces or when the handler receives a request from a different project.
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Link {
            /// A unique identifier of a trace that this linked span is part of. The ID is a
            /// 16-byte array.
            #[prost(bytes = "vec", tag = "1")]
            pub trace_id: ::prost::alloc::vec::Vec<u8>,
            /// A unique identifier for the linked span. The ID is an 8-byte array.
            #[prost(bytes = "vec", tag = "2")]
            pub span_id: ::prost::alloc::vec::Vec<u8>,
            /// The trace_state associated with the link.
            #[prost(string, tag = "3")]
            pub trace_state: ::prost::alloc::string::String,
            /// A collection of attribute key/value pairs on the link.
            /// Attribute keys MUST be unique (it is not allowed to have more than one
            /// attribute with the same key).
            ///
            /// The attribute values SHOULD NOT contain empty values.
            /// The attribute values SHOULD NOT contain bytes values.
            /// The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
            /// double values.
            /// The attribute values SHOULD NOT contain kvlist values.
            /// The behavior of software that receives attributes containing such values can be unpredictable.
            /// These restrictions can change in a minor release.
            /// The restrictions take origin from the OpenTelemetry specification:
            /// <https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.>
            #[prost(message, repeated, tag = "4")]
            pub attributes: ::prost::alloc::vec::Vec<super::super::KeyValueRef>,
            /// The number of dropped attributes. If the value is 0,
            /// then no attributes were dropped.
            #[prost(uint32, tag = "5")]
            pub dropped_attributes_count: u32,
            /// Flags, a bit field.
            ///
            /// Bits 0-7 (8 least significant bits) are the trace flags as defined in W3C Trace
            /// Context specification. To read the 8-bit W3C trace flag, use
            /// `flags & SPAN_FLAGS_TRACE_FLAGS_MASK`.
            ///
            /// See <https://www.w3.org/TR/trace-context-2/#trace-flags> for the flag definitions.
            ///
            /// Bits 8 and 9 represent the 3 states of whether the link is remote.
            /// The states are (unknown, is not remote, is remote).
            /// To read whether the value is known, use `(flags & SPAN_FLAGS_CONTEXT_HAS_IS_REMOTE_MASK) != 0`.
            /// To read whether the link is remote, use `(flags & SPAN_FLAGS_CONTEXT_IS_REMOTE_MASK) != 0`.
            ///
            /// Readers MUST NOT assume that bits 10-31 (22 most significant bits) will be zero.
            /// When creating new spans, bits 10-31 (most-significant 22-bits) MUST be zero.
            ///
            /// \[Optional\].
            #[prost(fixed32, tag = "6")]
            pub flags: u32,
        }
    }
    /// The actual event data.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Event {
        #[prost(message, tag = "11")]
        Start(StartSpan),
        #[prost(message, tag = "12")]
        End(EndSpan),
        #[prost(message, tag = "13")]
        Name(ChangeSpanName),
        #[prost(message, tag = "14")]
        Attributes(UpdateAttributes),
        #[prost(message, tag = "15")]
        Link(AddLink),
    }
}
/// The Status type defines a logical error model that is suitable for different
/// programming environments, including REST APIs and RPC APIs.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Status {
    /// A developer-facing human readable error message.
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
    /// The status code.
    #[prost(enumeration = "status::StatusCode", tag = "3")]
    pub code: i32,
}
/// Nested message and enum types in `Status`.
pub mod status {
    /// For the semantics of status codes see
    /// <https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/trace/api.md#set-status>
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum StatusCode {
        /// The default status.
        Unset = 0,
        /// The Span has been validated by an Application developer or Operator to
        /// have completed successfully.
        Ok = 1,
        /// The Span contains an error.
        Error = 2,
    }
    impl StatusCode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unset => "STATUS_CODE_UNSET",
                Self::Ok => "STATUS_CODE_OK",
                Self::Error => "STATUS_CODE_ERROR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATUS_CODE_UNSET" => Some(Self::Unset),
                "STATUS_CODE_OK" => Some(Self::Ok),
                "STATUS_CODE_ERROR" => Some(Self::Error),
                _ => None,
            }
        }
    }
}
/// Passes a single metric measurement from the source to the
/// collector.  This MUST use the metric_ref to determine
/// how to aggregate the measurement into a real OTLP metric.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Measurement {
    /// Reference to the definition of this metric in the dictionary.
    #[prost(int64, tag = "1")]
    pub metric_ref: i64,
    /// A collection of attribute key/value pairs that identify the time series.
    /// For performance, it is recommended to use a `value_ref` in `AnyValue`
    /// to point to a dictionary entry for attribute sets, especially for metrics
    /// with high cardinality.
    /// TODO: Consider replacing this with a single `timeseries_ref` to a dictionary
    /// entry to better deduplicate attribute sets.
    #[prost(message, repeated, tag = "2")]
    pub attributes: ::prost::alloc::vec::Vec<KeyValueRef>,
    /// Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January
    /// 1970.
    #[prost(fixed64, tag = "3")]
    pub time_unix_nano: u64,
    /// (optional) Span context information if this measurement was
    /// recorded within a span.
    /// Note: Unlike SpanEvent, this uses a nested SpanContext message as
    /// it is referring to an existing span context rather than defining it.
    #[prost(message, optional, tag = "6")]
    pub span_context: ::core::option::Option<SpanContext>,
    /// The value itself.  A point is considered invalid when one of the recognized
    /// value fields is not present inside this oneof.
    #[prost(oneof = "measurement::Value", tags = "4, 5")]
    pub value: ::core::option::Option<measurement::Value>,
}
/// Nested message and enum types in `Measurement`.
pub mod measurement {
    /// The value itself.  A point is considered invalid when one of the recognized
    /// value fields is not present inside this oneof.
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Value {
        #[prost(int64, tag = "4")]
        AsLong(i64),
        #[prost(double, tag = "5")]
        AsDouble(f64),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetricRef {
    /// The name of the metric.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// A description of the metric, which can be used in documentation.
    #[prost(string, tag = "2")]
    pub description: ::prost::alloc::string::String,
    /// The unit in which the metric value is reported. Follows the format
    /// described by <https://unitsofmeasure.org/ucum.html.>
    #[prost(string, tag = "3")]
    pub unit: ::prost::alloc::string::String,
    /// Reference to the instrumentation scope where this metric is defined.
    #[prost(int64, tag = "4")]
    pub instrumentation_scope_ref: i64,
    /// Defines the aggregation to perform on measurements recorded.
    #[prost(oneof = "metric_ref::Aggregation", tags = "5, 6, 7, 8")]
    pub aggregation: ::core::option::Option<metric_ref::Aggregation>,
}
/// Nested message and enum types in `MetricRef`.
pub mod metric_ref {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Gauge {}
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Sum {
        /// aggregation_temporality describes if the aggregator reports delta changes
        /// since last report time, or cumulative changes since a fixed start time.
        #[prost(enumeration = "super::AggregationTemporality", tag = "2")]
        pub aggregation_temporality: i32,
        /// Represents whether the sum is monotonic.
        #[prost(bool, tag = "3")]
        pub is_monotonic: bool,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Histogram {
        /// aggregation_temporality describes if the aggregator reports delta changes
        /// since last report time, or cumulative changes since a fixed start time.
        #[prost(enumeration = "super::AggregationTemporality", tag = "1")]
        pub aggregation_temporality: i32,
        /// Bucket boundaries to use for this histogram.
        #[prost(double, repeated, tag = "2")]
        pub bucket_boundaries: ::prost::alloc::vec::Vec<f64>,
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct ExponentialHistogram {
        /// aggregation_temporality describes if the aggregator reports delta changes
        /// since last report time, or cumulative changes since a fixed start time.
        #[prost(enumeration = "super::AggregationTemporality", tag = "1")]
        pub aggregation_temporality: i32,
        /// The number of buckets to configure for the exponential histogram.
        #[prost(int64, tag = "2")]
        pub max_buckets: i64,
        /// The maximum scale to allow for this histogram.
        #[prost(int64, tag = "3")]
        pub max_scale: i64,
    }
    /// Defines the aggregation to perform on measurements recorded.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Aggregation {
        #[prost(message, tag = "5")]
        Gauge(Gauge),
        #[prost(message, tag = "6")]
        Sum(Sum),
        #[prost(message, tag = "7")]
        Histogram(Histogram),
        #[prost(message, tag = "8")]
        ExpHist(ExponentialHistogram),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Event {
    /// InstrumentationScope from which this was recorded.
    #[prost(int64, tag = "1")]
    pub scope_ref: i64,
    /// time_unix_nano is the time when the event occurred.
    /// Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January 1970.
    /// Value of 0 indicates unknown or missing timestamp.
    #[prost(fixed64, tag = "2")]
    pub time_unix_nano: u64,
    /// Numerical value of the severity, normalized to values described in Log Data Model.
    /// \[Optional\].
    #[prost(enumeration = "SeverityNumber", tag = "3")]
    pub severity_number: i32,
    /// The severity text (also known as log level). The original string representation as
    /// it is known at the source. \[Optional\].
    #[prost(string, tag = "4")]
    pub severity_text: ::prost::alloc::string::String,
    /// A value containing the body of the log record. Can be for example a human-readable
    /// string message (including multi-line) describing the event in a free form or it can
    /// be a structured data composed of arrays and maps of other values. \[Optional\].
    #[prost(message, optional, tag = "5")]
    pub body: ::core::option::Option<AnyValue>,
    /// A unique identifier of event category/type.
    /// All events with the same event_name are expected to conform to the same
    /// schema for both their attributes and their body.
    ///
    /// Recommended to be fully qualified and short (no longer than 256 characters).
    ///
    /// Presence of event_name on the log record identifies this record
    /// as an event.
    ///
    /// \[Optional\].
    #[prost(int64, tag = "6")]
    pub event_name_ref: i64,
    /// Span information in which this event was recorded.
    /// \[Optional\].
    /// Note: Unlike SpanEvent, this uses a nested SpanContext message as
    /// it is referring to an existing span context rather than defining it.
    #[prost(message, optional, tag = "7")]
    pub span_context: ::core::option::Option<SpanContext>,
    /// Attributes about this event.
    #[prost(message, repeated, tag = "8")]
    pub attributes: ::prost::alloc::vec::Vec<KeyValueRef>,
}
/// Resource information.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Resource {
    /// Set of attributes that describe the resource.
    /// Attribute keys MUST be unique (it is not allowed to have more than one
    /// attribute with the same key).
    ///
    /// The attribute values SHOULD NOT contain empty values.
    /// The attribute values SHOULD NOT contain bytes values.
    /// The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
    /// double values.
    /// The attribute values SHOULD NOT contain kvlist values.
    /// The behavior of software that receives attributes containing such values can be unpredictable.
    /// These restrictions can change in a minor release.
    /// The restrictions take origin from the OpenTelemetry specification:
    /// <https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.>
    #[prost(message, repeated, tag = "1")]
    pub attributes: ::prost::alloc::vec::Vec<KeyValueRef>,
    /// The number of dropped attributes. If the value is 0, then
    /// no attributes were dropped.
    #[prost(uint32, tag = "2")]
    pub dropped_attributes_count: u32,
}
/// InstrumentationScope defines a logical unit of code instrumentation.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstrumentationScope {
    /// A name denoting the Instrumentation scope.
    /// An empty instrumentation scope name means the name is unknown.
    #[prost(int64, tag = "1")]
    pub name_ref: i64,
    /// Defines the version of the instrumentation scope.
    /// An empty instrumentation scope version means the version is unknown.
    #[prost(int64, tag = "2")]
    pub version_ref: i64,
    /// Additional attributes that describe the scope. \[Optional\].
    /// Attribute keys MUST be unique (it is not allowed to have more than one
    /// attribute with the same key).
    #[prost(message, repeated, tag = "3")]
    pub attributes: ::prost::alloc::vec::Vec<KeyValueRef>,
    /// The number of attributes that were discarded. Attributes
    /// can be discarded because their keys are too long or because there are too many
    /// attributes. If this value is 0, then no attributes were dropped.
    #[prost(uint32, tag = "4")]
    pub dropped_attributes_count: u32,
    /// Resource in which this instrumentation scope was created.
    #[prost(int64, tag = "5")]
    pub resource_ref: i64,
}
/// KeyValueRef represents a key-value pair.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KeyValueRef {
    /// Reference to a key in the dictionary.
    #[prost(int64, tag = "1")]
    pub key_ref: i64,
    /// The value of this key-value.
    #[prost(message, optional, tag = "2")]
    pub value: ::core::option::Option<AnyValue>,
}
/// Represents any type of attribute value. AnyValue may contain a
/// primitive value such as a string or integer or it may contain an arbitrary nested
/// object containing arrays, key-value lists and primitives.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnyValue {
    /// The value is one of the listed fields. It is valid for all values to be unspecified
    /// in which case this AnyValue is considered to be "empty".
    #[prost(oneof = "any_value::Value", tags = "1, 2, 3, 4, 5, 6, 7, 8")]
    pub value: ::core::option::Option<any_value::Value>,
}
/// Nested message and enum types in `AnyValue`.
pub mod any_value {
    /// The value is one of the listed fields. It is valid for all values to be unspecified
    /// in which case this AnyValue is considered to be "empty".
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Value {
        #[prost(string, tag = "1")]
        StringValue(::prost::alloc::string::String),
        #[prost(bool, tag = "2")]
        BoolValue(bool),
        #[prost(int64, tag = "3")]
        IntValue(i64),
        #[prost(double, tag = "4")]
        DoubleValue(f64),
        #[prost(message, tag = "5")]
        ArrayValue(super::ArrayValue),
        /// TODO: Consider forcing keys for KeyValueList to be dictionary references
        /// for consistency and to reduce data size.
        #[prost(message, tag = "6")]
        KvlistValue(super::KeyValueList),
        #[prost(bytes, tag = "7")]
        BytesValue(::prost::alloc::vec::Vec<u8>),
        /// Reference to a value in the dictionary.
        #[prost(int64, tag = "8")]
        ValueRef(i64),
    }
}
/// ArrayValue is a list of AnyValue messages. We need ArrayValue as a message
/// since oneof in AnyValue does not allow repeated fields.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ArrayValue {
    /// Array of values. The array may be empty (contain 0 elements).
    #[prost(message, repeated, tag = "1")]
    pub values: ::prost::alloc::vec::Vec<AnyValue>,
}
/// KeyValueList is a list of KeyValue messages. We need KeyValueList as a message
/// since `oneof` in AnyValue does not allow repeated fields. Everywhere else where we need
/// a list of KeyValue messages (e.g. in Span) we use `repeated KeyValue` directly to
/// avoid unnecessary extra wrapping (which slows down the protocol). The 2 approaches
/// are semantically equivalent.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KeyValueList {
    /// A collection of key/value pairs. The list may be empty (may
    /// contain 0 elements).
    /// The keys MUST be unique (it is not allowed to have more than one
    /// value with the same key).
    #[prost(message, repeated, tag = "1")]
    pub values: ::prost::alloc::vec::Vec<KeyValueRef>,
}
/// Shared span-context to use between measurements/events
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SpanContext {
    /// (Optional) Span ID of the exemplar trace.
    /// span_id may be missing if the measurement is not recorded inside a trace
    /// or if the trace is not sampled.
    #[prost(bytes = "vec", tag = "1")]
    pub span_id: ::prost::alloc::vec::Vec<u8>,
    /// (Optional) Trace ID of the exemplar trace.
    /// trace_id may be missing if the measurement is not recorded inside a trace
    /// or if the trace is not sampled.
    #[prost(bytes = "vec", tag = "2")]
    pub trace_id: ::prost::alloc::vec::Vec<u8>,
    /// Span Flags, a bit field.
    ///
    /// Bits 0-7 (8 least significant bits) are the trace flags as defined in W3C Trace
    /// Context specification. To read the 8-bit W3C trace flag, use
    /// `flags & SPAN_FLAGS_TRACE_FLAGS_MASK`.
    ///
    /// See <https://www.w3.org/TR/trace-context-2/#trace-flags> for the flag definitions.
    ///
    /// Bits 8 and 9 represent the 3 states of whether a span's parent
    /// is remote. The states are (unknown, is not remote, is remote).
    /// To read whether the value is known, use `(flags & SPAN_FLAGS_CONTEXT_HAS_IS_REMOTE_MASK) != 0`.
    /// To read whether the span is remote, use `(flags & SPAN_FLAGS_CONTEXT_IS_REMOTE_MASK) != 0`.
    ///
    /// When creating span messages, if the message is logically forwarded from another source
    /// with an equivalent flags fields (i.e., usually another OTLP span message), the field SHOULD
    /// be copied as-is. If creating from a source that does not have an equivalent flags field
    /// (such as a runtime representation of an OpenTelemetry span), the high 22 bits MUST
    /// be set to zero.
    /// Readers MUST NOT assume that bits 10-31 (22 most significant bits) will be zero.
    ///
    /// \[Optional\].
    #[prost(fixed32, tag = "3")]
    pub flags: u32,
}
/// AggregationTemporality defines how a metric aggregator reports aggregated
/// values. It describes how those values relate to the time interval over
/// which they are aggregated.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AggregationTemporality {
    /// UNSPECIFIED is the default AggregationTemporality, it MUST not be used.
    Unspecified = 0,
    /// DELTA is an AggregationTemporality for a metric aggregator which reports
    /// changes since last report time. Successive metrics contain aggregation of
    /// values from continuous and non-overlapping intervals.
    ///
    /// The values for a DELTA metric are based only on the time interval
    /// associated with one measurement cycle. There is no dependency on
    /// previous measurements like is the case for CUMULATIVE metrics.
    ///
    /// For example, consider a system measuring the number of requests that
    /// it receives and reports the sum of these requests every second as a
    /// DELTA metric:
    ///
    ///    1. The system starts receiving at time=t_0.
    ///    2. A request is received, the system measures 1 request.
    ///    3. A request is received, the system measures 1 request.
    ///    4. A request is received, the system measures 1 request.
    ///    5. The 1 second collection cycle ends. A metric is exported for the
    ///       number of requests received over the interval of time t_0 to
    ///       t_0+1 with a value of 3.
    ///    6. A request is received, the system measures 1 request.
    ///    7. A request is received, the system measures 1 request.
    ///    8. The 1 second collection cycle ends. A metric is exported for the
    ///       number of requests received over the interval of time t_0+1 to
    ///       t_0+2 with a value of 2.
    Delta = 1,
    /// CUMULATIVE is an AggregationTemporality for a metric aggregator which
    /// reports changes since a fixed start time. This means that current values
    /// of a CUMULATIVE metric depend on all previous measurements since the
    /// start time. Because of this, the sender is required to retain this state
    /// in some form. If this state is lost or invalidated, the CUMULATIVE metric
    /// values MUST be reset and a new fixed start time following the last
    /// reported measurement time sent MUST be used.
    ///
    /// For example, consider a system measuring the number of requests that
    /// it receives and reports the sum of these requests every second as a
    /// CUMULATIVE metric:
    ///
    ///    1. The system starts receiving at time=t_0.
    ///    2. A request is received, the system measures 1 request.
    ///    3. A request is received, the system measures 1 request.
    ///    4. A request is received, the system measures 1 request.
    ///    5. The 1 second collection cycle ends. A metric is exported for the
    ///       number of requests received over the interval of time t_0 to
    ///       t_0+1 with a value of 3.
    ///    6. A request is received, the system measures 1 request.
    ///    7. A request is received, the system measures 1 request.
    ///    8. The 1 second collection cycle ends. A metric is exported for the
    ///       number of requests received over the interval of time t_0 to
    ///       t_0+2 with a value of 5.
    ///    9. The system experiences a fault and loses state.
    ///    10. The system recovers and resumes receiving at time=t_1.
    ///    11. A request is received, the system measures 1 request.
    ///    12. The 1 second collection cycle ends. A metric is exported for the
    ///       number of requests received over the interval of time t_1 to
    ///       t_0+1 with a value of 1.
    ///
    /// Note: Even though, when reporting changes since last report time, using
    /// CUMULATIVE is valid, it is not recommended. This may cause problems for
    /// systems that do not use start_time to determine when the aggregation
    /// value was reset (e.g. Prometheus).
    Cumulative = 2,
}
impl AggregationTemporality {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "AGGREGATION_TEMPORALITY_UNSPECIFIED",
            Self::Delta => "AGGREGATION_TEMPORALITY_DELTA",
            Self::Cumulative => "AGGREGATION_TEMPORALITY_CUMULATIVE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "AGGREGATION_TEMPORALITY_UNSPECIFIED" => Some(Self::Unspecified),
            "AGGREGATION_TEMPORALITY_DELTA" => Some(Self::Delta),
            "AGGREGATION_TEMPORALITY_CUMULATIVE" => Some(Self::Cumulative),
            _ => None,
        }
    }
}
/// Possible values for LogRecord.SeverityNumber.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SeverityNumber {
    /// UNSPECIFIED is the default SeverityNumber, it MUST NOT be used.
    Unspecified = 0,
    Trace = 1,
    Trace2 = 2,
    Trace3 = 3,
    Trace4 = 4,
    Debug = 5,
    Debug2 = 6,
    Debug3 = 7,
    Debug4 = 8,
    Info = 9,
    Info2 = 10,
    Info3 = 11,
    Info4 = 12,
    Warn = 13,
    Warn2 = 14,
    Warn3 = 15,
    Warn4 = 16,
    Error = 17,
    Error2 = 18,
    Error3 = 19,
    Error4 = 20,
    Fatal = 21,
    Fatal2 = 22,
    Fatal3 = 23,
    Fatal4 = 24,
}
impl SeverityNumber {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "SEVERITY_NUMBER_UNSPECIFIED",
            Self::Trace => "SEVERITY_NUMBER_TRACE",
            Self::Trace2 => "SEVERITY_NUMBER_TRACE2",
            Self::Trace3 => "SEVERITY_NUMBER_TRACE3",
            Self::Trace4 => "SEVERITY_NUMBER_TRACE4",
            Self::Debug => "SEVERITY_NUMBER_DEBUG",
            Self::Debug2 => "SEVERITY_NUMBER_DEBUG2",
            Self::Debug3 => "SEVERITY_NUMBER_DEBUG3",
            Self::Debug4 => "SEVERITY_NUMBER_DEBUG4",
            Self::Info => "SEVERITY_NUMBER_INFO",
            Self::Info2 => "SEVERITY_NUMBER_INFO2",
            Self::Info3 => "SEVERITY_NUMBER_INFO3",
            Self::Info4 => "SEVERITY_NUMBER_INFO4",
            Self::Warn => "SEVERITY_NUMBER_WARN",
            Self::Warn2 => "SEVERITY_NUMBER_WARN2",
            Self::Warn3 => "SEVERITY_NUMBER_WARN3",
            Self::Warn4 => "SEVERITY_NUMBER_WARN4",
            Self::Error => "SEVERITY_NUMBER_ERROR",
            Self::Error2 => "SEVERITY_NUMBER_ERROR2",
            Self::Error3 => "SEVERITY_NUMBER_ERROR3",
            Self::Error4 => "SEVERITY_NUMBER_ERROR4",
            Self::Fatal => "SEVERITY_NUMBER_FATAL",
            Self::Fatal2 => "SEVERITY_NUMBER_FATAL2",
            Self::Fatal3 => "SEVERITY_NUMBER_FATAL3",
            Self::Fatal4 => "SEVERITY_NUMBER_FATAL4",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SEVERITY_NUMBER_UNSPECIFIED" => Some(Self::Unspecified),
            "SEVERITY_NUMBER_TRACE" => Some(Self::Trace),
            "SEVERITY_NUMBER_TRACE2" => Some(Self::Trace2),
            "SEVERITY_NUMBER_TRACE3" => Some(Self::Trace3),
            "SEVERITY_NUMBER_TRACE4" => Some(Self::Trace4),
            "SEVERITY_NUMBER_DEBUG" => Some(Self::Debug),
            "SEVERITY_NUMBER_DEBUG2" => Some(Self::Debug2),
            "SEVERITY_NUMBER_DEBUG3" => Some(Self::Debug3),
            "SEVERITY_NUMBER_DEBUG4" => Some(Self::Debug4),
            "SEVERITY_NUMBER_INFO" => Some(Self::Info),
            "SEVERITY_NUMBER_INFO2" => Some(Self::Info2),
            "SEVERITY_NUMBER_INFO3" => Some(Self::Info3),
            "SEVERITY_NUMBER_INFO4" => Some(Self::Info4),
            "SEVERITY_NUMBER_WARN" => Some(Self::Warn),
            "SEVERITY_NUMBER_WARN2" => Some(Self::Warn2),
            "SEVERITY_NUMBER_WARN3" => Some(Self::Warn3),
            "SEVERITY_NUMBER_WARN4" => Some(Self::Warn4),
            "SEVERITY_NUMBER_ERROR" => Some(Self::Error),
            "SEVERITY_NUMBER_ERROR2" => Some(Self::Error2),
            "SEVERITY_NUMBER_ERROR3" => Some(Self::Error3),
            "SEVERITY_NUMBER_ERROR4" => Some(Self::Error4),
            "SEVERITY_NUMBER_FATAL" => Some(Self::Fatal),
            "SEVERITY_NUMBER_FATAL2" => Some(Self::Fatal2),
            "SEVERITY_NUMBER_FATAL3" => Some(Self::Fatal3),
            "SEVERITY_NUMBER_FATAL4" => Some(Self::Fatal4),
            _ => None,
        }
    }
}

