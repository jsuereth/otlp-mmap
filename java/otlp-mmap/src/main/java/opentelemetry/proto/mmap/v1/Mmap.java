// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: mmap.proto
// Protobuf Java Version: 4.33.0

package opentelemetry.proto.mmap.v1;

@com.google.protobuf.Generated
public final class Mmap extends com.google.protobuf.GeneratedFile {
  private Mmap() {}
  static {
    com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
      com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
      /* major= */ 4,
      /* minor= */ 33,
      /* patch= */ 0,
      /* suffix= */ "",
      "Mmap");
  }
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistryLite registry) {
  }

  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistry registry) {
    registerAllExtensions(
        (com.google.protobuf.ExtensionRegistryLite) registry);
  }
  /**
   * <pre>
   * AggregationTemporality defines how a metric aggregator reports aggregated
   * values. It describes how those values relate to the time interval over
   * which they are aggregated.
   * </pre>
   *
   * Protobuf enum {@code opentelemetry.proto.mmap.v1.AggregationTemporality}
   */
  public enum AggregationTemporality
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <pre>
     * UNSPECIFIED is the default AggregationTemporality, it MUST not be used.
     * </pre>
     *
     * <code>AGGREGATION_TEMPORALITY_UNSPECIFIED = 0;</code>
     */
    AGGREGATION_TEMPORALITY_UNSPECIFIED(0),
    /**
     * <pre>
     * DELTA is an AggregationTemporality for a metric aggregator which reports
     * changes since last report time. Successive metrics contain aggregation of
     * values from continuous and non-overlapping intervals.
     *
     * The values for a DELTA metric are based only on the time interval
     * associated with one measurement cycle. There is no dependency on
     * previous measurements like is the case for CUMULATIVE metrics.
     *
     * For example, consider a system measuring the number of requests that
     * it receives and reports the sum of these requests every second as a
     * DELTA metric:
     *
     * 1. The system starts receiving at time=t_0.
     * 2. A request is received, the system measures 1 request.
     * 3. A request is received, the system measures 1 request.
     * 4. A request is received, the system measures 1 request.
     * 5. The 1 second collection cycle ends. A metric is exported for the
     * number of requests received over the interval of time t_0 to
     * t_0+1 with a value of 3.
     * 6. A request is received, the system measures 1 request.
     * 7. A request is received, the system measures 1 request.
     * 8. The 1 second collection cycle ends. A metric is exported for the
     * number of requests received over the interval of time t_0+1 to
     * t_0+2 with a value of 2.
     * </pre>
     *
     * <code>AGGREGATION_TEMPORALITY_DELTA = 1;</code>
     */
    AGGREGATION_TEMPORALITY_DELTA(1),
    /**
     * <pre>
     * CUMULATIVE is an AggregationTemporality for a metric aggregator which
     * reports changes since a fixed start time. This means that current values
     * of a CUMULATIVE metric depend on all previous measurements since the
     * start time. Because of this, the sender is required to retain this state
     * in some form. If this state is lost or invalidated, the CUMULATIVE metric
     * values MUST be reset and a new fixed start time following the last
     * reported measurement time sent MUST be used.
     *
     * For example, consider a system measuring the number of requests that
     * it receives and reports the sum of these requests every second as a
     * CUMULATIVE metric:
     *
     * 1. The system starts receiving at time=t_0.
     * 2. A request is received, the system measures 1 request.
     * 3. A request is received, the system measures 1 request.
     * 4. A request is received, the system measures 1 request.
     * 5. The 1 second collection cycle ends. A metric is exported for the
     * number of requests received over the interval of time t_0 to
     * t_0+1 with a value of 3.
     * 6. A request is received, the system measures 1 request.
     * 7. A request is received, the system measures 1 request.
     * 8. The 1 second collection cycle ends. A metric is exported for the
     * number of requests received over the interval of time t_0 to
     * t_0+2 with a value of 5.
     * 9. The system experiences a fault and loses state.
     * 10. The system recovers and resumes receiving at time=t_1.
     * 11. A request is received, the system measures 1 request.
     * 12. The 1 second collection cycle ends. A metric is exported for the
     * number of requests received over the interval of time t_1 to
     * t_0+1 with a value of 1.
     *
     * Note: Even though, when reporting changes since last report time, using
     * CUMULATIVE is valid, it is not recommended. This may cause problems for
     * systems that do not use start_time to determine when the aggregation
     * value was reset (e.g. Prometheus).
     * </pre>
     *
     * <code>AGGREGATION_TEMPORALITY_CUMULATIVE = 2;</code>
     */
    AGGREGATION_TEMPORALITY_CUMULATIVE(2),
    UNRECOGNIZED(-1),
    ;

    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 33,
        /* patch= */ 0,
        /* suffix= */ "",
        "AggregationTemporality");
    }
    /**
     * <pre>
     * UNSPECIFIED is the default AggregationTemporality, it MUST not be used.
     * </pre>
     *
     * <code>AGGREGATION_TEMPORALITY_UNSPECIFIED = 0;</code>
     */
    public static final int AGGREGATION_TEMPORALITY_UNSPECIFIED_VALUE = 0;
    /**
     * <pre>
     * DELTA is an AggregationTemporality for a metric aggregator which reports
     * changes since last report time. Successive metrics contain aggregation of
     * values from continuous and non-overlapping intervals.
     *
     * The values for a DELTA metric are based only on the time interval
     * associated with one measurement cycle. There is no dependency on
     * previous measurements like is the case for CUMULATIVE metrics.
     *
     * For example, consider a system measuring the number of requests that
     * it receives and reports the sum of these requests every second as a
     * DELTA metric:
     *
     * 1. The system starts receiving at time=t_0.
     * 2. A request is received, the system measures 1 request.
     * 3. A request is received, the system measures 1 request.
     * 4. A request is received, the system measures 1 request.
     * 5. The 1 second collection cycle ends. A metric is exported for the
     * number of requests received over the interval of time t_0 to
     * t_0+1 with a value of 3.
     * 6. A request is received, the system measures 1 request.
     * 7. A request is received, the system measures 1 request.
     * 8. The 1 second collection cycle ends. A metric is exported for the
     * number of requests received over the interval of time t_0+1 to
     * t_0+2 with a value of 2.
     * </pre>
     *
     * <code>AGGREGATION_TEMPORALITY_DELTA = 1;</code>
     */
    public static final int AGGREGATION_TEMPORALITY_DELTA_VALUE = 1;
    /**
     * <pre>
     * CUMULATIVE is an AggregationTemporality for a metric aggregator which
     * reports changes since a fixed start time. This means that current values
     * of a CUMULATIVE metric depend on all previous measurements since the
     * start time. Because of this, the sender is required to retain this state
     * in some form. If this state is lost or invalidated, the CUMULATIVE metric
     * values MUST be reset and a new fixed start time following the last
     * reported measurement time sent MUST be used.
     *
     * For example, consider a system measuring the number of requests that
     * it receives and reports the sum of these requests every second as a
     * CUMULATIVE metric:
     *
     * 1. The system starts receiving at time=t_0.
     * 2. A request is received, the system measures 1 request.
     * 3. A request is received, the system measures 1 request.
     * 4. A request is received, the system measures 1 request.
     * 5. The 1 second collection cycle ends. A metric is exported for the
     * number of requests received over the interval of time t_0 to
     * t_0+1 with a value of 3.
     * 6. A request is received, the system measures 1 request.
     * 7. A request is received, the system measures 1 request.
     * 8. The 1 second collection cycle ends. A metric is exported for the
     * number of requests received over the interval of time t_0 to
     * t_0+2 with a value of 5.
     * 9. The system experiences a fault and loses state.
     * 10. The system recovers and resumes receiving at time=t_1.
     * 11. A request is received, the system measures 1 request.
     * 12. The 1 second collection cycle ends. A metric is exported for the
     * number of requests received over the interval of time t_1 to
     * t_0+1 with a value of 1.
     *
     * Note: Even though, when reporting changes since last report time, using
     * CUMULATIVE is valid, it is not recommended. This may cause problems for
     * systems that do not use start_time to determine when the aggregation
     * value was reset (e.g. Prometheus).
     * </pre>
     *
     * <code>AGGREGATION_TEMPORALITY_CUMULATIVE = 2;</code>
     */
    public static final int AGGREGATION_TEMPORALITY_CUMULATIVE_VALUE = 2;


    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static AggregationTemporality valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static AggregationTemporality forNumber(int value) {
      switch (value) {
        case 0: return AGGREGATION_TEMPORALITY_UNSPECIFIED;
        case 1: return AGGREGATION_TEMPORALITY_DELTA;
        case 2: return AGGREGATION_TEMPORALITY_CUMULATIVE;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<AggregationTemporality>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        AggregationTemporality> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<AggregationTemporality>() {
            public AggregationTemporality findValueByNumber(int number) {
              return AggregationTemporality.forNumber(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return opentelemetry.proto.mmap.v1.Mmap.getDescriptor().getEnumTypes().get(0);
    }

    private static final AggregationTemporality[] VALUES = values();

    public static AggregationTemporality valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private AggregationTemporality(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:opentelemetry.proto.mmap.v1.AggregationTemporality)
  }

  /**
   * <pre>
   * Possible values for LogRecord.SeverityNumber.
   * </pre>
   *
   * Protobuf enum {@code opentelemetry.proto.mmap.v1.SeverityNumber}
   */
  public enum SeverityNumber
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <pre>
     * UNSPECIFIED is the default SeverityNumber, it MUST NOT be used.
     * </pre>
     *
     * <code>SEVERITY_NUMBER_UNSPECIFIED = 0;</code>
     */
    SEVERITY_NUMBER_UNSPECIFIED(0),
    /**
     * <code>SEVERITY_NUMBER_TRACE = 1;</code>
     */
    SEVERITY_NUMBER_TRACE(1),
    /**
     * <code>SEVERITY_NUMBER_TRACE2 = 2;</code>
     */
    SEVERITY_NUMBER_TRACE2(2),
    /**
     * <code>SEVERITY_NUMBER_TRACE3 = 3;</code>
     */
    SEVERITY_NUMBER_TRACE3(3),
    /**
     * <code>SEVERITY_NUMBER_TRACE4 = 4;</code>
     */
    SEVERITY_NUMBER_TRACE4(4),
    /**
     * <code>SEVERITY_NUMBER_DEBUG = 5;</code>
     */
    SEVERITY_NUMBER_DEBUG(5),
    /**
     * <code>SEVERITY_NUMBER_DEBUG2 = 6;</code>
     */
    SEVERITY_NUMBER_DEBUG2(6),
    /**
     * <code>SEVERITY_NUMBER_DEBUG3 = 7;</code>
     */
    SEVERITY_NUMBER_DEBUG3(7),
    /**
     * <code>SEVERITY_NUMBER_DEBUG4 = 8;</code>
     */
    SEVERITY_NUMBER_DEBUG4(8),
    /**
     * <code>SEVERITY_NUMBER_INFO = 9;</code>
     */
    SEVERITY_NUMBER_INFO(9),
    /**
     * <code>SEVERITY_NUMBER_INFO2 = 10;</code>
     */
    SEVERITY_NUMBER_INFO2(10),
    /**
     * <code>SEVERITY_NUMBER_INFO3 = 11;</code>
     */
    SEVERITY_NUMBER_INFO3(11),
    /**
     * <code>SEVERITY_NUMBER_INFO4 = 12;</code>
     */
    SEVERITY_NUMBER_INFO4(12),
    /**
     * <code>SEVERITY_NUMBER_WARN = 13;</code>
     */
    SEVERITY_NUMBER_WARN(13),
    /**
     * <code>SEVERITY_NUMBER_WARN2 = 14;</code>
     */
    SEVERITY_NUMBER_WARN2(14),
    /**
     * <code>SEVERITY_NUMBER_WARN3 = 15;</code>
     */
    SEVERITY_NUMBER_WARN3(15),
    /**
     * <code>SEVERITY_NUMBER_WARN4 = 16;</code>
     */
    SEVERITY_NUMBER_WARN4(16),
    /**
     * <code>SEVERITY_NUMBER_ERROR = 17;</code>
     */
    SEVERITY_NUMBER_ERROR(17),
    /**
     * <code>SEVERITY_NUMBER_ERROR2 = 18;</code>
     */
    SEVERITY_NUMBER_ERROR2(18),
    /**
     * <code>SEVERITY_NUMBER_ERROR3 = 19;</code>
     */
    SEVERITY_NUMBER_ERROR3(19),
    /**
     * <code>SEVERITY_NUMBER_ERROR4 = 20;</code>
     */
    SEVERITY_NUMBER_ERROR4(20),
    /**
     * <code>SEVERITY_NUMBER_FATAL = 21;</code>
     */
    SEVERITY_NUMBER_FATAL(21),
    /**
     * <code>SEVERITY_NUMBER_FATAL2 = 22;</code>
     */
    SEVERITY_NUMBER_FATAL2(22),
    /**
     * <code>SEVERITY_NUMBER_FATAL3 = 23;</code>
     */
    SEVERITY_NUMBER_FATAL3(23),
    /**
     * <code>SEVERITY_NUMBER_FATAL4 = 24;</code>
     */
    SEVERITY_NUMBER_FATAL4(24),
    UNRECOGNIZED(-1),
    ;

    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 33,
        /* patch= */ 0,
        /* suffix= */ "",
        "SeverityNumber");
    }
    /**
     * <pre>
     * UNSPECIFIED is the default SeverityNumber, it MUST NOT be used.
     * </pre>
     *
     * <code>SEVERITY_NUMBER_UNSPECIFIED = 0;</code>
     */
    public static final int SEVERITY_NUMBER_UNSPECIFIED_VALUE = 0;
    /**
     * <code>SEVERITY_NUMBER_TRACE = 1;</code>
     */
    public static final int SEVERITY_NUMBER_TRACE_VALUE = 1;
    /**
     * <code>SEVERITY_NUMBER_TRACE2 = 2;</code>
     */
    public static final int SEVERITY_NUMBER_TRACE2_VALUE = 2;
    /**
     * <code>SEVERITY_NUMBER_TRACE3 = 3;</code>
     */
    public static final int SEVERITY_NUMBER_TRACE3_VALUE = 3;
    /**
     * <code>SEVERITY_NUMBER_TRACE4 = 4;</code>
     */
    public static final int SEVERITY_NUMBER_TRACE4_VALUE = 4;
    /**
     * <code>SEVERITY_NUMBER_DEBUG = 5;</code>
     */
    public static final int SEVERITY_NUMBER_DEBUG_VALUE = 5;
    /**
     * <code>SEVERITY_NUMBER_DEBUG2 = 6;</code>
     */
    public static final int SEVERITY_NUMBER_DEBUG2_VALUE = 6;
    /**
     * <code>SEVERITY_NUMBER_DEBUG3 = 7;</code>
     */
    public static final int SEVERITY_NUMBER_DEBUG3_VALUE = 7;
    /**
     * <code>SEVERITY_NUMBER_DEBUG4 = 8;</code>
     */
    public static final int SEVERITY_NUMBER_DEBUG4_VALUE = 8;
    /**
     * <code>SEVERITY_NUMBER_INFO = 9;</code>
     */
    public static final int SEVERITY_NUMBER_INFO_VALUE = 9;
    /**
     * <code>SEVERITY_NUMBER_INFO2 = 10;</code>
     */
    public static final int SEVERITY_NUMBER_INFO2_VALUE = 10;
    /**
     * <code>SEVERITY_NUMBER_INFO3 = 11;</code>
     */
    public static final int SEVERITY_NUMBER_INFO3_VALUE = 11;
    /**
     * <code>SEVERITY_NUMBER_INFO4 = 12;</code>
     */
    public static final int SEVERITY_NUMBER_INFO4_VALUE = 12;
    /**
     * <code>SEVERITY_NUMBER_WARN = 13;</code>
     */
    public static final int SEVERITY_NUMBER_WARN_VALUE = 13;
    /**
     * <code>SEVERITY_NUMBER_WARN2 = 14;</code>
     */
    public static final int SEVERITY_NUMBER_WARN2_VALUE = 14;
    /**
     * <code>SEVERITY_NUMBER_WARN3 = 15;</code>
     */
    public static final int SEVERITY_NUMBER_WARN3_VALUE = 15;
    /**
     * <code>SEVERITY_NUMBER_WARN4 = 16;</code>
     */
    public static final int SEVERITY_NUMBER_WARN4_VALUE = 16;
    /**
     * <code>SEVERITY_NUMBER_ERROR = 17;</code>
     */
    public static final int SEVERITY_NUMBER_ERROR_VALUE = 17;
    /**
     * <code>SEVERITY_NUMBER_ERROR2 = 18;</code>
     */
    public static final int SEVERITY_NUMBER_ERROR2_VALUE = 18;
    /**
     * <code>SEVERITY_NUMBER_ERROR3 = 19;</code>
     */
    public static final int SEVERITY_NUMBER_ERROR3_VALUE = 19;
    /**
     * <code>SEVERITY_NUMBER_ERROR4 = 20;</code>
     */
    public static final int SEVERITY_NUMBER_ERROR4_VALUE = 20;
    /**
     * <code>SEVERITY_NUMBER_FATAL = 21;</code>
     */
    public static final int SEVERITY_NUMBER_FATAL_VALUE = 21;
    /**
     * <code>SEVERITY_NUMBER_FATAL2 = 22;</code>
     */
    public static final int SEVERITY_NUMBER_FATAL2_VALUE = 22;
    /**
     * <code>SEVERITY_NUMBER_FATAL3 = 23;</code>
     */
    public static final int SEVERITY_NUMBER_FATAL3_VALUE = 23;
    /**
     * <code>SEVERITY_NUMBER_FATAL4 = 24;</code>
     */
    public static final int SEVERITY_NUMBER_FATAL4_VALUE = 24;


    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static SeverityNumber valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static SeverityNumber forNumber(int value) {
      switch (value) {
        case 0: return SEVERITY_NUMBER_UNSPECIFIED;
        case 1: return SEVERITY_NUMBER_TRACE;
        case 2: return SEVERITY_NUMBER_TRACE2;
        case 3: return SEVERITY_NUMBER_TRACE3;
        case 4: return SEVERITY_NUMBER_TRACE4;
        case 5: return SEVERITY_NUMBER_DEBUG;
        case 6: return SEVERITY_NUMBER_DEBUG2;
        case 7: return SEVERITY_NUMBER_DEBUG3;
        case 8: return SEVERITY_NUMBER_DEBUG4;
        case 9: return SEVERITY_NUMBER_INFO;
        case 10: return SEVERITY_NUMBER_INFO2;
        case 11: return SEVERITY_NUMBER_INFO3;
        case 12: return SEVERITY_NUMBER_INFO4;
        case 13: return SEVERITY_NUMBER_WARN;
        case 14: return SEVERITY_NUMBER_WARN2;
        case 15: return SEVERITY_NUMBER_WARN3;
        case 16: return SEVERITY_NUMBER_WARN4;
        case 17: return SEVERITY_NUMBER_ERROR;
        case 18: return SEVERITY_NUMBER_ERROR2;
        case 19: return SEVERITY_NUMBER_ERROR3;
        case 20: return SEVERITY_NUMBER_ERROR4;
        case 21: return SEVERITY_NUMBER_FATAL;
        case 22: return SEVERITY_NUMBER_FATAL2;
        case 23: return SEVERITY_NUMBER_FATAL3;
        case 24: return SEVERITY_NUMBER_FATAL4;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<SeverityNumber>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        SeverityNumber> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<SeverityNumber>() {
            public SeverityNumber findValueByNumber(int number) {
              return SeverityNumber.forNumber(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return opentelemetry.proto.mmap.v1.Mmap.getDescriptor().getEnumTypes().get(1);
    }

    private static final SeverityNumber[] VALUES = values();

    public static SeverityNumber valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private SeverityNumber(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:opentelemetry.proto.mmap.v1.SeverityNumber)
  }

  public interface SpanEventOrBuilder extends
      // @@protoc_insertion_point(interface_extends:opentelemetry.proto.mmap.v1.SpanEvent)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * InsturmentationScope from which this was recorded.
     * </pre>
     *
     * <code>int64 scope_ref = 20;</code>
     * @return The scopeRef.
     */
    long getScopeRef();

    /**
     * <pre>
     * A unique identifier for a trace. All spans from the same trace share
     * the same `trace_id`. The ID is a 16-byte array. An ID with all zeroes OR
     * of length other than 16 bytes is considered invalid (empty string in OTLP/JSON
     * is zero-length and thus is also invalid).
     *
     * This field is required.
     * </pre>
     *
     * <code>bytes trace_id = 1;</code>
     * @return The traceId.
     */
    com.google.protobuf.ByteString getTraceId();

    /**
     * <pre>
     * A unique identifier for a span within a trace, assigned when the span
     * is created. The ID is an 8-byte array. An ID with all zeroes OR of length
     * other than 8 bytes is considered invalid (empty string in OTLP/JSON
     * is zero-length and thus is also invalid).
     *
     * This field is required.
     * </pre>
     *
     * <code>bytes span_id = 2;</code>
     * @return The spanId.
     */
    com.google.protobuf.ByteString getSpanId();

    /**
     * <code>.opentelemetry.proto.mmap.v1.SpanEvent.StartSpan start = 11;</code>
     * @return Whether the start field is set.
     */
    boolean hasStart();
    /**
     * <code>.opentelemetry.proto.mmap.v1.SpanEvent.StartSpan start = 11;</code>
     * @return The start.
     */
    opentelemetry.proto.mmap.v1.Mmap.SpanEvent.StartSpan getStart();
    /**
     * <code>.opentelemetry.proto.mmap.v1.SpanEvent.StartSpan start = 11;</code>
     */
    opentelemetry.proto.mmap.v1.Mmap.SpanEvent.StartSpanOrBuilder getStartOrBuilder();

    /**
     * <code>.opentelemetry.proto.mmap.v1.SpanEvent.EndSpan end = 12;</code>
     * @return Whether the end field is set.
     */
    boolean hasEnd();
    /**
     * <code>.opentelemetry.proto.mmap.v1.SpanEvent.EndSpan end = 12;</code>
     * @return The end.
     */
    opentelemetry.proto.mmap.v1.Mmap.SpanEvent.EndSpan getEnd();
    /**
     * <code>.opentelemetry.proto.mmap.v1.SpanEvent.EndSpan end = 12;</code>
     */
    opentelemetry.proto.mmap.v1.Mmap.SpanEvent.EndSpanOrBuilder getEndOrBuilder();

    /**
     * <code>.opentelemetry.proto.mmap.v1.SpanEvent.ChangeSpanName name = 13;</code>
     * @return Whether the name field is set.
     */
    boolean hasName();
    /**
     * <code>.opentelemetry.proto.mmap.v1.SpanEvent.ChangeSpanName name = 13;</code>
     * @return The name.
     */
    opentelemetry.proto.mmap.v1.Mmap.SpanEvent.ChangeSpanName getName();
    /**
     * <code>.opentelemetry.proto.mmap.v1.SpanEvent.ChangeSpanName name = 13;</code>
     */
    opentelemetry.proto.mmap.v1.Mmap.SpanEvent.ChangeSpanNameOrBuilder getNameOrBuilder();

    /**
     * <code>.opentelemetry.proto.mmap.v1.SpanEvent.UpdateAttributes attributes = 14;</code>
     * @return Whether the attributes field is set.
     */
    boolean hasAttributes();
    /**
     * <code>.opentelemetry.proto.mmap.v1.SpanEvent.UpdateAttributes attributes = 14;</code>
     * @return The attributes.
     */
    opentelemetry.proto.mmap.v1.Mmap.SpanEvent.UpdateAttributes getAttributes();
    /**
     * <code>.opentelemetry.proto.mmap.v1.SpanEvent.UpdateAttributes attributes = 14;</code>
     */
    opentelemetry.proto.mmap.v1.Mmap.SpanEvent.UpdateAttributesOrBuilder getAttributesOrBuilder();

    /**
     * <code>.opentelemetry.proto.mmap.v1.SpanEvent.AddLink link = 15;</code>
     * @return Whether the link field is set.
     */
    boolean hasLink();
    /**
     * <code>.opentelemetry.proto.mmap.v1.SpanEvent.AddLink link = 15;</code>
     * @return The link.
     */
    opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink getLink();
    /**
     * <code>.opentelemetry.proto.mmap.v1.SpanEvent.AddLink link = 15;</code>
     */
    opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLinkOrBuilder getLinkOrBuilder();

    opentelemetry.proto.mmap.v1.Mmap.SpanEvent.EventCase getEventCase();
  }
  /**
   * Protobuf type {@code opentelemetry.proto.mmap.v1.SpanEvent}
   */
  public static final class SpanEvent extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:opentelemetry.proto.mmap.v1.SpanEvent)
      SpanEventOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 33,
        /* patch= */ 0,
        /* suffix= */ "",
        "SpanEvent");
    }
    // Use SpanEvent.newBuilder() to construct.
    private SpanEvent(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private SpanEvent() {
      traceId_ = com.google.protobuf.ByteString.EMPTY;
      spanId_ = com.google.protobuf.ByteString.EMPTY;
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_SpanEvent_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_SpanEvent_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              opentelemetry.proto.mmap.v1.Mmap.SpanEvent.class, opentelemetry.proto.mmap.v1.Mmap.SpanEvent.Builder.class);
    }

    public interface StartSpanOrBuilder extends
        // @@protoc_insertion_point(interface_extends:opentelemetry.proto.mmap.v1.SpanEvent.StartSpan)
        com.google.protobuf.MessageOrBuilder {

      /**
       * <pre>
       * The `span_id` of this span's parent span. If this is a root span, then this
       * field must be empty. The ID is an 8-byte array.
       * </pre>
       *
       * <code>bytes parent_span_id = 4;</code>
       * @return The parentSpanId.
       */
      com.google.protobuf.ByteString getParentSpanId();

      /**
       * <pre>
       * Flags, a bit field.
       *
       * Bits 0-7 (8 least significant bits) are the trace flags as defined in W3C Trace
       * Context specification. To read the 8-bit W3C trace flag, use
       * `flags &amp; SPAN_FLAGS_TRACE_FLAGS_MASK`.
       *
       * See https://www.w3.org/TR/trace-context-2/#trace-flags for the flag definitions.
       *
       * Bits 8 and 9 represent the 3 states of whether a span's parent
       * is remote. The states are (unknown, is not remote, is remote).
       * To read whether the value is known, use `(flags &amp; SPAN_FLAGS_CONTEXT_HAS_IS_REMOTE_MASK) != 0`.
       * To read whether the span is remote, use `(flags &amp; SPAN_FLAGS_CONTEXT_IS_REMOTE_MASK) != 0`.
       *
       * When creating span messages, if the message is logically forwarded from another source
       * with an equivalent flags fields (i.e., usually another OTLP span message), the field SHOULD
       * be copied as-is. If creating from a source that does not have an equivalent flags field
       * (such as a runtime representation of an OpenTelemetry span), the high 22 bits MUST
       * be set to zero.
       * Readers MUST NOT assume that bits 10-31 (22 most significant bits) will be zero.
       *
       * [Optional].
       * </pre>
       *
       * <code>fixed32 flags = 16;</code>
       * @return The flags.
       */
      int getFlags();

      /**
       * <pre>
       * A description of the span's operation.
       *
       * For example, the name can be a qualified method name or a file name
       * and a line number where the operation is called. A best practice is to use
       * the same display name at the same call point in an application.
       * This makes it easier to correlate spans in different traces.
       *
       * This field is semantically required to be set to non-empty string.
       * Empty value is equivalent to an unknown span name.
       *
       * This field is required.
       * </pre>
       *
       * <code>string name = 5;</code>
       * @return The name.
       */
      java.lang.String getName();
      /**
       * <pre>
       * A description of the span's operation.
       *
       * For example, the name can be a qualified method name or a file name
       * and a line number where the operation is called. A best practice is to use
       * the same display name at the same call point in an application.
       * This makes it easier to correlate spans in different traces.
       *
       * This field is semantically required to be set to non-empty string.
       * Empty value is equivalent to an unknown span name.
       *
       * This field is required.
       * </pre>
       *
       * <code>string name = 5;</code>
       * @return The bytes for name.
       */
      com.google.protobuf.ByteString
          getNameBytes();

      /**
       * <pre>
       * Distinguishes between spans generated in a particular context. For example,
       * two spans with the same name may be distinguished using `CLIENT` (caller)
       * and `SERVER` (callee) to identify queueing latency associated with the span.
       * </pre>
       *
       * <code>.opentelemetry.proto.mmap.v1.SpanEvent.StartSpan.SpanKind kind = 6;</code>
       * @return The enum numeric value on the wire for kind.
       */
      int getKindValue();
      /**
       * <pre>
       * Distinguishes between spans generated in a particular context. For example,
       * two spans with the same name may be distinguished using `CLIENT` (caller)
       * and `SERVER` (callee) to identify queueing latency associated with the span.
       * </pre>
       *
       * <code>.opentelemetry.proto.mmap.v1.SpanEvent.StartSpan.SpanKind kind = 6;</code>
       * @return The kind.
       */
      opentelemetry.proto.mmap.v1.Mmap.SpanEvent.StartSpan.SpanKind getKind();

      /**
       * <pre>
       * The start time of the span. On the client side, this is the time
       * kept by the local machine where the span execution starts. On the server side, this
       * is the time when the server's application handler starts running.
       * Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January 1970.
       *
       * This field is semantically required and it is expected that end_time &gt;= start_time.
       * </pre>
       *
       * <code>fixed64 start_time_unix_nano = 7;</code>
       * @return The startTimeUnixNano.
       */
      long getStartTimeUnixNano();

      /**
       * <pre>
       * A collection of key/value pairs. Note, global attributes
       * like server name can be set using the resource API. Examples of attributes:
       *
       * "/http/user_agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"
       * "/http/server_latency": 300
       * "example.com/myattribute": true
       * "example.com/score": 10.239
       *
       * Attribute keys MUST be unique (it is not allowed to have more than one
       * attribute with the same key).
       *
       * The attribute values SHOULD NOT contain empty values.
       * The attribute values SHOULD NOT contain bytes values.
       * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
       * double values.
       * The attribute values SHOULD NOT contain kvlist values.
       * The behavior of software that receives attributes containing such values can be unpredictable.
       * These restrictions can change in a minor release.
       * The restrictions take origin from the OpenTelemetry specification:
       * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 9;</code>
       */
      java.util.List<opentelemetry.proto.mmap.v1.Mmap.KeyValueRef> 
          getAttributesList();
      /**
       * <pre>
       * A collection of key/value pairs. Note, global attributes
       * like server name can be set using the resource API. Examples of attributes:
       *
       * "/http/user_agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"
       * "/http/server_latency": 300
       * "example.com/myattribute": true
       * "example.com/score": 10.239
       *
       * Attribute keys MUST be unique (it is not allowed to have more than one
       * attribute with the same key).
       *
       * The attribute values SHOULD NOT contain empty values.
       * The attribute values SHOULD NOT contain bytes values.
       * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
       * double values.
       * The attribute values SHOULD NOT contain kvlist values.
       * The behavior of software that receives attributes containing such values can be unpredictable.
       * These restrictions can change in a minor release.
       * The restrictions take origin from the OpenTelemetry specification:
       * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 9;</code>
       */
      opentelemetry.proto.mmap.v1.Mmap.KeyValueRef getAttributes(int index);
      /**
       * <pre>
       * A collection of key/value pairs. Note, global attributes
       * like server name can be set using the resource API. Examples of attributes:
       *
       * "/http/user_agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"
       * "/http/server_latency": 300
       * "example.com/myattribute": true
       * "example.com/score": 10.239
       *
       * Attribute keys MUST be unique (it is not allowed to have more than one
       * attribute with the same key).
       *
       * The attribute values SHOULD NOT contain empty values.
       * The attribute values SHOULD NOT contain bytes values.
       * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
       * double values.
       * The attribute values SHOULD NOT contain kvlist values.
       * The behavior of software that receives attributes containing such values can be unpredictable.
       * These restrictions can change in a minor release.
       * The restrictions take origin from the OpenTelemetry specification:
       * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 9;</code>
       */
      int getAttributesCount();
      /**
       * <pre>
       * A collection of key/value pairs. Note, global attributes
       * like server name can be set using the resource API. Examples of attributes:
       *
       * "/http/user_agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"
       * "/http/server_latency": 300
       * "example.com/myattribute": true
       * "example.com/score": 10.239
       *
       * Attribute keys MUST be unique (it is not allowed to have more than one
       * attribute with the same key).
       *
       * The attribute values SHOULD NOT contain empty values.
       * The attribute values SHOULD NOT contain bytes values.
       * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
       * double values.
       * The attribute values SHOULD NOT contain kvlist values.
       * The behavior of software that receives attributes containing such values can be unpredictable.
       * These restrictions can change in a minor release.
       * The restrictions take origin from the OpenTelemetry specification:
       * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 9;</code>
       */
      java.util.List<? extends opentelemetry.proto.mmap.v1.Mmap.KeyValueRefOrBuilder> 
          getAttributesOrBuilderList();
      /**
       * <pre>
       * A collection of key/value pairs. Note, global attributes
       * like server name can be set using the resource API. Examples of attributes:
       *
       * "/http/user_agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"
       * "/http/server_latency": 300
       * "example.com/myattribute": true
       * "example.com/score": 10.239
       *
       * Attribute keys MUST be unique (it is not allowed to have more than one
       * attribute with the same key).
       *
       * The attribute values SHOULD NOT contain empty values.
       * The attribute values SHOULD NOT contain bytes values.
       * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
       * double values.
       * The attribute values SHOULD NOT contain kvlist values.
       * The behavior of software that receives attributes containing such values can be unpredictable.
       * These restrictions can change in a minor release.
       * The restrictions take origin from the OpenTelemetry specification:
       * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 9;</code>
       */
      opentelemetry.proto.mmap.v1.Mmap.KeyValueRefOrBuilder getAttributesOrBuilder(
          int index);
    }
    /**
     * Protobuf type {@code opentelemetry.proto.mmap.v1.SpanEvent.StartSpan}
     */
    public static final class StartSpan extends
        com.google.protobuf.GeneratedMessage implements
        // @@protoc_insertion_point(message_implements:opentelemetry.proto.mmap.v1.SpanEvent.StartSpan)
        StartSpanOrBuilder {
    private static final long serialVersionUID = 0L;
      static {
        com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
          com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
          /* major= */ 4,
          /* minor= */ 33,
          /* patch= */ 0,
          /* suffix= */ "",
          "StartSpan");
      }
      // Use StartSpan.newBuilder() to construct.
      private StartSpan(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
        super(builder);
      }
      private StartSpan() {
        parentSpanId_ = com.google.protobuf.ByteString.EMPTY;
        name_ = "";
        kind_ = 0;
        attributes_ = java.util.Collections.emptyList();
      }

      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_SpanEvent_StartSpan_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_SpanEvent_StartSpan_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                opentelemetry.proto.mmap.v1.Mmap.SpanEvent.StartSpan.class, opentelemetry.proto.mmap.v1.Mmap.SpanEvent.StartSpan.Builder.class);
      }

      /**
       * <pre>
       * SpanKind is the type of span. Can be used to specify additional relationships between spans
       * in addition to a parent/child relationship.
       * </pre>
       *
       * Protobuf enum {@code opentelemetry.proto.mmap.v1.SpanEvent.StartSpan.SpanKind}
       */
      public enum SpanKind
          implements com.google.protobuf.ProtocolMessageEnum {
        /**
         * <pre>
         * Unspecified. Do NOT use as default.
         * Implementations MAY assume SpanKind to be INTERNAL when receiving UNSPECIFIED.
         * </pre>
         *
         * <code>SPAN_KIND_UNSPECIFIED = 0;</code>
         */
        SPAN_KIND_UNSPECIFIED(0),
        /**
         * <pre>
         * Indicates that the span represents an internal operation within an application,
         * as opposed to an operation happening at the boundaries. Default value.
         * </pre>
         *
         * <code>SPAN_KIND_INTERNAL = 1;</code>
         */
        SPAN_KIND_INTERNAL(1),
        /**
         * <pre>
         * Indicates that the span covers server-side handling of an RPC or other
         * remote network request.
         * </pre>
         *
         * <code>SPAN_KIND_SERVER = 2;</code>
         */
        SPAN_KIND_SERVER(2),
        /**
         * <pre>
         * Indicates that the span describes a request to some remote service.
         * </pre>
         *
         * <code>SPAN_KIND_CLIENT = 3;</code>
         */
        SPAN_KIND_CLIENT(3),
        /**
         * <pre>
         * Indicates that the span describes a producer sending a message to a broker.
         * Unlike CLIENT and SERVER, there is often no direct critical path latency relationship
         * between producer and consumer spans. A PRODUCER span ends when the message was accepted
         * by the broker while the logical processing of the message might span a much longer time.
         * </pre>
         *
         * <code>SPAN_KIND_PRODUCER = 4;</code>
         */
        SPAN_KIND_PRODUCER(4),
        /**
         * <pre>
         * Indicates that the span describes consumer receiving a message from a broker.
         * Like the PRODUCER kind, there is often no direct critical path latency relationship
         * between producer and consumer spans.
         * </pre>
         *
         * <code>SPAN_KIND_CONSUMER = 5;</code>
         */
        SPAN_KIND_CONSUMER(5),
        UNRECOGNIZED(-1),
        ;

        static {
          com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
            com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
            /* major= */ 4,
            /* minor= */ 33,
            /* patch= */ 0,
            /* suffix= */ "",
            "SpanKind");
        }
        /**
         * <pre>
         * Unspecified. Do NOT use as default.
         * Implementations MAY assume SpanKind to be INTERNAL when receiving UNSPECIFIED.
         * </pre>
         *
         * <code>SPAN_KIND_UNSPECIFIED = 0;</code>
         */
        public static final int SPAN_KIND_UNSPECIFIED_VALUE = 0;
        /**
         * <pre>
         * Indicates that the span represents an internal operation within an application,
         * as opposed to an operation happening at the boundaries. Default value.
         * </pre>
         *
         * <code>SPAN_KIND_INTERNAL = 1;</code>
         */
        public static final int SPAN_KIND_INTERNAL_VALUE = 1;
        /**
         * <pre>
         * Indicates that the span covers server-side handling of an RPC or other
         * remote network request.
         * </pre>
         *
         * <code>SPAN_KIND_SERVER = 2;</code>
         */
        public static final int SPAN_KIND_SERVER_VALUE = 2;
        /**
         * <pre>
         * Indicates that the span describes a request to some remote service.
         * </pre>
         *
         * <code>SPAN_KIND_CLIENT = 3;</code>
         */
        public static final int SPAN_KIND_CLIENT_VALUE = 3;
        /**
         * <pre>
         * Indicates that the span describes a producer sending a message to a broker.
         * Unlike CLIENT and SERVER, there is often no direct critical path latency relationship
         * between producer and consumer spans. A PRODUCER span ends when the message was accepted
         * by the broker while the logical processing of the message might span a much longer time.
         * </pre>
         *
         * <code>SPAN_KIND_PRODUCER = 4;</code>
         */
        public static final int SPAN_KIND_PRODUCER_VALUE = 4;
        /**
         * <pre>
         * Indicates that the span describes consumer receiving a message from a broker.
         * Like the PRODUCER kind, there is often no direct critical path latency relationship
         * between producer and consumer spans.
         * </pre>
         *
         * <code>SPAN_KIND_CONSUMER = 5;</code>
         */
        public static final int SPAN_KIND_CONSUMER_VALUE = 5;


        public final int getNumber() {
          if (this == UNRECOGNIZED) {
            throw new java.lang.IllegalArgumentException(
                "Can't get the number of an unknown enum value.");
          }
          return value;
        }

        /**
         * @param value The numeric wire value of the corresponding enum entry.
         * @return The enum associated with the given numeric wire value.
         * @deprecated Use {@link #forNumber(int)} instead.
         */
        @java.lang.Deprecated
        public static SpanKind valueOf(int value) {
          return forNumber(value);
        }

        /**
         * @param value The numeric wire value of the corresponding enum entry.
         * @return The enum associated with the given numeric wire value.
         */
        public static SpanKind forNumber(int value) {
          switch (value) {
            case 0: return SPAN_KIND_UNSPECIFIED;
            case 1: return SPAN_KIND_INTERNAL;
            case 2: return SPAN_KIND_SERVER;
            case 3: return SPAN_KIND_CLIENT;
            case 4: return SPAN_KIND_PRODUCER;
            case 5: return SPAN_KIND_CONSUMER;
            default: return null;
          }
        }

        public static com.google.protobuf.Internal.EnumLiteMap<SpanKind>
            internalGetValueMap() {
          return internalValueMap;
        }
        private static final com.google.protobuf.Internal.EnumLiteMap<
            SpanKind> internalValueMap =
              new com.google.protobuf.Internal.EnumLiteMap<SpanKind>() {
                public SpanKind findValueByNumber(int number) {
                  return SpanKind.forNumber(number);
                }
              };

        public final com.google.protobuf.Descriptors.EnumValueDescriptor
            getValueDescriptor() {
          if (this == UNRECOGNIZED) {
            throw new java.lang.IllegalStateException(
                "Can't get the descriptor of an unrecognized enum value.");
          }
          return getDescriptor().getValues().get(ordinal());
        }
        public final com.google.protobuf.Descriptors.EnumDescriptor
            getDescriptorForType() {
          return getDescriptor();
        }
        public static com.google.protobuf.Descriptors.EnumDescriptor
            getDescriptor() {
          return opentelemetry.proto.mmap.v1.Mmap.SpanEvent.StartSpan.getDescriptor().getEnumTypes().get(0);
        }

        private static final SpanKind[] VALUES = values();

        public static SpanKind valueOf(
            com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
          if (desc.getType() != getDescriptor()) {
            throw new java.lang.IllegalArgumentException(
              "EnumValueDescriptor is not for this type.");
          }
          if (desc.getIndex() == -1) {
            return UNRECOGNIZED;
          }
          return VALUES[desc.getIndex()];
        }

        private final int value;

        private SpanKind(int value) {
          this.value = value;
        }

        // @@protoc_insertion_point(enum_scope:opentelemetry.proto.mmap.v1.SpanEvent.StartSpan.SpanKind)
      }

      public static final int PARENT_SPAN_ID_FIELD_NUMBER = 4;
      private com.google.protobuf.ByteString parentSpanId_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       * The `span_id` of this span's parent span. If this is a root span, then this
       * field must be empty. The ID is an 8-byte array.
       * </pre>
       *
       * <code>bytes parent_span_id = 4;</code>
       * @return The parentSpanId.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getParentSpanId() {
        return parentSpanId_;
      }

      public static final int FLAGS_FIELD_NUMBER = 16;
      private int flags_ = 0;
      /**
       * <pre>
       * Flags, a bit field.
       *
       * Bits 0-7 (8 least significant bits) are the trace flags as defined in W3C Trace
       * Context specification. To read the 8-bit W3C trace flag, use
       * `flags &amp; SPAN_FLAGS_TRACE_FLAGS_MASK`.
       *
       * See https://www.w3.org/TR/trace-context-2/#trace-flags for the flag definitions.
       *
       * Bits 8 and 9 represent the 3 states of whether a span's parent
       * is remote. The states are (unknown, is not remote, is remote).
       * To read whether the value is known, use `(flags &amp; SPAN_FLAGS_CONTEXT_HAS_IS_REMOTE_MASK) != 0`.
       * To read whether the span is remote, use `(flags &amp; SPAN_FLAGS_CONTEXT_IS_REMOTE_MASK) != 0`.
       *
       * When creating span messages, if the message is logically forwarded from another source
       * with an equivalent flags fields (i.e., usually another OTLP span message), the field SHOULD
       * be copied as-is. If creating from a source that does not have an equivalent flags field
       * (such as a runtime representation of an OpenTelemetry span), the high 22 bits MUST
       * be set to zero.
       * Readers MUST NOT assume that bits 10-31 (22 most significant bits) will be zero.
       *
       * [Optional].
       * </pre>
       *
       * <code>fixed32 flags = 16;</code>
       * @return The flags.
       */
      @java.lang.Override
      public int getFlags() {
        return flags_;
      }

      public static final int NAME_FIELD_NUMBER = 5;
      @SuppressWarnings("serial")
      private volatile java.lang.Object name_ = "";
      /**
       * <pre>
       * A description of the span's operation.
       *
       * For example, the name can be a qualified method name or a file name
       * and a line number where the operation is called. A best practice is to use
       * the same display name at the same call point in an application.
       * This makes it easier to correlate spans in different traces.
       *
       * This field is semantically required to be set to non-empty string.
       * Empty value is equivalent to an unknown span name.
       *
       * This field is required.
       * </pre>
       *
       * <code>string name = 5;</code>
       * @return The name.
       */
      @java.lang.Override
      public java.lang.String getName() {
        java.lang.Object ref = name_;
        if (ref instanceof java.lang.String) {
          return (java.lang.String) ref;
        } else {
          com.google.protobuf.ByteString bs = 
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          name_ = s;
          return s;
        }
      }
      /**
       * <pre>
       * A description of the span's operation.
       *
       * For example, the name can be a qualified method name or a file name
       * and a line number where the operation is called. A best practice is to use
       * the same display name at the same call point in an application.
       * This makes it easier to correlate spans in different traces.
       *
       * This field is semantically required to be set to non-empty string.
       * Empty value is equivalent to an unknown span name.
       *
       * This field is required.
       * </pre>
       *
       * <code>string name = 5;</code>
       * @return The bytes for name.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getNameBytes() {
        java.lang.Object ref = name_;
        if (ref instanceof java.lang.String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          name_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }

      public static final int KIND_FIELD_NUMBER = 6;
      private int kind_ = 0;
      /**
       * <pre>
       * Distinguishes between spans generated in a particular context. For example,
       * two spans with the same name may be distinguished using `CLIENT` (caller)
       * and `SERVER` (callee) to identify queueing latency associated with the span.
       * </pre>
       *
       * <code>.opentelemetry.proto.mmap.v1.SpanEvent.StartSpan.SpanKind kind = 6;</code>
       * @return The enum numeric value on the wire for kind.
       */
      @java.lang.Override public int getKindValue() {
        return kind_;
      }
      /**
       * <pre>
       * Distinguishes between spans generated in a particular context. For example,
       * two spans with the same name may be distinguished using `CLIENT` (caller)
       * and `SERVER` (callee) to identify queueing latency associated with the span.
       * </pre>
       *
       * <code>.opentelemetry.proto.mmap.v1.SpanEvent.StartSpan.SpanKind kind = 6;</code>
       * @return The kind.
       */
      @java.lang.Override public opentelemetry.proto.mmap.v1.Mmap.SpanEvent.StartSpan.SpanKind getKind() {
        opentelemetry.proto.mmap.v1.Mmap.SpanEvent.StartSpan.SpanKind result = opentelemetry.proto.mmap.v1.Mmap.SpanEvent.StartSpan.SpanKind.forNumber(kind_);
        return result == null ? opentelemetry.proto.mmap.v1.Mmap.SpanEvent.StartSpan.SpanKind.UNRECOGNIZED : result;
      }

      public static final int START_TIME_UNIX_NANO_FIELD_NUMBER = 7;
      private long startTimeUnixNano_ = 0L;
      /**
       * <pre>
       * The start time of the span. On the client side, this is the time
       * kept by the local machine where the span execution starts. On the server side, this
       * is the time when the server's application handler starts running.
       * Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January 1970.
       *
       * This field is semantically required and it is expected that end_time &gt;= start_time.
       * </pre>
       *
       * <code>fixed64 start_time_unix_nano = 7;</code>
       * @return The startTimeUnixNano.
       */
      @java.lang.Override
      public long getStartTimeUnixNano() {
        return startTimeUnixNano_;
      }

      public static final int ATTRIBUTES_FIELD_NUMBER = 9;
      @SuppressWarnings("serial")
      private java.util.List<opentelemetry.proto.mmap.v1.Mmap.KeyValueRef> attributes_;
      /**
       * <pre>
       * A collection of key/value pairs. Note, global attributes
       * like server name can be set using the resource API. Examples of attributes:
       *
       * "/http/user_agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"
       * "/http/server_latency": 300
       * "example.com/myattribute": true
       * "example.com/score": 10.239
       *
       * Attribute keys MUST be unique (it is not allowed to have more than one
       * attribute with the same key).
       *
       * The attribute values SHOULD NOT contain empty values.
       * The attribute values SHOULD NOT contain bytes values.
       * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
       * double values.
       * The attribute values SHOULD NOT contain kvlist values.
       * The behavior of software that receives attributes containing such values can be unpredictable.
       * These restrictions can change in a minor release.
       * The restrictions take origin from the OpenTelemetry specification:
       * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 9;</code>
       */
      @java.lang.Override
      public java.util.List<opentelemetry.proto.mmap.v1.Mmap.KeyValueRef> getAttributesList() {
        return attributes_;
      }
      /**
       * <pre>
       * A collection of key/value pairs. Note, global attributes
       * like server name can be set using the resource API. Examples of attributes:
       *
       * "/http/user_agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"
       * "/http/server_latency": 300
       * "example.com/myattribute": true
       * "example.com/score": 10.239
       *
       * Attribute keys MUST be unique (it is not allowed to have more than one
       * attribute with the same key).
       *
       * The attribute values SHOULD NOT contain empty values.
       * The attribute values SHOULD NOT contain bytes values.
       * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
       * double values.
       * The attribute values SHOULD NOT contain kvlist values.
       * The behavior of software that receives attributes containing such values can be unpredictable.
       * These restrictions can change in a minor release.
       * The restrictions take origin from the OpenTelemetry specification:
       * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 9;</code>
       */
      @java.lang.Override
      public java.util.List<? extends opentelemetry.proto.mmap.v1.Mmap.KeyValueRefOrBuilder> 
          getAttributesOrBuilderList() {
        return attributes_;
      }
      /**
       * <pre>
       * A collection of key/value pairs. Note, global attributes
       * like server name can be set using the resource API. Examples of attributes:
       *
       * "/http/user_agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"
       * "/http/server_latency": 300
       * "example.com/myattribute": true
       * "example.com/score": 10.239
       *
       * Attribute keys MUST be unique (it is not allowed to have more than one
       * attribute with the same key).
       *
       * The attribute values SHOULD NOT contain empty values.
       * The attribute values SHOULD NOT contain bytes values.
       * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
       * double values.
       * The attribute values SHOULD NOT contain kvlist values.
       * The behavior of software that receives attributes containing such values can be unpredictable.
       * These restrictions can change in a minor release.
       * The restrictions take origin from the OpenTelemetry specification:
       * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 9;</code>
       */
      @java.lang.Override
      public int getAttributesCount() {
        return attributes_.size();
      }
      /**
       * <pre>
       * A collection of key/value pairs. Note, global attributes
       * like server name can be set using the resource API. Examples of attributes:
       *
       * "/http/user_agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"
       * "/http/server_latency": 300
       * "example.com/myattribute": true
       * "example.com/score": 10.239
       *
       * Attribute keys MUST be unique (it is not allowed to have more than one
       * attribute with the same key).
       *
       * The attribute values SHOULD NOT contain empty values.
       * The attribute values SHOULD NOT contain bytes values.
       * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
       * double values.
       * The attribute values SHOULD NOT contain kvlist values.
       * The behavior of software that receives attributes containing such values can be unpredictable.
       * These restrictions can change in a minor release.
       * The restrictions take origin from the OpenTelemetry specification:
       * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 9;</code>
       */
      @java.lang.Override
      public opentelemetry.proto.mmap.v1.Mmap.KeyValueRef getAttributes(int index) {
        return attributes_.get(index);
      }
      /**
       * <pre>
       * A collection of key/value pairs. Note, global attributes
       * like server name can be set using the resource API. Examples of attributes:
       *
       * "/http/user_agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"
       * "/http/server_latency": 300
       * "example.com/myattribute": true
       * "example.com/score": 10.239
       *
       * Attribute keys MUST be unique (it is not allowed to have more than one
       * attribute with the same key).
       *
       * The attribute values SHOULD NOT contain empty values.
       * The attribute values SHOULD NOT contain bytes values.
       * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
       * double values.
       * The attribute values SHOULD NOT contain kvlist values.
       * The behavior of software that receives attributes containing such values can be unpredictable.
       * These restrictions can change in a minor release.
       * The restrictions take origin from the OpenTelemetry specification:
       * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 9;</code>
       */
      @java.lang.Override
      public opentelemetry.proto.mmap.v1.Mmap.KeyValueRefOrBuilder getAttributesOrBuilder(
          int index) {
        return attributes_.get(index);
      }

      private byte memoizedIsInitialized = -1;
      @java.lang.Override
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        memoizedIsInitialized = 1;
        return true;
      }

      @java.lang.Override
      public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        if (!parentSpanId_.isEmpty()) {
          output.writeBytes(4, parentSpanId_);
        }
        if (!com.google.protobuf.GeneratedMessage.isStringEmpty(name_)) {
          com.google.protobuf.GeneratedMessage.writeString(output, 5, name_);
        }
        if (kind_ != opentelemetry.proto.mmap.v1.Mmap.SpanEvent.StartSpan.SpanKind.SPAN_KIND_UNSPECIFIED.getNumber()) {
          output.writeEnum(6, kind_);
        }
        if (startTimeUnixNano_ != 0L) {
          output.writeFixed64(7, startTimeUnixNano_);
        }
        for (int i = 0; i < attributes_.size(); i++) {
          output.writeMessage(9, attributes_.get(i));
        }
        if (flags_ != 0) {
          output.writeFixed32(16, flags_);
        }
        getUnknownFields().writeTo(output);
      }

      @java.lang.Override
      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        if (!parentSpanId_.isEmpty()) {
          size += com.google.protobuf.CodedOutputStream
            .computeBytesSize(4, parentSpanId_);
        }
        if (!com.google.protobuf.GeneratedMessage.isStringEmpty(name_)) {
          size += com.google.protobuf.GeneratedMessage.computeStringSize(5, name_);
        }
        if (kind_ != opentelemetry.proto.mmap.v1.Mmap.SpanEvent.StartSpan.SpanKind.SPAN_KIND_UNSPECIFIED.getNumber()) {
          size += com.google.protobuf.CodedOutputStream
            .computeEnumSize(6, kind_);
        }
        if (startTimeUnixNano_ != 0L) {
          size += com.google.protobuf.CodedOutputStream
            .computeFixed64Size(7, startTimeUnixNano_);
        }
        for (int i = 0; i < attributes_.size(); i++) {
          size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(9, attributes_.get(i));
        }
        if (flags_ != 0) {
          size += com.google.protobuf.CodedOutputStream
            .computeFixed32Size(16, flags_);
        }
        size += getUnknownFields().getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof opentelemetry.proto.mmap.v1.Mmap.SpanEvent.StartSpan)) {
          return super.equals(obj);
        }
        opentelemetry.proto.mmap.v1.Mmap.SpanEvent.StartSpan other = (opentelemetry.proto.mmap.v1.Mmap.SpanEvent.StartSpan) obj;

        if (!getParentSpanId()
            .equals(other.getParentSpanId())) return false;
        if (getFlags()
            != other.getFlags()) return false;
        if (!getName()
            .equals(other.getName())) return false;
        if (kind_ != other.kind_) return false;
        if (getStartTimeUnixNano()
            != other.getStartTimeUnixNano()) return false;
        if (!getAttributesList()
            .equals(other.getAttributesList())) return false;
        if (!getUnknownFields().equals(other.getUnknownFields())) return false;
        return true;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        hash = (37 * hash) + PARENT_SPAN_ID_FIELD_NUMBER;
        hash = (53 * hash) + getParentSpanId().hashCode();
        hash = (37 * hash) + FLAGS_FIELD_NUMBER;
        hash = (53 * hash) + getFlags();
        hash = (37 * hash) + NAME_FIELD_NUMBER;
        hash = (53 * hash) + getName().hashCode();
        hash = (37 * hash) + KIND_FIELD_NUMBER;
        hash = (53 * hash) + kind_;
        hash = (37 * hash) + START_TIME_UNIX_NANO_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getStartTimeUnixNano());
        if (getAttributesCount() > 0) {
          hash = (37 * hash) + ATTRIBUTES_FIELD_NUMBER;
          hash = (53 * hash) + getAttributesList().hashCode();
        }
        hash = (29 * hash) + getUnknownFields().hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static opentelemetry.proto.mmap.v1.Mmap.SpanEvent.StartSpan parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static opentelemetry.proto.mmap.v1.Mmap.SpanEvent.StartSpan parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static opentelemetry.proto.mmap.v1.Mmap.SpanEvent.StartSpan parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static opentelemetry.proto.mmap.v1.Mmap.SpanEvent.StartSpan parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static opentelemetry.proto.mmap.v1.Mmap.SpanEvent.StartSpan parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static opentelemetry.proto.mmap.v1.Mmap.SpanEvent.StartSpan parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static opentelemetry.proto.mmap.v1.Mmap.SpanEvent.StartSpan parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input);
      }
      public static opentelemetry.proto.mmap.v1.Mmap.SpanEvent.StartSpan parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      public static opentelemetry.proto.mmap.v1.Mmap.SpanEvent.StartSpan parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseDelimitedWithIOException(PARSER, input);
      }

      public static opentelemetry.proto.mmap.v1.Mmap.SpanEvent.StartSpan parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static opentelemetry.proto.mmap.v1.Mmap.SpanEvent.StartSpan parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input);
      }
      public static opentelemetry.proto.mmap.v1.Mmap.SpanEvent.StartSpan parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      @java.lang.Override
      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(opentelemetry.proto.mmap.v1.Mmap.SpanEvent.StartSpan prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      @java.lang.Override
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * Protobuf type {@code opentelemetry.proto.mmap.v1.SpanEvent.StartSpan}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessage.Builder<Builder> implements
          // @@protoc_insertion_point(builder_implements:opentelemetry.proto.mmap.v1.SpanEvent.StartSpan)
          opentelemetry.proto.mmap.v1.Mmap.SpanEvent.StartSpanOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_SpanEvent_StartSpan_descriptor;
        }

        @java.lang.Override
        protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_SpanEvent_StartSpan_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  opentelemetry.proto.mmap.v1.Mmap.SpanEvent.StartSpan.class, opentelemetry.proto.mmap.v1.Mmap.SpanEvent.StartSpan.Builder.class);
        }

        // Construct using opentelemetry.proto.mmap.v1.Mmap.SpanEvent.StartSpan.newBuilder()
        private Builder() {

        }

        private Builder(
            com.google.protobuf.GeneratedMessage.BuilderParent parent) {
          super(parent);

        }
        @java.lang.Override
        public Builder clear() {
          super.clear();
          bitField0_ = 0;
          parentSpanId_ = com.google.protobuf.ByteString.EMPTY;
          flags_ = 0;
          name_ = "";
          kind_ = 0;
          startTimeUnixNano_ = 0L;
          if (attributesBuilder_ == null) {
            attributes_ = java.util.Collections.emptyList();
          } else {
            attributes_ = null;
            attributesBuilder_.clear();
          }
          bitField0_ = (bitField0_ & ~0x00000020);
          return this;
        }

        @java.lang.Override
        public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_SpanEvent_StartSpan_descriptor;
        }

        @java.lang.Override
        public opentelemetry.proto.mmap.v1.Mmap.SpanEvent.StartSpan getDefaultInstanceForType() {
          return opentelemetry.proto.mmap.v1.Mmap.SpanEvent.StartSpan.getDefaultInstance();
        }

        @java.lang.Override
        public opentelemetry.proto.mmap.v1.Mmap.SpanEvent.StartSpan build() {
          opentelemetry.proto.mmap.v1.Mmap.SpanEvent.StartSpan result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        @java.lang.Override
        public opentelemetry.proto.mmap.v1.Mmap.SpanEvent.StartSpan buildPartial() {
          opentelemetry.proto.mmap.v1.Mmap.SpanEvent.StartSpan result = new opentelemetry.proto.mmap.v1.Mmap.SpanEvent.StartSpan(this);
          buildPartialRepeatedFields(result);
          if (bitField0_ != 0) { buildPartial0(result); }
          onBuilt();
          return result;
        }

        private void buildPartialRepeatedFields(opentelemetry.proto.mmap.v1.Mmap.SpanEvent.StartSpan result) {
          if (attributesBuilder_ == null) {
            if (((bitField0_ & 0x00000020) != 0)) {
              attributes_ = java.util.Collections.unmodifiableList(attributes_);
              bitField0_ = (bitField0_ & ~0x00000020);
            }
            result.attributes_ = attributes_;
          } else {
            result.attributes_ = attributesBuilder_.build();
          }
        }

        private void buildPartial0(opentelemetry.proto.mmap.v1.Mmap.SpanEvent.StartSpan result) {
          int from_bitField0_ = bitField0_;
          if (((from_bitField0_ & 0x00000001) != 0)) {
            result.parentSpanId_ = parentSpanId_;
          }
          if (((from_bitField0_ & 0x00000002) != 0)) {
            result.flags_ = flags_;
          }
          if (((from_bitField0_ & 0x00000004) != 0)) {
            result.name_ = name_;
          }
          if (((from_bitField0_ & 0x00000008) != 0)) {
            result.kind_ = kind_;
          }
          if (((from_bitField0_ & 0x00000010) != 0)) {
            result.startTimeUnixNano_ = startTimeUnixNano_;
          }
        }

        @java.lang.Override
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other instanceof opentelemetry.proto.mmap.v1.Mmap.SpanEvent.StartSpan) {
            return mergeFrom((opentelemetry.proto.mmap.v1.Mmap.SpanEvent.StartSpan)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(opentelemetry.proto.mmap.v1.Mmap.SpanEvent.StartSpan other) {
          if (other == opentelemetry.proto.mmap.v1.Mmap.SpanEvent.StartSpan.getDefaultInstance()) return this;
          if (!other.getParentSpanId().isEmpty()) {
            setParentSpanId(other.getParentSpanId());
          }
          if (other.getFlags() != 0) {
            setFlags(other.getFlags());
          }
          if (!other.getName().isEmpty()) {
            name_ = other.name_;
            bitField0_ |= 0x00000004;
            onChanged();
          }
          if (other.kind_ != 0) {
            setKindValue(other.getKindValue());
          }
          if (other.getStartTimeUnixNano() != 0L) {
            setStartTimeUnixNano(other.getStartTimeUnixNano());
          }
          if (attributesBuilder_ == null) {
            if (!other.attributes_.isEmpty()) {
              if (attributes_.isEmpty()) {
                attributes_ = other.attributes_;
                bitField0_ = (bitField0_ & ~0x00000020);
              } else {
                ensureAttributesIsMutable();
                attributes_.addAll(other.attributes_);
              }
              onChanged();
            }
          } else {
            if (!other.attributes_.isEmpty()) {
              if (attributesBuilder_.isEmpty()) {
                attributesBuilder_.dispose();
                attributesBuilder_ = null;
                attributes_ = other.attributes_;
                bitField0_ = (bitField0_ & ~0x00000020);
                attributesBuilder_ = 
                  com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                     internalGetAttributesFieldBuilder() : null;
              } else {
                attributesBuilder_.addAllMessages(other.attributes_);
              }
            }
          }
          this.mergeUnknownFields(other.getUnknownFields());
          onChanged();
          return this;
        }

        @java.lang.Override
        public final boolean isInitialized() {
          return true;
        }

        @java.lang.Override
        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          if (extensionRegistry == null) {
            throw new java.lang.NullPointerException();
          }
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                case 34: {
                  parentSpanId_ = input.readBytes();
                  bitField0_ |= 0x00000001;
                  break;
                } // case 34
                case 42: {
                  name_ = input.readStringRequireUtf8();
                  bitField0_ |= 0x00000004;
                  break;
                } // case 42
                case 48: {
                  kind_ = input.readEnum();
                  bitField0_ |= 0x00000008;
                  break;
                } // case 48
                case 57: {
                  startTimeUnixNano_ = input.readFixed64();
                  bitField0_ |= 0x00000010;
                  break;
                } // case 57
                case 74: {
                  opentelemetry.proto.mmap.v1.Mmap.KeyValueRef m =
                      input.readMessage(
                          opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.parser(),
                          extensionRegistry);
                  if (attributesBuilder_ == null) {
                    ensureAttributesIsMutable();
                    attributes_.add(m);
                  } else {
                    attributesBuilder_.addMessage(m);
                  }
                  break;
                } // case 74
                case 133: {
                  flags_ = input.readFixed32();
                  bitField0_ |= 0x00000002;
                  break;
                } // case 133
                default: {
                  if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                    done = true; // was an endgroup tag
                  }
                  break;
                } // default:
              } // switch (tag)
            } // while (!done)
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.unwrapIOException();
          } finally {
            onChanged();
          } // finally
          return this;
        }
        private int bitField0_;

        private com.google.protobuf.ByteString parentSpanId_ = com.google.protobuf.ByteString.EMPTY;
        /**
         * <pre>
         * The `span_id` of this span's parent span. If this is a root span, then this
         * field must be empty. The ID is an 8-byte array.
         * </pre>
         *
         * <code>bytes parent_span_id = 4;</code>
         * @return The parentSpanId.
         */
        @java.lang.Override
        public com.google.protobuf.ByteString getParentSpanId() {
          return parentSpanId_;
        }
        /**
         * <pre>
         * The `span_id` of this span's parent span. If this is a root span, then this
         * field must be empty. The ID is an 8-byte array.
         * </pre>
         *
         * <code>bytes parent_span_id = 4;</code>
         * @param value The parentSpanId to set.
         * @return This builder for chaining.
         */
        public Builder setParentSpanId(com.google.protobuf.ByteString value) {
          if (value == null) { throw new NullPointerException(); }
          parentSpanId_ = value;
          bitField0_ |= 0x00000001;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * The `span_id` of this span's parent span. If this is a root span, then this
         * field must be empty. The ID is an 8-byte array.
         * </pre>
         *
         * <code>bytes parent_span_id = 4;</code>
         * @return This builder for chaining.
         */
        public Builder clearParentSpanId() {
          bitField0_ = (bitField0_ & ~0x00000001);
          parentSpanId_ = getDefaultInstance().getParentSpanId();
          onChanged();
          return this;
        }

        private int flags_ ;
        /**
         * <pre>
         * Flags, a bit field.
         *
         * Bits 0-7 (8 least significant bits) are the trace flags as defined in W3C Trace
         * Context specification. To read the 8-bit W3C trace flag, use
         * `flags &amp; SPAN_FLAGS_TRACE_FLAGS_MASK`.
         *
         * See https://www.w3.org/TR/trace-context-2/#trace-flags for the flag definitions.
         *
         * Bits 8 and 9 represent the 3 states of whether a span's parent
         * is remote. The states are (unknown, is not remote, is remote).
         * To read whether the value is known, use `(flags &amp; SPAN_FLAGS_CONTEXT_HAS_IS_REMOTE_MASK) != 0`.
         * To read whether the span is remote, use `(flags &amp; SPAN_FLAGS_CONTEXT_IS_REMOTE_MASK) != 0`.
         *
         * When creating span messages, if the message is logically forwarded from another source
         * with an equivalent flags fields (i.e., usually another OTLP span message), the field SHOULD
         * be copied as-is. If creating from a source that does not have an equivalent flags field
         * (such as a runtime representation of an OpenTelemetry span), the high 22 bits MUST
         * be set to zero.
         * Readers MUST NOT assume that bits 10-31 (22 most significant bits) will be zero.
         *
         * [Optional].
         * </pre>
         *
         * <code>fixed32 flags = 16;</code>
         * @return The flags.
         */
        @java.lang.Override
        public int getFlags() {
          return flags_;
        }
        /**
         * <pre>
         * Flags, a bit field.
         *
         * Bits 0-7 (8 least significant bits) are the trace flags as defined in W3C Trace
         * Context specification. To read the 8-bit W3C trace flag, use
         * `flags &amp; SPAN_FLAGS_TRACE_FLAGS_MASK`.
         *
         * See https://www.w3.org/TR/trace-context-2/#trace-flags for the flag definitions.
         *
         * Bits 8 and 9 represent the 3 states of whether a span's parent
         * is remote. The states are (unknown, is not remote, is remote).
         * To read whether the value is known, use `(flags &amp; SPAN_FLAGS_CONTEXT_HAS_IS_REMOTE_MASK) != 0`.
         * To read whether the span is remote, use `(flags &amp; SPAN_FLAGS_CONTEXT_IS_REMOTE_MASK) != 0`.
         *
         * When creating span messages, if the message is logically forwarded from another source
         * with an equivalent flags fields (i.e., usually another OTLP span message), the field SHOULD
         * be copied as-is. If creating from a source that does not have an equivalent flags field
         * (such as a runtime representation of an OpenTelemetry span), the high 22 bits MUST
         * be set to zero.
         * Readers MUST NOT assume that bits 10-31 (22 most significant bits) will be zero.
         *
         * [Optional].
         * </pre>
         *
         * <code>fixed32 flags = 16;</code>
         * @param value The flags to set.
         * @return This builder for chaining.
         */
        public Builder setFlags(int value) {

          flags_ = value;
          bitField0_ |= 0x00000002;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Flags, a bit field.
         *
         * Bits 0-7 (8 least significant bits) are the trace flags as defined in W3C Trace
         * Context specification. To read the 8-bit W3C trace flag, use
         * `flags &amp; SPAN_FLAGS_TRACE_FLAGS_MASK`.
         *
         * See https://www.w3.org/TR/trace-context-2/#trace-flags for the flag definitions.
         *
         * Bits 8 and 9 represent the 3 states of whether a span's parent
         * is remote. The states are (unknown, is not remote, is remote).
         * To read whether the value is known, use `(flags &amp; SPAN_FLAGS_CONTEXT_HAS_IS_REMOTE_MASK) != 0`.
         * To read whether the span is remote, use `(flags &amp; SPAN_FLAGS_CONTEXT_IS_REMOTE_MASK) != 0`.
         *
         * When creating span messages, if the message is logically forwarded from another source
         * with an equivalent flags fields (i.e., usually another OTLP span message), the field SHOULD
         * be copied as-is. If creating from a source that does not have an equivalent flags field
         * (such as a runtime representation of an OpenTelemetry span), the high 22 bits MUST
         * be set to zero.
         * Readers MUST NOT assume that bits 10-31 (22 most significant bits) will be zero.
         *
         * [Optional].
         * </pre>
         *
         * <code>fixed32 flags = 16;</code>
         * @return This builder for chaining.
         */
        public Builder clearFlags() {
          bitField0_ = (bitField0_ & ~0x00000002);
          flags_ = 0;
          onChanged();
          return this;
        }

        private java.lang.Object name_ = "";
        /**
         * <pre>
         * A description of the span's operation.
         *
         * For example, the name can be a qualified method name or a file name
         * and a line number where the operation is called. A best practice is to use
         * the same display name at the same call point in an application.
         * This makes it easier to correlate spans in different traces.
         *
         * This field is semantically required to be set to non-empty string.
         * Empty value is equivalent to an unknown span name.
         *
         * This field is required.
         * </pre>
         *
         * <code>string name = 5;</code>
         * @return The name.
         */
        public java.lang.String getName() {
          java.lang.Object ref = name_;
          if (!(ref instanceof java.lang.String)) {
            com.google.protobuf.ByteString bs =
                (com.google.protobuf.ByteString) ref;
            java.lang.String s = bs.toStringUtf8();
            name_ = s;
            return s;
          } else {
            return (java.lang.String) ref;
          }
        }
        /**
         * <pre>
         * A description of the span's operation.
         *
         * For example, the name can be a qualified method name or a file name
         * and a line number where the operation is called. A best practice is to use
         * the same display name at the same call point in an application.
         * This makes it easier to correlate spans in different traces.
         *
         * This field is semantically required to be set to non-empty string.
         * Empty value is equivalent to an unknown span name.
         *
         * This field is required.
         * </pre>
         *
         * <code>string name = 5;</code>
         * @return The bytes for name.
         */
        public com.google.protobuf.ByteString
            getNameBytes() {
          java.lang.Object ref = name_;
          if (ref instanceof String) {
            com.google.protobuf.ByteString b = 
                com.google.protobuf.ByteString.copyFromUtf8(
                    (java.lang.String) ref);
            name_ = b;
            return b;
          } else {
            return (com.google.protobuf.ByteString) ref;
          }
        }
        /**
         * <pre>
         * A description of the span's operation.
         *
         * For example, the name can be a qualified method name or a file name
         * and a line number where the operation is called. A best practice is to use
         * the same display name at the same call point in an application.
         * This makes it easier to correlate spans in different traces.
         *
         * This field is semantically required to be set to non-empty string.
         * Empty value is equivalent to an unknown span name.
         *
         * This field is required.
         * </pre>
         *
         * <code>string name = 5;</code>
         * @param value The name to set.
         * @return This builder for chaining.
         */
        public Builder setName(
            java.lang.String value) {
          if (value == null) { throw new NullPointerException(); }
          name_ = value;
          bitField0_ |= 0x00000004;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * A description of the span's operation.
         *
         * For example, the name can be a qualified method name or a file name
         * and a line number where the operation is called. A best practice is to use
         * the same display name at the same call point in an application.
         * This makes it easier to correlate spans in different traces.
         *
         * This field is semantically required to be set to non-empty string.
         * Empty value is equivalent to an unknown span name.
         *
         * This field is required.
         * </pre>
         *
         * <code>string name = 5;</code>
         * @return This builder for chaining.
         */
        public Builder clearName() {
          name_ = getDefaultInstance().getName();
          bitField0_ = (bitField0_ & ~0x00000004);
          onChanged();
          return this;
        }
        /**
         * <pre>
         * A description of the span's operation.
         *
         * For example, the name can be a qualified method name or a file name
         * and a line number where the operation is called. A best practice is to use
         * the same display name at the same call point in an application.
         * This makes it easier to correlate spans in different traces.
         *
         * This field is semantically required to be set to non-empty string.
         * Empty value is equivalent to an unknown span name.
         *
         * This field is required.
         * </pre>
         *
         * <code>string name = 5;</code>
         * @param value The bytes for name to set.
         * @return This builder for chaining.
         */
        public Builder setNameBytes(
            com.google.protobuf.ByteString value) {
          if (value == null) { throw new NullPointerException(); }
          checkByteStringIsUtf8(value);
          name_ = value;
          bitField0_ |= 0x00000004;
          onChanged();
          return this;
        }

        private int kind_ = 0;
        /**
         * <pre>
         * Distinguishes between spans generated in a particular context. For example,
         * two spans with the same name may be distinguished using `CLIENT` (caller)
         * and `SERVER` (callee) to identify queueing latency associated with the span.
         * </pre>
         *
         * <code>.opentelemetry.proto.mmap.v1.SpanEvent.StartSpan.SpanKind kind = 6;</code>
         * @return The enum numeric value on the wire for kind.
         */
        @java.lang.Override public int getKindValue() {
          return kind_;
        }
        /**
         * <pre>
         * Distinguishes between spans generated in a particular context. For example,
         * two spans with the same name may be distinguished using `CLIENT` (caller)
         * and `SERVER` (callee) to identify queueing latency associated with the span.
         * </pre>
         *
         * <code>.opentelemetry.proto.mmap.v1.SpanEvent.StartSpan.SpanKind kind = 6;</code>
         * @param value The enum numeric value on the wire for kind to set.
         * @return This builder for chaining.
         */
        public Builder setKindValue(int value) {
          kind_ = value;
          bitField0_ |= 0x00000008;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Distinguishes between spans generated in a particular context. For example,
         * two spans with the same name may be distinguished using `CLIENT` (caller)
         * and `SERVER` (callee) to identify queueing latency associated with the span.
         * </pre>
         *
         * <code>.opentelemetry.proto.mmap.v1.SpanEvent.StartSpan.SpanKind kind = 6;</code>
         * @return The kind.
         */
        @java.lang.Override
        public opentelemetry.proto.mmap.v1.Mmap.SpanEvent.StartSpan.SpanKind getKind() {
          opentelemetry.proto.mmap.v1.Mmap.SpanEvent.StartSpan.SpanKind result = opentelemetry.proto.mmap.v1.Mmap.SpanEvent.StartSpan.SpanKind.forNumber(kind_);
          return result == null ? opentelemetry.proto.mmap.v1.Mmap.SpanEvent.StartSpan.SpanKind.UNRECOGNIZED : result;
        }
        /**
         * <pre>
         * Distinguishes between spans generated in a particular context. For example,
         * two spans with the same name may be distinguished using `CLIENT` (caller)
         * and `SERVER` (callee) to identify queueing latency associated with the span.
         * </pre>
         *
         * <code>.opentelemetry.proto.mmap.v1.SpanEvent.StartSpan.SpanKind kind = 6;</code>
         * @param value The kind to set.
         * @return This builder for chaining.
         */
        public Builder setKind(opentelemetry.proto.mmap.v1.Mmap.SpanEvent.StartSpan.SpanKind value) {
          if (value == null) { throw new NullPointerException(); }
          bitField0_ |= 0x00000008;
          kind_ = value.getNumber();
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Distinguishes between spans generated in a particular context. For example,
         * two spans with the same name may be distinguished using `CLIENT` (caller)
         * and `SERVER` (callee) to identify queueing latency associated with the span.
         * </pre>
         *
         * <code>.opentelemetry.proto.mmap.v1.SpanEvent.StartSpan.SpanKind kind = 6;</code>
         * @return This builder for chaining.
         */
        public Builder clearKind() {
          bitField0_ = (bitField0_ & ~0x00000008);
          kind_ = 0;
          onChanged();
          return this;
        }

        private long startTimeUnixNano_ ;
        /**
         * <pre>
         * The start time of the span. On the client side, this is the time
         * kept by the local machine where the span execution starts. On the server side, this
         * is the time when the server's application handler starts running.
         * Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January 1970.
         *
         * This field is semantically required and it is expected that end_time &gt;= start_time.
         * </pre>
         *
         * <code>fixed64 start_time_unix_nano = 7;</code>
         * @return The startTimeUnixNano.
         */
        @java.lang.Override
        public long getStartTimeUnixNano() {
          return startTimeUnixNano_;
        }
        /**
         * <pre>
         * The start time of the span. On the client side, this is the time
         * kept by the local machine where the span execution starts. On the server side, this
         * is the time when the server's application handler starts running.
         * Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January 1970.
         *
         * This field is semantically required and it is expected that end_time &gt;= start_time.
         * </pre>
         *
         * <code>fixed64 start_time_unix_nano = 7;</code>
         * @param value The startTimeUnixNano to set.
         * @return This builder for chaining.
         */
        public Builder setStartTimeUnixNano(long value) {

          startTimeUnixNano_ = value;
          bitField0_ |= 0x00000010;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * The start time of the span. On the client side, this is the time
         * kept by the local machine where the span execution starts. On the server side, this
         * is the time when the server's application handler starts running.
         * Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January 1970.
         *
         * This field is semantically required and it is expected that end_time &gt;= start_time.
         * </pre>
         *
         * <code>fixed64 start_time_unix_nano = 7;</code>
         * @return This builder for chaining.
         */
        public Builder clearStartTimeUnixNano() {
          bitField0_ = (bitField0_ & ~0x00000010);
          startTimeUnixNano_ = 0L;
          onChanged();
          return this;
        }

        private java.util.List<opentelemetry.proto.mmap.v1.Mmap.KeyValueRef> attributes_ =
          java.util.Collections.emptyList();
        private void ensureAttributesIsMutable() {
          if (!((bitField0_ & 0x00000020) != 0)) {
            attributes_ = new java.util.ArrayList<opentelemetry.proto.mmap.v1.Mmap.KeyValueRef>(attributes_);
            bitField0_ |= 0x00000020;
           }
        }

        private com.google.protobuf.RepeatedFieldBuilder<
            opentelemetry.proto.mmap.v1.Mmap.KeyValueRef, opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.Builder, opentelemetry.proto.mmap.v1.Mmap.KeyValueRefOrBuilder> attributesBuilder_;

        /**
         * <pre>
         * A collection of key/value pairs. Note, global attributes
         * like server name can be set using the resource API. Examples of attributes:
         *
         * "/http/user_agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"
         * "/http/server_latency": 300
         * "example.com/myattribute": true
         * "example.com/score": 10.239
         *
         * Attribute keys MUST be unique (it is not allowed to have more than one
         * attribute with the same key).
         *
         * The attribute values SHOULD NOT contain empty values.
         * The attribute values SHOULD NOT contain bytes values.
         * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
         * double values.
         * The attribute values SHOULD NOT contain kvlist values.
         * The behavior of software that receives attributes containing such values can be unpredictable.
         * These restrictions can change in a minor release.
         * The restrictions take origin from the OpenTelemetry specification:
         * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
         * </pre>
         *
         * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 9;</code>
         */
        public java.util.List<opentelemetry.proto.mmap.v1.Mmap.KeyValueRef> getAttributesList() {
          if (attributesBuilder_ == null) {
            return java.util.Collections.unmodifiableList(attributes_);
          } else {
            return attributesBuilder_.getMessageList();
          }
        }
        /**
         * <pre>
         * A collection of key/value pairs. Note, global attributes
         * like server name can be set using the resource API. Examples of attributes:
         *
         * "/http/user_agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"
         * "/http/server_latency": 300
         * "example.com/myattribute": true
         * "example.com/score": 10.239
         *
         * Attribute keys MUST be unique (it is not allowed to have more than one
         * attribute with the same key).
         *
         * The attribute values SHOULD NOT contain empty values.
         * The attribute values SHOULD NOT contain bytes values.
         * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
         * double values.
         * The attribute values SHOULD NOT contain kvlist values.
         * The behavior of software that receives attributes containing such values can be unpredictable.
         * These restrictions can change in a minor release.
         * The restrictions take origin from the OpenTelemetry specification:
         * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
         * </pre>
         *
         * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 9;</code>
         */
        public int getAttributesCount() {
          if (attributesBuilder_ == null) {
            return attributes_.size();
          } else {
            return attributesBuilder_.getCount();
          }
        }
        /**
         * <pre>
         * A collection of key/value pairs. Note, global attributes
         * like server name can be set using the resource API. Examples of attributes:
         *
         * "/http/user_agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"
         * "/http/server_latency": 300
         * "example.com/myattribute": true
         * "example.com/score": 10.239
         *
         * Attribute keys MUST be unique (it is not allowed to have more than one
         * attribute with the same key).
         *
         * The attribute values SHOULD NOT contain empty values.
         * The attribute values SHOULD NOT contain bytes values.
         * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
         * double values.
         * The attribute values SHOULD NOT contain kvlist values.
         * The behavior of software that receives attributes containing such values can be unpredictable.
         * These restrictions can change in a minor release.
         * The restrictions take origin from the OpenTelemetry specification:
         * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
         * </pre>
         *
         * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 9;</code>
         */
        public opentelemetry.proto.mmap.v1.Mmap.KeyValueRef getAttributes(int index) {
          if (attributesBuilder_ == null) {
            return attributes_.get(index);
          } else {
            return attributesBuilder_.getMessage(index);
          }
        }
        /**
         * <pre>
         * A collection of key/value pairs. Note, global attributes
         * like server name can be set using the resource API. Examples of attributes:
         *
         * "/http/user_agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"
         * "/http/server_latency": 300
         * "example.com/myattribute": true
         * "example.com/score": 10.239
         *
         * Attribute keys MUST be unique (it is not allowed to have more than one
         * attribute with the same key).
         *
         * The attribute values SHOULD NOT contain empty values.
         * The attribute values SHOULD NOT contain bytes values.
         * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
         * double values.
         * The attribute values SHOULD NOT contain kvlist values.
         * The behavior of software that receives attributes containing such values can be unpredictable.
         * These restrictions can change in a minor release.
         * The restrictions take origin from the OpenTelemetry specification:
         * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
         * </pre>
         *
         * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 9;</code>
         */
        public Builder setAttributes(
            int index, opentelemetry.proto.mmap.v1.Mmap.KeyValueRef value) {
          if (attributesBuilder_ == null) {
            if (value == null) {
              throw new NullPointerException();
            }
            ensureAttributesIsMutable();
            attributes_.set(index, value);
            onChanged();
          } else {
            attributesBuilder_.setMessage(index, value);
          }
          return this;
        }
        /**
         * <pre>
         * A collection of key/value pairs. Note, global attributes
         * like server name can be set using the resource API. Examples of attributes:
         *
         * "/http/user_agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"
         * "/http/server_latency": 300
         * "example.com/myattribute": true
         * "example.com/score": 10.239
         *
         * Attribute keys MUST be unique (it is not allowed to have more than one
         * attribute with the same key).
         *
         * The attribute values SHOULD NOT contain empty values.
         * The attribute values SHOULD NOT contain bytes values.
         * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
         * double values.
         * The attribute values SHOULD NOT contain kvlist values.
         * The behavior of software that receives attributes containing such values can be unpredictable.
         * These restrictions can change in a minor release.
         * The restrictions take origin from the OpenTelemetry specification:
         * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
         * </pre>
         *
         * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 9;</code>
         */
        public Builder setAttributes(
            int index, opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.Builder builderForValue) {
          if (attributesBuilder_ == null) {
            ensureAttributesIsMutable();
            attributes_.set(index, builderForValue.build());
            onChanged();
          } else {
            attributesBuilder_.setMessage(index, builderForValue.build());
          }
          return this;
        }
        /**
         * <pre>
         * A collection of key/value pairs. Note, global attributes
         * like server name can be set using the resource API. Examples of attributes:
         *
         * "/http/user_agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"
         * "/http/server_latency": 300
         * "example.com/myattribute": true
         * "example.com/score": 10.239
         *
         * Attribute keys MUST be unique (it is not allowed to have more than one
         * attribute with the same key).
         *
         * The attribute values SHOULD NOT contain empty values.
         * The attribute values SHOULD NOT contain bytes values.
         * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
         * double values.
         * The attribute values SHOULD NOT contain kvlist values.
         * The behavior of software that receives attributes containing such values can be unpredictable.
         * These restrictions can change in a minor release.
         * The restrictions take origin from the OpenTelemetry specification:
         * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
         * </pre>
         *
         * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 9;</code>
         */
        public Builder addAttributes(opentelemetry.proto.mmap.v1.Mmap.KeyValueRef value) {
          if (attributesBuilder_ == null) {
            if (value == null) {
              throw new NullPointerException();
            }
            ensureAttributesIsMutable();
            attributes_.add(value);
            onChanged();
          } else {
            attributesBuilder_.addMessage(value);
          }
          return this;
        }
        /**
         * <pre>
         * A collection of key/value pairs. Note, global attributes
         * like server name can be set using the resource API. Examples of attributes:
         *
         * "/http/user_agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"
         * "/http/server_latency": 300
         * "example.com/myattribute": true
         * "example.com/score": 10.239
         *
         * Attribute keys MUST be unique (it is not allowed to have more than one
         * attribute with the same key).
         *
         * The attribute values SHOULD NOT contain empty values.
         * The attribute values SHOULD NOT contain bytes values.
         * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
         * double values.
         * The attribute values SHOULD NOT contain kvlist values.
         * The behavior of software that receives attributes containing such values can be unpredictable.
         * These restrictions can change in a minor release.
         * The restrictions take origin from the OpenTelemetry specification:
         * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
         * </pre>
         *
         * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 9;</code>
         */
        public Builder addAttributes(
            int index, opentelemetry.proto.mmap.v1.Mmap.KeyValueRef value) {
          if (attributesBuilder_ == null) {
            if (value == null) {
              throw new NullPointerException();
            }
            ensureAttributesIsMutable();
            attributes_.add(index, value);
            onChanged();
          } else {
            attributesBuilder_.addMessage(index, value);
          }
          return this;
        }
        /**
         * <pre>
         * A collection of key/value pairs. Note, global attributes
         * like server name can be set using the resource API. Examples of attributes:
         *
         * "/http/user_agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"
         * "/http/server_latency": 300
         * "example.com/myattribute": true
         * "example.com/score": 10.239
         *
         * Attribute keys MUST be unique (it is not allowed to have more than one
         * attribute with the same key).
         *
         * The attribute values SHOULD NOT contain empty values.
         * The attribute values SHOULD NOT contain bytes values.
         * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
         * double values.
         * The attribute values SHOULD NOT contain kvlist values.
         * The behavior of software that receives attributes containing such values can be unpredictable.
         * These restrictions can change in a minor release.
         * The restrictions take origin from the OpenTelemetry specification:
         * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
         * </pre>
         *
         * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 9;</code>
         */
        public Builder addAttributes(
            opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.Builder builderForValue) {
          if (attributesBuilder_ == null) {
            ensureAttributesIsMutable();
            attributes_.add(builderForValue.build());
            onChanged();
          } else {
            attributesBuilder_.addMessage(builderForValue.build());
          }
          return this;
        }
        /**
         * <pre>
         * A collection of key/value pairs. Note, global attributes
         * like server name can be set using the resource API. Examples of attributes:
         *
         * "/http/user_agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"
         * "/http/server_latency": 300
         * "example.com/myattribute": true
         * "example.com/score": 10.239
         *
         * Attribute keys MUST be unique (it is not allowed to have more than one
         * attribute with the same key).
         *
         * The attribute values SHOULD NOT contain empty values.
         * The attribute values SHOULD NOT contain bytes values.
         * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
         * double values.
         * The attribute values SHOULD NOT contain kvlist values.
         * The behavior of software that receives attributes containing such values can be unpredictable.
         * These restrictions can change in a minor release.
         * The restrictions take origin from the OpenTelemetry specification:
         * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
         * </pre>
         *
         * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 9;</code>
         */
        public Builder addAttributes(
            int index, opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.Builder builderForValue) {
          if (attributesBuilder_ == null) {
            ensureAttributesIsMutable();
            attributes_.add(index, builderForValue.build());
            onChanged();
          } else {
            attributesBuilder_.addMessage(index, builderForValue.build());
          }
          return this;
        }
        /**
         * <pre>
         * A collection of key/value pairs. Note, global attributes
         * like server name can be set using the resource API. Examples of attributes:
         *
         * "/http/user_agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"
         * "/http/server_latency": 300
         * "example.com/myattribute": true
         * "example.com/score": 10.239
         *
         * Attribute keys MUST be unique (it is not allowed to have more than one
         * attribute with the same key).
         *
         * The attribute values SHOULD NOT contain empty values.
         * The attribute values SHOULD NOT contain bytes values.
         * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
         * double values.
         * The attribute values SHOULD NOT contain kvlist values.
         * The behavior of software that receives attributes containing such values can be unpredictable.
         * These restrictions can change in a minor release.
         * The restrictions take origin from the OpenTelemetry specification:
         * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
         * </pre>
         *
         * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 9;</code>
         */
        public Builder addAllAttributes(
            java.lang.Iterable<? extends opentelemetry.proto.mmap.v1.Mmap.KeyValueRef> values) {
          if (attributesBuilder_ == null) {
            ensureAttributesIsMutable();
            com.google.protobuf.AbstractMessageLite.Builder.addAll(
                values, attributes_);
            onChanged();
          } else {
            attributesBuilder_.addAllMessages(values);
          }
          return this;
        }
        /**
         * <pre>
         * A collection of key/value pairs. Note, global attributes
         * like server name can be set using the resource API. Examples of attributes:
         *
         * "/http/user_agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"
         * "/http/server_latency": 300
         * "example.com/myattribute": true
         * "example.com/score": 10.239
         *
         * Attribute keys MUST be unique (it is not allowed to have more than one
         * attribute with the same key).
         *
         * The attribute values SHOULD NOT contain empty values.
         * The attribute values SHOULD NOT contain bytes values.
         * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
         * double values.
         * The attribute values SHOULD NOT contain kvlist values.
         * The behavior of software that receives attributes containing such values can be unpredictable.
         * These restrictions can change in a minor release.
         * The restrictions take origin from the OpenTelemetry specification:
         * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
         * </pre>
         *
         * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 9;</code>
         */
        public Builder clearAttributes() {
          if (attributesBuilder_ == null) {
            attributes_ = java.util.Collections.emptyList();
            bitField0_ = (bitField0_ & ~0x00000020);
            onChanged();
          } else {
            attributesBuilder_.clear();
          }
          return this;
        }
        /**
         * <pre>
         * A collection of key/value pairs. Note, global attributes
         * like server name can be set using the resource API. Examples of attributes:
         *
         * "/http/user_agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"
         * "/http/server_latency": 300
         * "example.com/myattribute": true
         * "example.com/score": 10.239
         *
         * Attribute keys MUST be unique (it is not allowed to have more than one
         * attribute with the same key).
         *
         * The attribute values SHOULD NOT contain empty values.
         * The attribute values SHOULD NOT contain bytes values.
         * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
         * double values.
         * The attribute values SHOULD NOT contain kvlist values.
         * The behavior of software that receives attributes containing such values can be unpredictable.
         * These restrictions can change in a minor release.
         * The restrictions take origin from the OpenTelemetry specification:
         * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
         * </pre>
         *
         * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 9;</code>
         */
        public Builder removeAttributes(int index) {
          if (attributesBuilder_ == null) {
            ensureAttributesIsMutable();
            attributes_.remove(index);
            onChanged();
          } else {
            attributesBuilder_.remove(index);
          }
          return this;
        }
        /**
         * <pre>
         * A collection of key/value pairs. Note, global attributes
         * like server name can be set using the resource API. Examples of attributes:
         *
         * "/http/user_agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"
         * "/http/server_latency": 300
         * "example.com/myattribute": true
         * "example.com/score": 10.239
         *
         * Attribute keys MUST be unique (it is not allowed to have more than one
         * attribute with the same key).
         *
         * The attribute values SHOULD NOT contain empty values.
         * The attribute values SHOULD NOT contain bytes values.
         * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
         * double values.
         * The attribute values SHOULD NOT contain kvlist values.
         * The behavior of software that receives attributes containing such values can be unpredictable.
         * These restrictions can change in a minor release.
         * The restrictions take origin from the OpenTelemetry specification:
         * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
         * </pre>
         *
         * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 9;</code>
         */
        public opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.Builder getAttributesBuilder(
            int index) {
          return internalGetAttributesFieldBuilder().getBuilder(index);
        }
        /**
         * <pre>
         * A collection of key/value pairs. Note, global attributes
         * like server name can be set using the resource API. Examples of attributes:
         *
         * "/http/user_agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"
         * "/http/server_latency": 300
         * "example.com/myattribute": true
         * "example.com/score": 10.239
         *
         * Attribute keys MUST be unique (it is not allowed to have more than one
         * attribute with the same key).
         *
         * The attribute values SHOULD NOT contain empty values.
         * The attribute values SHOULD NOT contain bytes values.
         * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
         * double values.
         * The attribute values SHOULD NOT contain kvlist values.
         * The behavior of software that receives attributes containing such values can be unpredictable.
         * These restrictions can change in a minor release.
         * The restrictions take origin from the OpenTelemetry specification:
         * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
         * </pre>
         *
         * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 9;</code>
         */
        public opentelemetry.proto.mmap.v1.Mmap.KeyValueRefOrBuilder getAttributesOrBuilder(
            int index) {
          if (attributesBuilder_ == null) {
            return attributes_.get(index);  } else {
            return attributesBuilder_.getMessageOrBuilder(index);
          }
        }
        /**
         * <pre>
         * A collection of key/value pairs. Note, global attributes
         * like server name can be set using the resource API. Examples of attributes:
         *
         * "/http/user_agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"
         * "/http/server_latency": 300
         * "example.com/myattribute": true
         * "example.com/score": 10.239
         *
         * Attribute keys MUST be unique (it is not allowed to have more than one
         * attribute with the same key).
         *
         * The attribute values SHOULD NOT contain empty values.
         * The attribute values SHOULD NOT contain bytes values.
         * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
         * double values.
         * The attribute values SHOULD NOT contain kvlist values.
         * The behavior of software that receives attributes containing such values can be unpredictable.
         * These restrictions can change in a minor release.
         * The restrictions take origin from the OpenTelemetry specification:
         * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
         * </pre>
         *
         * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 9;</code>
         */
        public java.util.List<? extends opentelemetry.proto.mmap.v1.Mmap.KeyValueRefOrBuilder> 
             getAttributesOrBuilderList() {
          if (attributesBuilder_ != null) {
            return attributesBuilder_.getMessageOrBuilderList();
          } else {
            return java.util.Collections.unmodifiableList(attributes_);
          }
        }
        /**
         * <pre>
         * A collection of key/value pairs. Note, global attributes
         * like server name can be set using the resource API. Examples of attributes:
         *
         * "/http/user_agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"
         * "/http/server_latency": 300
         * "example.com/myattribute": true
         * "example.com/score": 10.239
         *
         * Attribute keys MUST be unique (it is not allowed to have more than one
         * attribute with the same key).
         *
         * The attribute values SHOULD NOT contain empty values.
         * The attribute values SHOULD NOT contain bytes values.
         * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
         * double values.
         * The attribute values SHOULD NOT contain kvlist values.
         * The behavior of software that receives attributes containing such values can be unpredictable.
         * These restrictions can change in a minor release.
         * The restrictions take origin from the OpenTelemetry specification:
         * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
         * </pre>
         *
         * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 9;</code>
         */
        public opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.Builder addAttributesBuilder() {
          return internalGetAttributesFieldBuilder().addBuilder(
              opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.getDefaultInstance());
        }
        /**
         * <pre>
         * A collection of key/value pairs. Note, global attributes
         * like server name can be set using the resource API. Examples of attributes:
         *
         * "/http/user_agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"
         * "/http/server_latency": 300
         * "example.com/myattribute": true
         * "example.com/score": 10.239
         *
         * Attribute keys MUST be unique (it is not allowed to have more than one
         * attribute with the same key).
         *
         * The attribute values SHOULD NOT contain empty values.
         * The attribute values SHOULD NOT contain bytes values.
         * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
         * double values.
         * The attribute values SHOULD NOT contain kvlist values.
         * The behavior of software that receives attributes containing such values can be unpredictable.
         * These restrictions can change in a minor release.
         * The restrictions take origin from the OpenTelemetry specification:
         * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
         * </pre>
         *
         * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 9;</code>
         */
        public opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.Builder addAttributesBuilder(
            int index) {
          return internalGetAttributesFieldBuilder().addBuilder(
              index, opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.getDefaultInstance());
        }
        /**
         * <pre>
         * A collection of key/value pairs. Note, global attributes
         * like server name can be set using the resource API. Examples of attributes:
         *
         * "/http/user_agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"
         * "/http/server_latency": 300
         * "example.com/myattribute": true
         * "example.com/score": 10.239
         *
         * Attribute keys MUST be unique (it is not allowed to have more than one
         * attribute with the same key).
         *
         * The attribute values SHOULD NOT contain empty values.
         * The attribute values SHOULD NOT contain bytes values.
         * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
         * double values.
         * The attribute values SHOULD NOT contain kvlist values.
         * The behavior of software that receives attributes containing such values can be unpredictable.
         * These restrictions can change in a minor release.
         * The restrictions take origin from the OpenTelemetry specification:
         * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
         * </pre>
         *
         * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 9;</code>
         */
        public java.util.List<opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.Builder> 
             getAttributesBuilderList() {
          return internalGetAttributesFieldBuilder().getBuilderList();
        }
        private com.google.protobuf.RepeatedFieldBuilder<
            opentelemetry.proto.mmap.v1.Mmap.KeyValueRef, opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.Builder, opentelemetry.proto.mmap.v1.Mmap.KeyValueRefOrBuilder> 
            internalGetAttributesFieldBuilder() {
          if (attributesBuilder_ == null) {
            attributesBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
                opentelemetry.proto.mmap.v1.Mmap.KeyValueRef, opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.Builder, opentelemetry.proto.mmap.v1.Mmap.KeyValueRefOrBuilder>(
                    attributes_,
                    ((bitField0_ & 0x00000020) != 0),
                    getParentForChildren(),
                    isClean());
            attributes_ = null;
          }
          return attributesBuilder_;
        }

        // @@protoc_insertion_point(builder_scope:opentelemetry.proto.mmap.v1.SpanEvent.StartSpan)
      }

      // @@protoc_insertion_point(class_scope:opentelemetry.proto.mmap.v1.SpanEvent.StartSpan)
      private static final opentelemetry.proto.mmap.v1.Mmap.SpanEvent.StartSpan DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new opentelemetry.proto.mmap.v1.Mmap.SpanEvent.StartSpan();
      }

      public static opentelemetry.proto.mmap.v1.Mmap.SpanEvent.StartSpan getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static final com.google.protobuf.Parser<StartSpan>
          PARSER = new com.google.protobuf.AbstractParser<StartSpan>() {
        @java.lang.Override
        public StartSpan parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          Builder builder = newBuilder();
          try {
            builder.mergeFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.setUnfinishedMessage(builder.buildPartial());
          } catch (com.google.protobuf.UninitializedMessageException e) {
            throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
          } catch (java.io.IOException e) {
            throw new com.google.protobuf.InvalidProtocolBufferException(e)
                .setUnfinishedMessage(builder.buildPartial());
          }
          return builder.buildPartial();
        }
      };

      public static com.google.protobuf.Parser<StartSpan> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<StartSpan> getParserForType() {
        return PARSER;
      }

      @java.lang.Override
      public opentelemetry.proto.mmap.v1.Mmap.SpanEvent.StartSpan getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    public interface EndSpanOrBuilder extends
        // @@protoc_insertion_point(interface_extends:opentelemetry.proto.mmap.v1.SpanEvent.EndSpan)
        com.google.protobuf.MessageOrBuilder {

      /**
       * <pre>
       * The end time of the span. On the client side, this is the time
       * kept by the local machine where the span execution ends. On the server side, this
       * is the time when the server application handler stops running.
       * Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January 1970.
       *
       * This field is semantically required and it is expected that end_time &gt;= start_time.
       * </pre>
       *
       * <code>fixed64 end_time_unix_nano = 8;</code>
       * @return The endTimeUnixNano.
       */
      long getEndTimeUnixNano();

      /**
       * <pre>
       * An optional final status for this span. Semantically when Status isn't set, it means
       * span's status code is unset, i.e. assume STATUS_CODE_UNSET (code = 0).
       * </pre>
       *
       * <code>.opentelemetry.proto.mmap.v1.Status status = 15;</code>
       * @return Whether the status field is set.
       */
      boolean hasStatus();
      /**
       * <pre>
       * An optional final status for this span. Semantically when Status isn't set, it means
       * span's status code is unset, i.e. assume STATUS_CODE_UNSET (code = 0).
       * </pre>
       *
       * <code>.opentelemetry.proto.mmap.v1.Status status = 15;</code>
       * @return The status.
       */
      opentelemetry.proto.mmap.v1.Mmap.Status getStatus();
      /**
       * <pre>
       * An optional final status for this span. Semantically when Status isn't set, it means
       * span's status code is unset, i.e. assume STATUS_CODE_UNSET (code = 0).
       * </pre>
       *
       * <code>.opentelemetry.proto.mmap.v1.Status status = 15;</code>
       */
      opentelemetry.proto.mmap.v1.Mmap.StatusOrBuilder getStatusOrBuilder();
    }
    /**
     * Protobuf type {@code opentelemetry.proto.mmap.v1.SpanEvent.EndSpan}
     */
    public static final class EndSpan extends
        com.google.protobuf.GeneratedMessage implements
        // @@protoc_insertion_point(message_implements:opentelemetry.proto.mmap.v1.SpanEvent.EndSpan)
        EndSpanOrBuilder {
    private static final long serialVersionUID = 0L;
      static {
        com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
          com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
          /* major= */ 4,
          /* minor= */ 33,
          /* patch= */ 0,
          /* suffix= */ "",
          "EndSpan");
      }
      // Use EndSpan.newBuilder() to construct.
      private EndSpan(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
        super(builder);
      }
      private EndSpan() {
      }

      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_SpanEvent_EndSpan_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_SpanEvent_EndSpan_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                opentelemetry.proto.mmap.v1.Mmap.SpanEvent.EndSpan.class, opentelemetry.proto.mmap.v1.Mmap.SpanEvent.EndSpan.Builder.class);
      }

      private int bitField0_;
      public static final int END_TIME_UNIX_NANO_FIELD_NUMBER = 8;
      private long endTimeUnixNano_ = 0L;
      /**
       * <pre>
       * The end time of the span. On the client side, this is the time
       * kept by the local machine where the span execution ends. On the server side, this
       * is the time when the server application handler stops running.
       * Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January 1970.
       *
       * This field is semantically required and it is expected that end_time &gt;= start_time.
       * </pre>
       *
       * <code>fixed64 end_time_unix_nano = 8;</code>
       * @return The endTimeUnixNano.
       */
      @java.lang.Override
      public long getEndTimeUnixNano() {
        return endTimeUnixNano_;
      }

      public static final int STATUS_FIELD_NUMBER = 15;
      private opentelemetry.proto.mmap.v1.Mmap.Status status_;
      /**
       * <pre>
       * An optional final status for this span. Semantically when Status isn't set, it means
       * span's status code is unset, i.e. assume STATUS_CODE_UNSET (code = 0).
       * </pre>
       *
       * <code>.opentelemetry.proto.mmap.v1.Status status = 15;</code>
       * @return Whether the status field is set.
       */
      @java.lang.Override
      public boolean hasStatus() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * An optional final status for this span. Semantically when Status isn't set, it means
       * span's status code is unset, i.e. assume STATUS_CODE_UNSET (code = 0).
       * </pre>
       *
       * <code>.opentelemetry.proto.mmap.v1.Status status = 15;</code>
       * @return The status.
       */
      @java.lang.Override
      public opentelemetry.proto.mmap.v1.Mmap.Status getStatus() {
        return status_ == null ? opentelemetry.proto.mmap.v1.Mmap.Status.getDefaultInstance() : status_;
      }
      /**
       * <pre>
       * An optional final status for this span. Semantically when Status isn't set, it means
       * span's status code is unset, i.e. assume STATUS_CODE_UNSET (code = 0).
       * </pre>
       *
       * <code>.opentelemetry.proto.mmap.v1.Status status = 15;</code>
       */
      @java.lang.Override
      public opentelemetry.proto.mmap.v1.Mmap.StatusOrBuilder getStatusOrBuilder() {
        return status_ == null ? opentelemetry.proto.mmap.v1.Mmap.Status.getDefaultInstance() : status_;
      }

      private byte memoizedIsInitialized = -1;
      @java.lang.Override
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        memoizedIsInitialized = 1;
        return true;
      }

      @java.lang.Override
      public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        if (endTimeUnixNano_ != 0L) {
          output.writeFixed64(8, endTimeUnixNano_);
        }
        if (((bitField0_ & 0x00000001) != 0)) {
          output.writeMessage(15, getStatus());
        }
        getUnknownFields().writeTo(output);
      }

      @java.lang.Override
      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        if (endTimeUnixNano_ != 0L) {
          size += com.google.protobuf.CodedOutputStream
            .computeFixed64Size(8, endTimeUnixNano_);
        }
        if (((bitField0_ & 0x00000001) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(15, getStatus());
        }
        size += getUnknownFields().getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof opentelemetry.proto.mmap.v1.Mmap.SpanEvent.EndSpan)) {
          return super.equals(obj);
        }
        opentelemetry.proto.mmap.v1.Mmap.SpanEvent.EndSpan other = (opentelemetry.proto.mmap.v1.Mmap.SpanEvent.EndSpan) obj;

        if (getEndTimeUnixNano()
            != other.getEndTimeUnixNano()) return false;
        if (hasStatus() != other.hasStatus()) return false;
        if (hasStatus()) {
          if (!getStatus()
              .equals(other.getStatus())) return false;
        }
        if (!getUnknownFields().equals(other.getUnknownFields())) return false;
        return true;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        hash = (37 * hash) + END_TIME_UNIX_NANO_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getEndTimeUnixNano());
        if (hasStatus()) {
          hash = (37 * hash) + STATUS_FIELD_NUMBER;
          hash = (53 * hash) + getStatus().hashCode();
        }
        hash = (29 * hash) + getUnknownFields().hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static opentelemetry.proto.mmap.v1.Mmap.SpanEvent.EndSpan parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static opentelemetry.proto.mmap.v1.Mmap.SpanEvent.EndSpan parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static opentelemetry.proto.mmap.v1.Mmap.SpanEvent.EndSpan parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static opentelemetry.proto.mmap.v1.Mmap.SpanEvent.EndSpan parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static opentelemetry.proto.mmap.v1.Mmap.SpanEvent.EndSpan parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static opentelemetry.proto.mmap.v1.Mmap.SpanEvent.EndSpan parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static opentelemetry.proto.mmap.v1.Mmap.SpanEvent.EndSpan parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input);
      }
      public static opentelemetry.proto.mmap.v1.Mmap.SpanEvent.EndSpan parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      public static opentelemetry.proto.mmap.v1.Mmap.SpanEvent.EndSpan parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseDelimitedWithIOException(PARSER, input);
      }

      public static opentelemetry.proto.mmap.v1.Mmap.SpanEvent.EndSpan parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static opentelemetry.proto.mmap.v1.Mmap.SpanEvent.EndSpan parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input);
      }
      public static opentelemetry.proto.mmap.v1.Mmap.SpanEvent.EndSpan parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      @java.lang.Override
      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(opentelemetry.proto.mmap.v1.Mmap.SpanEvent.EndSpan prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      @java.lang.Override
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * Protobuf type {@code opentelemetry.proto.mmap.v1.SpanEvent.EndSpan}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessage.Builder<Builder> implements
          // @@protoc_insertion_point(builder_implements:opentelemetry.proto.mmap.v1.SpanEvent.EndSpan)
          opentelemetry.proto.mmap.v1.Mmap.SpanEvent.EndSpanOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_SpanEvent_EndSpan_descriptor;
        }

        @java.lang.Override
        protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_SpanEvent_EndSpan_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  opentelemetry.proto.mmap.v1.Mmap.SpanEvent.EndSpan.class, opentelemetry.proto.mmap.v1.Mmap.SpanEvent.EndSpan.Builder.class);
        }

        // Construct using opentelemetry.proto.mmap.v1.Mmap.SpanEvent.EndSpan.newBuilder()
        private Builder() {
          maybeForceBuilderInitialization();
        }

        private Builder(
            com.google.protobuf.GeneratedMessage.BuilderParent parent) {
          super(parent);
          maybeForceBuilderInitialization();
        }
        private void maybeForceBuilderInitialization() {
          if (com.google.protobuf.GeneratedMessage
                  .alwaysUseFieldBuilders) {
            internalGetStatusFieldBuilder();
          }
        }
        @java.lang.Override
        public Builder clear() {
          super.clear();
          bitField0_ = 0;
          endTimeUnixNano_ = 0L;
          status_ = null;
          if (statusBuilder_ != null) {
            statusBuilder_.dispose();
            statusBuilder_ = null;
          }
          return this;
        }

        @java.lang.Override
        public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_SpanEvent_EndSpan_descriptor;
        }

        @java.lang.Override
        public opentelemetry.proto.mmap.v1.Mmap.SpanEvent.EndSpan getDefaultInstanceForType() {
          return opentelemetry.proto.mmap.v1.Mmap.SpanEvent.EndSpan.getDefaultInstance();
        }

        @java.lang.Override
        public opentelemetry.proto.mmap.v1.Mmap.SpanEvent.EndSpan build() {
          opentelemetry.proto.mmap.v1.Mmap.SpanEvent.EndSpan result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        @java.lang.Override
        public opentelemetry.proto.mmap.v1.Mmap.SpanEvent.EndSpan buildPartial() {
          opentelemetry.proto.mmap.v1.Mmap.SpanEvent.EndSpan result = new opentelemetry.proto.mmap.v1.Mmap.SpanEvent.EndSpan(this);
          if (bitField0_ != 0) { buildPartial0(result); }
          onBuilt();
          return result;
        }

        private void buildPartial0(opentelemetry.proto.mmap.v1.Mmap.SpanEvent.EndSpan result) {
          int from_bitField0_ = bitField0_;
          if (((from_bitField0_ & 0x00000001) != 0)) {
            result.endTimeUnixNano_ = endTimeUnixNano_;
          }
          int to_bitField0_ = 0;
          if (((from_bitField0_ & 0x00000002) != 0)) {
            result.status_ = statusBuilder_ == null
                ? status_
                : statusBuilder_.build();
            to_bitField0_ |= 0x00000001;
          }
          result.bitField0_ |= to_bitField0_;
        }

        @java.lang.Override
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other instanceof opentelemetry.proto.mmap.v1.Mmap.SpanEvent.EndSpan) {
            return mergeFrom((opentelemetry.proto.mmap.v1.Mmap.SpanEvent.EndSpan)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(opentelemetry.proto.mmap.v1.Mmap.SpanEvent.EndSpan other) {
          if (other == opentelemetry.proto.mmap.v1.Mmap.SpanEvent.EndSpan.getDefaultInstance()) return this;
          if (other.getEndTimeUnixNano() != 0L) {
            setEndTimeUnixNano(other.getEndTimeUnixNano());
          }
          if (other.hasStatus()) {
            mergeStatus(other.getStatus());
          }
          this.mergeUnknownFields(other.getUnknownFields());
          onChanged();
          return this;
        }

        @java.lang.Override
        public final boolean isInitialized() {
          return true;
        }

        @java.lang.Override
        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          if (extensionRegistry == null) {
            throw new java.lang.NullPointerException();
          }
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                case 65: {
                  endTimeUnixNano_ = input.readFixed64();
                  bitField0_ |= 0x00000001;
                  break;
                } // case 65
                case 122: {
                  input.readMessage(
                      internalGetStatusFieldBuilder().getBuilder(),
                      extensionRegistry);
                  bitField0_ |= 0x00000002;
                  break;
                } // case 122
                default: {
                  if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                    done = true; // was an endgroup tag
                  }
                  break;
                } // default:
              } // switch (tag)
            } // while (!done)
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.unwrapIOException();
          } finally {
            onChanged();
          } // finally
          return this;
        }
        private int bitField0_;

        private long endTimeUnixNano_ ;
        /**
         * <pre>
         * The end time of the span. On the client side, this is the time
         * kept by the local machine where the span execution ends. On the server side, this
         * is the time when the server application handler stops running.
         * Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January 1970.
         *
         * This field is semantically required and it is expected that end_time &gt;= start_time.
         * </pre>
         *
         * <code>fixed64 end_time_unix_nano = 8;</code>
         * @return The endTimeUnixNano.
         */
        @java.lang.Override
        public long getEndTimeUnixNano() {
          return endTimeUnixNano_;
        }
        /**
         * <pre>
         * The end time of the span. On the client side, this is the time
         * kept by the local machine where the span execution ends. On the server side, this
         * is the time when the server application handler stops running.
         * Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January 1970.
         *
         * This field is semantically required and it is expected that end_time &gt;= start_time.
         * </pre>
         *
         * <code>fixed64 end_time_unix_nano = 8;</code>
         * @param value The endTimeUnixNano to set.
         * @return This builder for chaining.
         */
        public Builder setEndTimeUnixNano(long value) {

          endTimeUnixNano_ = value;
          bitField0_ |= 0x00000001;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * The end time of the span. On the client side, this is the time
         * kept by the local machine where the span execution ends. On the server side, this
         * is the time when the server application handler stops running.
         * Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January 1970.
         *
         * This field is semantically required and it is expected that end_time &gt;= start_time.
         * </pre>
         *
         * <code>fixed64 end_time_unix_nano = 8;</code>
         * @return This builder for chaining.
         */
        public Builder clearEndTimeUnixNano() {
          bitField0_ = (bitField0_ & ~0x00000001);
          endTimeUnixNano_ = 0L;
          onChanged();
          return this;
        }

        private opentelemetry.proto.mmap.v1.Mmap.Status status_;
        private com.google.protobuf.SingleFieldBuilder<
            opentelemetry.proto.mmap.v1.Mmap.Status, opentelemetry.proto.mmap.v1.Mmap.Status.Builder, opentelemetry.proto.mmap.v1.Mmap.StatusOrBuilder> statusBuilder_;
        /**
         * <pre>
         * An optional final status for this span. Semantically when Status isn't set, it means
         * span's status code is unset, i.e. assume STATUS_CODE_UNSET (code = 0).
         * </pre>
         *
         * <code>.opentelemetry.proto.mmap.v1.Status status = 15;</code>
         * @return Whether the status field is set.
         */
        public boolean hasStatus() {
          return ((bitField0_ & 0x00000002) != 0);
        }
        /**
         * <pre>
         * An optional final status for this span. Semantically when Status isn't set, it means
         * span's status code is unset, i.e. assume STATUS_CODE_UNSET (code = 0).
         * </pre>
         *
         * <code>.opentelemetry.proto.mmap.v1.Status status = 15;</code>
         * @return The status.
         */
        public opentelemetry.proto.mmap.v1.Mmap.Status getStatus() {
          if (statusBuilder_ == null) {
            return status_ == null ? opentelemetry.proto.mmap.v1.Mmap.Status.getDefaultInstance() : status_;
          } else {
            return statusBuilder_.getMessage();
          }
        }
        /**
         * <pre>
         * An optional final status for this span. Semantically when Status isn't set, it means
         * span's status code is unset, i.e. assume STATUS_CODE_UNSET (code = 0).
         * </pre>
         *
         * <code>.opentelemetry.proto.mmap.v1.Status status = 15;</code>
         */
        public Builder setStatus(opentelemetry.proto.mmap.v1.Mmap.Status value) {
          if (statusBuilder_ == null) {
            if (value == null) {
              throw new NullPointerException();
            }
            status_ = value;
          } else {
            statusBuilder_.setMessage(value);
          }
          bitField0_ |= 0x00000002;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * An optional final status for this span. Semantically when Status isn't set, it means
         * span's status code is unset, i.e. assume STATUS_CODE_UNSET (code = 0).
         * </pre>
         *
         * <code>.opentelemetry.proto.mmap.v1.Status status = 15;</code>
         */
        public Builder setStatus(
            opentelemetry.proto.mmap.v1.Mmap.Status.Builder builderForValue) {
          if (statusBuilder_ == null) {
            status_ = builderForValue.build();
          } else {
            statusBuilder_.setMessage(builderForValue.build());
          }
          bitField0_ |= 0x00000002;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * An optional final status for this span. Semantically when Status isn't set, it means
         * span's status code is unset, i.e. assume STATUS_CODE_UNSET (code = 0).
         * </pre>
         *
         * <code>.opentelemetry.proto.mmap.v1.Status status = 15;</code>
         */
        public Builder mergeStatus(opentelemetry.proto.mmap.v1.Mmap.Status value) {
          if (statusBuilder_ == null) {
            if (((bitField0_ & 0x00000002) != 0) &&
              status_ != null &&
              status_ != opentelemetry.proto.mmap.v1.Mmap.Status.getDefaultInstance()) {
              getStatusBuilder().mergeFrom(value);
            } else {
              status_ = value;
            }
          } else {
            statusBuilder_.mergeFrom(value);
          }
          if (status_ != null) {
            bitField0_ |= 0x00000002;
            onChanged();
          }
          return this;
        }
        /**
         * <pre>
         * An optional final status for this span. Semantically when Status isn't set, it means
         * span's status code is unset, i.e. assume STATUS_CODE_UNSET (code = 0).
         * </pre>
         *
         * <code>.opentelemetry.proto.mmap.v1.Status status = 15;</code>
         */
        public Builder clearStatus() {
          bitField0_ = (bitField0_ & ~0x00000002);
          status_ = null;
          if (statusBuilder_ != null) {
            statusBuilder_.dispose();
            statusBuilder_ = null;
          }
          onChanged();
          return this;
        }
        /**
         * <pre>
         * An optional final status for this span. Semantically when Status isn't set, it means
         * span's status code is unset, i.e. assume STATUS_CODE_UNSET (code = 0).
         * </pre>
         *
         * <code>.opentelemetry.proto.mmap.v1.Status status = 15;</code>
         */
        public opentelemetry.proto.mmap.v1.Mmap.Status.Builder getStatusBuilder() {
          bitField0_ |= 0x00000002;
          onChanged();
          return internalGetStatusFieldBuilder().getBuilder();
        }
        /**
         * <pre>
         * An optional final status for this span. Semantically when Status isn't set, it means
         * span's status code is unset, i.e. assume STATUS_CODE_UNSET (code = 0).
         * </pre>
         *
         * <code>.opentelemetry.proto.mmap.v1.Status status = 15;</code>
         */
        public opentelemetry.proto.mmap.v1.Mmap.StatusOrBuilder getStatusOrBuilder() {
          if (statusBuilder_ != null) {
            return statusBuilder_.getMessageOrBuilder();
          } else {
            return status_ == null ?
                opentelemetry.proto.mmap.v1.Mmap.Status.getDefaultInstance() : status_;
          }
        }
        /**
         * <pre>
         * An optional final status for this span. Semantically when Status isn't set, it means
         * span's status code is unset, i.e. assume STATUS_CODE_UNSET (code = 0).
         * </pre>
         *
         * <code>.opentelemetry.proto.mmap.v1.Status status = 15;</code>
         */
        private com.google.protobuf.SingleFieldBuilder<
            opentelemetry.proto.mmap.v1.Mmap.Status, opentelemetry.proto.mmap.v1.Mmap.Status.Builder, opentelemetry.proto.mmap.v1.Mmap.StatusOrBuilder> 
            internalGetStatusFieldBuilder() {
          if (statusBuilder_ == null) {
            statusBuilder_ = new com.google.protobuf.SingleFieldBuilder<
                opentelemetry.proto.mmap.v1.Mmap.Status, opentelemetry.proto.mmap.v1.Mmap.Status.Builder, opentelemetry.proto.mmap.v1.Mmap.StatusOrBuilder>(
                    getStatus(),
                    getParentForChildren(),
                    isClean());
            status_ = null;
          }
          return statusBuilder_;
        }

        // @@protoc_insertion_point(builder_scope:opentelemetry.proto.mmap.v1.SpanEvent.EndSpan)
      }

      // @@protoc_insertion_point(class_scope:opentelemetry.proto.mmap.v1.SpanEvent.EndSpan)
      private static final opentelemetry.proto.mmap.v1.Mmap.SpanEvent.EndSpan DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new opentelemetry.proto.mmap.v1.Mmap.SpanEvent.EndSpan();
      }

      public static opentelemetry.proto.mmap.v1.Mmap.SpanEvent.EndSpan getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static final com.google.protobuf.Parser<EndSpan>
          PARSER = new com.google.protobuf.AbstractParser<EndSpan>() {
        @java.lang.Override
        public EndSpan parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          Builder builder = newBuilder();
          try {
            builder.mergeFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.setUnfinishedMessage(builder.buildPartial());
          } catch (com.google.protobuf.UninitializedMessageException e) {
            throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
          } catch (java.io.IOException e) {
            throw new com.google.protobuf.InvalidProtocolBufferException(e)
                .setUnfinishedMessage(builder.buildPartial());
          }
          return builder.buildPartial();
        }
      };

      public static com.google.protobuf.Parser<EndSpan> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<EndSpan> getParserForType() {
        return PARSER;
      }

      @java.lang.Override
      public opentelemetry.proto.mmap.v1.Mmap.SpanEvent.EndSpan getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    public interface ChangeSpanNameOrBuilder extends
        // @@protoc_insertion_point(interface_extends:opentelemetry.proto.mmap.v1.SpanEvent.ChangeSpanName)
        com.google.protobuf.MessageOrBuilder {

      /**
       * <pre>
       * A description of the span's operation.
       *
       * For example, the name can be a qualified method name or a file name
       * and a line number where the operation is called. A best practice is to use
       * the same display name at the same call point in an application.
       * This makes it easier to correlate spans in different traces.
       *
       * This field is semantically required to be set to non-empty string.
       * Empty value is equivalent to an unknown span name.
       *
       * This field is required.
       * </pre>
       *
       * <code>string name = 5;</code>
       * @return The name.
       */
      java.lang.String getName();
      /**
       * <pre>
       * A description of the span's operation.
       *
       * For example, the name can be a qualified method name or a file name
       * and a line number where the operation is called. A best practice is to use
       * the same display name at the same call point in an application.
       * This makes it easier to correlate spans in different traces.
       *
       * This field is semantically required to be set to non-empty string.
       * Empty value is equivalent to an unknown span name.
       *
       * This field is required.
       * </pre>
       *
       * <code>string name = 5;</code>
       * @return The bytes for name.
       */
      com.google.protobuf.ByteString
          getNameBytes();
    }
    /**
     * Protobuf type {@code opentelemetry.proto.mmap.v1.SpanEvent.ChangeSpanName}
     */
    public static final class ChangeSpanName extends
        com.google.protobuf.GeneratedMessage implements
        // @@protoc_insertion_point(message_implements:opentelemetry.proto.mmap.v1.SpanEvent.ChangeSpanName)
        ChangeSpanNameOrBuilder {
    private static final long serialVersionUID = 0L;
      static {
        com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
          com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
          /* major= */ 4,
          /* minor= */ 33,
          /* patch= */ 0,
          /* suffix= */ "",
          "ChangeSpanName");
      }
      // Use ChangeSpanName.newBuilder() to construct.
      private ChangeSpanName(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
        super(builder);
      }
      private ChangeSpanName() {
        name_ = "";
      }

      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_SpanEvent_ChangeSpanName_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_SpanEvent_ChangeSpanName_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                opentelemetry.proto.mmap.v1.Mmap.SpanEvent.ChangeSpanName.class, opentelemetry.proto.mmap.v1.Mmap.SpanEvent.ChangeSpanName.Builder.class);
      }

      public static final int NAME_FIELD_NUMBER = 5;
      @SuppressWarnings("serial")
      private volatile java.lang.Object name_ = "";
      /**
       * <pre>
       * A description of the span's operation.
       *
       * For example, the name can be a qualified method name or a file name
       * and a line number where the operation is called. A best practice is to use
       * the same display name at the same call point in an application.
       * This makes it easier to correlate spans in different traces.
       *
       * This field is semantically required to be set to non-empty string.
       * Empty value is equivalent to an unknown span name.
       *
       * This field is required.
       * </pre>
       *
       * <code>string name = 5;</code>
       * @return The name.
       */
      @java.lang.Override
      public java.lang.String getName() {
        java.lang.Object ref = name_;
        if (ref instanceof java.lang.String) {
          return (java.lang.String) ref;
        } else {
          com.google.protobuf.ByteString bs = 
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          name_ = s;
          return s;
        }
      }
      /**
       * <pre>
       * A description of the span's operation.
       *
       * For example, the name can be a qualified method name or a file name
       * and a line number where the operation is called. A best practice is to use
       * the same display name at the same call point in an application.
       * This makes it easier to correlate spans in different traces.
       *
       * This field is semantically required to be set to non-empty string.
       * Empty value is equivalent to an unknown span name.
       *
       * This field is required.
       * </pre>
       *
       * <code>string name = 5;</code>
       * @return The bytes for name.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getNameBytes() {
        java.lang.Object ref = name_;
        if (ref instanceof java.lang.String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          name_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }

      private byte memoizedIsInitialized = -1;
      @java.lang.Override
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        memoizedIsInitialized = 1;
        return true;
      }

      @java.lang.Override
      public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        if (!com.google.protobuf.GeneratedMessage.isStringEmpty(name_)) {
          com.google.protobuf.GeneratedMessage.writeString(output, 5, name_);
        }
        getUnknownFields().writeTo(output);
      }

      @java.lang.Override
      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        if (!com.google.protobuf.GeneratedMessage.isStringEmpty(name_)) {
          size += com.google.protobuf.GeneratedMessage.computeStringSize(5, name_);
        }
        size += getUnknownFields().getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof opentelemetry.proto.mmap.v1.Mmap.SpanEvent.ChangeSpanName)) {
          return super.equals(obj);
        }
        opentelemetry.proto.mmap.v1.Mmap.SpanEvent.ChangeSpanName other = (opentelemetry.proto.mmap.v1.Mmap.SpanEvent.ChangeSpanName) obj;

        if (!getName()
            .equals(other.getName())) return false;
        if (!getUnknownFields().equals(other.getUnknownFields())) return false;
        return true;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        hash = (37 * hash) + NAME_FIELD_NUMBER;
        hash = (53 * hash) + getName().hashCode();
        hash = (29 * hash) + getUnknownFields().hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static opentelemetry.proto.mmap.v1.Mmap.SpanEvent.ChangeSpanName parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static opentelemetry.proto.mmap.v1.Mmap.SpanEvent.ChangeSpanName parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static opentelemetry.proto.mmap.v1.Mmap.SpanEvent.ChangeSpanName parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static opentelemetry.proto.mmap.v1.Mmap.SpanEvent.ChangeSpanName parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static opentelemetry.proto.mmap.v1.Mmap.SpanEvent.ChangeSpanName parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static opentelemetry.proto.mmap.v1.Mmap.SpanEvent.ChangeSpanName parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static opentelemetry.proto.mmap.v1.Mmap.SpanEvent.ChangeSpanName parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input);
      }
      public static opentelemetry.proto.mmap.v1.Mmap.SpanEvent.ChangeSpanName parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      public static opentelemetry.proto.mmap.v1.Mmap.SpanEvent.ChangeSpanName parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseDelimitedWithIOException(PARSER, input);
      }

      public static opentelemetry.proto.mmap.v1.Mmap.SpanEvent.ChangeSpanName parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static opentelemetry.proto.mmap.v1.Mmap.SpanEvent.ChangeSpanName parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input);
      }
      public static opentelemetry.proto.mmap.v1.Mmap.SpanEvent.ChangeSpanName parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      @java.lang.Override
      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(opentelemetry.proto.mmap.v1.Mmap.SpanEvent.ChangeSpanName prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      @java.lang.Override
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * Protobuf type {@code opentelemetry.proto.mmap.v1.SpanEvent.ChangeSpanName}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessage.Builder<Builder> implements
          // @@protoc_insertion_point(builder_implements:opentelemetry.proto.mmap.v1.SpanEvent.ChangeSpanName)
          opentelemetry.proto.mmap.v1.Mmap.SpanEvent.ChangeSpanNameOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_SpanEvent_ChangeSpanName_descriptor;
        }

        @java.lang.Override
        protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_SpanEvent_ChangeSpanName_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  opentelemetry.proto.mmap.v1.Mmap.SpanEvent.ChangeSpanName.class, opentelemetry.proto.mmap.v1.Mmap.SpanEvent.ChangeSpanName.Builder.class);
        }

        // Construct using opentelemetry.proto.mmap.v1.Mmap.SpanEvent.ChangeSpanName.newBuilder()
        private Builder() {

        }

        private Builder(
            com.google.protobuf.GeneratedMessage.BuilderParent parent) {
          super(parent);

        }
        @java.lang.Override
        public Builder clear() {
          super.clear();
          bitField0_ = 0;
          name_ = "";
          return this;
        }

        @java.lang.Override
        public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_SpanEvent_ChangeSpanName_descriptor;
        }

        @java.lang.Override
        public opentelemetry.proto.mmap.v1.Mmap.SpanEvent.ChangeSpanName getDefaultInstanceForType() {
          return opentelemetry.proto.mmap.v1.Mmap.SpanEvent.ChangeSpanName.getDefaultInstance();
        }

        @java.lang.Override
        public opentelemetry.proto.mmap.v1.Mmap.SpanEvent.ChangeSpanName build() {
          opentelemetry.proto.mmap.v1.Mmap.SpanEvent.ChangeSpanName result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        @java.lang.Override
        public opentelemetry.proto.mmap.v1.Mmap.SpanEvent.ChangeSpanName buildPartial() {
          opentelemetry.proto.mmap.v1.Mmap.SpanEvent.ChangeSpanName result = new opentelemetry.proto.mmap.v1.Mmap.SpanEvent.ChangeSpanName(this);
          if (bitField0_ != 0) { buildPartial0(result); }
          onBuilt();
          return result;
        }

        private void buildPartial0(opentelemetry.proto.mmap.v1.Mmap.SpanEvent.ChangeSpanName result) {
          int from_bitField0_ = bitField0_;
          if (((from_bitField0_ & 0x00000001) != 0)) {
            result.name_ = name_;
          }
        }

        @java.lang.Override
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other instanceof opentelemetry.proto.mmap.v1.Mmap.SpanEvent.ChangeSpanName) {
            return mergeFrom((opentelemetry.proto.mmap.v1.Mmap.SpanEvent.ChangeSpanName)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(opentelemetry.proto.mmap.v1.Mmap.SpanEvent.ChangeSpanName other) {
          if (other == opentelemetry.proto.mmap.v1.Mmap.SpanEvent.ChangeSpanName.getDefaultInstance()) return this;
          if (!other.getName().isEmpty()) {
            name_ = other.name_;
            bitField0_ |= 0x00000001;
            onChanged();
          }
          this.mergeUnknownFields(other.getUnknownFields());
          onChanged();
          return this;
        }

        @java.lang.Override
        public final boolean isInitialized() {
          return true;
        }

        @java.lang.Override
        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          if (extensionRegistry == null) {
            throw new java.lang.NullPointerException();
          }
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                case 42: {
                  name_ = input.readStringRequireUtf8();
                  bitField0_ |= 0x00000001;
                  break;
                } // case 42
                default: {
                  if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                    done = true; // was an endgroup tag
                  }
                  break;
                } // default:
              } // switch (tag)
            } // while (!done)
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.unwrapIOException();
          } finally {
            onChanged();
          } // finally
          return this;
        }
        private int bitField0_;

        private java.lang.Object name_ = "";
        /**
         * <pre>
         * A description of the span's operation.
         *
         * For example, the name can be a qualified method name or a file name
         * and a line number where the operation is called. A best practice is to use
         * the same display name at the same call point in an application.
         * This makes it easier to correlate spans in different traces.
         *
         * This field is semantically required to be set to non-empty string.
         * Empty value is equivalent to an unknown span name.
         *
         * This field is required.
         * </pre>
         *
         * <code>string name = 5;</code>
         * @return The name.
         */
        public java.lang.String getName() {
          java.lang.Object ref = name_;
          if (!(ref instanceof java.lang.String)) {
            com.google.protobuf.ByteString bs =
                (com.google.protobuf.ByteString) ref;
            java.lang.String s = bs.toStringUtf8();
            name_ = s;
            return s;
          } else {
            return (java.lang.String) ref;
          }
        }
        /**
         * <pre>
         * A description of the span's operation.
         *
         * For example, the name can be a qualified method name or a file name
         * and a line number where the operation is called. A best practice is to use
         * the same display name at the same call point in an application.
         * This makes it easier to correlate spans in different traces.
         *
         * This field is semantically required to be set to non-empty string.
         * Empty value is equivalent to an unknown span name.
         *
         * This field is required.
         * </pre>
         *
         * <code>string name = 5;</code>
         * @return The bytes for name.
         */
        public com.google.protobuf.ByteString
            getNameBytes() {
          java.lang.Object ref = name_;
          if (ref instanceof String) {
            com.google.protobuf.ByteString b = 
                com.google.protobuf.ByteString.copyFromUtf8(
                    (java.lang.String) ref);
            name_ = b;
            return b;
          } else {
            return (com.google.protobuf.ByteString) ref;
          }
        }
        /**
         * <pre>
         * A description of the span's operation.
         *
         * For example, the name can be a qualified method name or a file name
         * and a line number where the operation is called. A best practice is to use
         * the same display name at the same call point in an application.
         * This makes it easier to correlate spans in different traces.
         *
         * This field is semantically required to be set to non-empty string.
         * Empty value is equivalent to an unknown span name.
         *
         * This field is required.
         * </pre>
         *
         * <code>string name = 5;</code>
         * @param value The name to set.
         * @return This builder for chaining.
         */
        public Builder setName(
            java.lang.String value) {
          if (value == null) { throw new NullPointerException(); }
          name_ = value;
          bitField0_ |= 0x00000001;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * A description of the span's operation.
         *
         * For example, the name can be a qualified method name or a file name
         * and a line number where the operation is called. A best practice is to use
         * the same display name at the same call point in an application.
         * This makes it easier to correlate spans in different traces.
         *
         * This field is semantically required to be set to non-empty string.
         * Empty value is equivalent to an unknown span name.
         *
         * This field is required.
         * </pre>
         *
         * <code>string name = 5;</code>
         * @return This builder for chaining.
         */
        public Builder clearName() {
          name_ = getDefaultInstance().getName();
          bitField0_ = (bitField0_ & ~0x00000001);
          onChanged();
          return this;
        }
        /**
         * <pre>
         * A description of the span's operation.
         *
         * For example, the name can be a qualified method name or a file name
         * and a line number where the operation is called. A best practice is to use
         * the same display name at the same call point in an application.
         * This makes it easier to correlate spans in different traces.
         *
         * This field is semantically required to be set to non-empty string.
         * Empty value is equivalent to an unknown span name.
         *
         * This field is required.
         * </pre>
         *
         * <code>string name = 5;</code>
         * @param value The bytes for name to set.
         * @return This builder for chaining.
         */
        public Builder setNameBytes(
            com.google.protobuf.ByteString value) {
          if (value == null) { throw new NullPointerException(); }
          checkByteStringIsUtf8(value);
          name_ = value;
          bitField0_ |= 0x00000001;
          onChanged();
          return this;
        }

        // @@protoc_insertion_point(builder_scope:opentelemetry.proto.mmap.v1.SpanEvent.ChangeSpanName)
      }

      // @@protoc_insertion_point(class_scope:opentelemetry.proto.mmap.v1.SpanEvent.ChangeSpanName)
      private static final opentelemetry.proto.mmap.v1.Mmap.SpanEvent.ChangeSpanName DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new opentelemetry.proto.mmap.v1.Mmap.SpanEvent.ChangeSpanName();
      }

      public static opentelemetry.proto.mmap.v1.Mmap.SpanEvent.ChangeSpanName getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static final com.google.protobuf.Parser<ChangeSpanName>
          PARSER = new com.google.protobuf.AbstractParser<ChangeSpanName>() {
        @java.lang.Override
        public ChangeSpanName parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          Builder builder = newBuilder();
          try {
            builder.mergeFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.setUnfinishedMessage(builder.buildPartial());
          } catch (com.google.protobuf.UninitializedMessageException e) {
            throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
          } catch (java.io.IOException e) {
            throw new com.google.protobuf.InvalidProtocolBufferException(e)
                .setUnfinishedMessage(builder.buildPartial());
          }
          return builder.buildPartial();
        }
      };

      public static com.google.protobuf.Parser<ChangeSpanName> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<ChangeSpanName> getParserForType() {
        return PARSER;
      }

      @java.lang.Override
      public opentelemetry.proto.mmap.v1.Mmap.SpanEvent.ChangeSpanName getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    public interface UpdateAttributesOrBuilder extends
        // @@protoc_insertion_point(interface_extends:opentelemetry.proto.mmap.v1.SpanEvent.UpdateAttributes)
        com.google.protobuf.MessageOrBuilder {

      /**
       * <pre>
       * A collection of key/value pairs. Note, global attributes
       * like server name can be set using the resource API. Examples of attributes:
       *
       * "/http/user_agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"
       * "/http/server_latency": 300
       * "example.com/myattribute": true
       * "example.com/score": 10.239
       *
       * Attribute keys MUST be unique (it is not allowed to have more than one
       * attribute with the same key).
       *
       * The attribute values SHOULD NOT contain empty values.
       * The attribute values SHOULD NOT contain bytes values.
       * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
       * double values.
       * The attribute values SHOULD NOT contain kvlist values.
       * The behavior of software that receives attributes containing such values can be unpredictable.
       * These restrictions can change in a minor release.
       * The restrictions take origin from the OpenTelemetry specification:
       * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 9;</code>
       */
      java.util.List<opentelemetry.proto.mmap.v1.Mmap.KeyValueRef> 
          getAttributesList();
      /**
       * <pre>
       * A collection of key/value pairs. Note, global attributes
       * like server name can be set using the resource API. Examples of attributes:
       *
       * "/http/user_agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"
       * "/http/server_latency": 300
       * "example.com/myattribute": true
       * "example.com/score": 10.239
       *
       * Attribute keys MUST be unique (it is not allowed to have more than one
       * attribute with the same key).
       *
       * The attribute values SHOULD NOT contain empty values.
       * The attribute values SHOULD NOT contain bytes values.
       * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
       * double values.
       * The attribute values SHOULD NOT contain kvlist values.
       * The behavior of software that receives attributes containing such values can be unpredictable.
       * These restrictions can change in a minor release.
       * The restrictions take origin from the OpenTelemetry specification:
       * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 9;</code>
       */
      opentelemetry.proto.mmap.v1.Mmap.KeyValueRef getAttributes(int index);
      /**
       * <pre>
       * A collection of key/value pairs. Note, global attributes
       * like server name can be set using the resource API. Examples of attributes:
       *
       * "/http/user_agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"
       * "/http/server_latency": 300
       * "example.com/myattribute": true
       * "example.com/score": 10.239
       *
       * Attribute keys MUST be unique (it is not allowed to have more than one
       * attribute with the same key).
       *
       * The attribute values SHOULD NOT contain empty values.
       * The attribute values SHOULD NOT contain bytes values.
       * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
       * double values.
       * The attribute values SHOULD NOT contain kvlist values.
       * The behavior of software that receives attributes containing such values can be unpredictable.
       * These restrictions can change in a minor release.
       * The restrictions take origin from the OpenTelemetry specification:
       * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 9;</code>
       */
      int getAttributesCount();
      /**
       * <pre>
       * A collection of key/value pairs. Note, global attributes
       * like server name can be set using the resource API. Examples of attributes:
       *
       * "/http/user_agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"
       * "/http/server_latency": 300
       * "example.com/myattribute": true
       * "example.com/score": 10.239
       *
       * Attribute keys MUST be unique (it is not allowed to have more than one
       * attribute with the same key).
       *
       * The attribute values SHOULD NOT contain empty values.
       * The attribute values SHOULD NOT contain bytes values.
       * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
       * double values.
       * The attribute values SHOULD NOT contain kvlist values.
       * The behavior of software that receives attributes containing such values can be unpredictable.
       * These restrictions can change in a minor release.
       * The restrictions take origin from the OpenTelemetry specification:
       * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 9;</code>
       */
      java.util.List<? extends opentelemetry.proto.mmap.v1.Mmap.KeyValueRefOrBuilder> 
          getAttributesOrBuilderList();
      /**
       * <pre>
       * A collection of key/value pairs. Note, global attributes
       * like server name can be set using the resource API. Examples of attributes:
       *
       * "/http/user_agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"
       * "/http/server_latency": 300
       * "example.com/myattribute": true
       * "example.com/score": 10.239
       *
       * Attribute keys MUST be unique (it is not allowed to have more than one
       * attribute with the same key).
       *
       * The attribute values SHOULD NOT contain empty values.
       * The attribute values SHOULD NOT contain bytes values.
       * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
       * double values.
       * The attribute values SHOULD NOT contain kvlist values.
       * The behavior of software that receives attributes containing such values can be unpredictable.
       * These restrictions can change in a minor release.
       * The restrictions take origin from the OpenTelemetry specification:
       * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 9;</code>
       */
      opentelemetry.proto.mmap.v1.Mmap.KeyValueRefOrBuilder getAttributesOrBuilder(
          int index);
    }
    /**
     * Protobuf type {@code opentelemetry.proto.mmap.v1.SpanEvent.UpdateAttributes}
     */
    public static final class UpdateAttributes extends
        com.google.protobuf.GeneratedMessage implements
        // @@protoc_insertion_point(message_implements:opentelemetry.proto.mmap.v1.SpanEvent.UpdateAttributes)
        UpdateAttributesOrBuilder {
    private static final long serialVersionUID = 0L;
      static {
        com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
          com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
          /* major= */ 4,
          /* minor= */ 33,
          /* patch= */ 0,
          /* suffix= */ "",
          "UpdateAttributes");
      }
      // Use UpdateAttributes.newBuilder() to construct.
      private UpdateAttributes(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
        super(builder);
      }
      private UpdateAttributes() {
        attributes_ = java.util.Collections.emptyList();
      }

      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_SpanEvent_UpdateAttributes_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_SpanEvent_UpdateAttributes_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                opentelemetry.proto.mmap.v1.Mmap.SpanEvent.UpdateAttributes.class, opentelemetry.proto.mmap.v1.Mmap.SpanEvent.UpdateAttributes.Builder.class);
      }

      public static final int ATTRIBUTES_FIELD_NUMBER = 9;
      @SuppressWarnings("serial")
      private java.util.List<opentelemetry.proto.mmap.v1.Mmap.KeyValueRef> attributes_;
      /**
       * <pre>
       * A collection of key/value pairs. Note, global attributes
       * like server name can be set using the resource API. Examples of attributes:
       *
       * "/http/user_agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"
       * "/http/server_latency": 300
       * "example.com/myattribute": true
       * "example.com/score": 10.239
       *
       * Attribute keys MUST be unique (it is not allowed to have more than one
       * attribute with the same key).
       *
       * The attribute values SHOULD NOT contain empty values.
       * The attribute values SHOULD NOT contain bytes values.
       * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
       * double values.
       * The attribute values SHOULD NOT contain kvlist values.
       * The behavior of software that receives attributes containing such values can be unpredictable.
       * These restrictions can change in a minor release.
       * The restrictions take origin from the OpenTelemetry specification:
       * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 9;</code>
       */
      @java.lang.Override
      public java.util.List<opentelemetry.proto.mmap.v1.Mmap.KeyValueRef> getAttributesList() {
        return attributes_;
      }
      /**
       * <pre>
       * A collection of key/value pairs. Note, global attributes
       * like server name can be set using the resource API. Examples of attributes:
       *
       * "/http/user_agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"
       * "/http/server_latency": 300
       * "example.com/myattribute": true
       * "example.com/score": 10.239
       *
       * Attribute keys MUST be unique (it is not allowed to have more than one
       * attribute with the same key).
       *
       * The attribute values SHOULD NOT contain empty values.
       * The attribute values SHOULD NOT contain bytes values.
       * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
       * double values.
       * The attribute values SHOULD NOT contain kvlist values.
       * The behavior of software that receives attributes containing such values can be unpredictable.
       * These restrictions can change in a minor release.
       * The restrictions take origin from the OpenTelemetry specification:
       * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 9;</code>
       */
      @java.lang.Override
      public java.util.List<? extends opentelemetry.proto.mmap.v1.Mmap.KeyValueRefOrBuilder> 
          getAttributesOrBuilderList() {
        return attributes_;
      }
      /**
       * <pre>
       * A collection of key/value pairs. Note, global attributes
       * like server name can be set using the resource API. Examples of attributes:
       *
       * "/http/user_agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"
       * "/http/server_latency": 300
       * "example.com/myattribute": true
       * "example.com/score": 10.239
       *
       * Attribute keys MUST be unique (it is not allowed to have more than one
       * attribute with the same key).
       *
       * The attribute values SHOULD NOT contain empty values.
       * The attribute values SHOULD NOT contain bytes values.
       * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
       * double values.
       * The attribute values SHOULD NOT contain kvlist values.
       * The behavior of software that receives attributes containing such values can be unpredictable.
       * These restrictions can change in a minor release.
       * The restrictions take origin from the OpenTelemetry specification:
       * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 9;</code>
       */
      @java.lang.Override
      public int getAttributesCount() {
        return attributes_.size();
      }
      /**
       * <pre>
       * A collection of key/value pairs. Note, global attributes
       * like server name can be set using the resource API. Examples of attributes:
       *
       * "/http/user_agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"
       * "/http/server_latency": 300
       * "example.com/myattribute": true
       * "example.com/score": 10.239
       *
       * Attribute keys MUST be unique (it is not allowed to have more than one
       * attribute with the same key).
       *
       * The attribute values SHOULD NOT contain empty values.
       * The attribute values SHOULD NOT contain bytes values.
       * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
       * double values.
       * The attribute values SHOULD NOT contain kvlist values.
       * The behavior of software that receives attributes containing such values can be unpredictable.
       * These restrictions can change in a minor release.
       * The restrictions take origin from the OpenTelemetry specification:
       * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 9;</code>
       */
      @java.lang.Override
      public opentelemetry.proto.mmap.v1.Mmap.KeyValueRef getAttributes(int index) {
        return attributes_.get(index);
      }
      /**
       * <pre>
       * A collection of key/value pairs. Note, global attributes
       * like server name can be set using the resource API. Examples of attributes:
       *
       * "/http/user_agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"
       * "/http/server_latency": 300
       * "example.com/myattribute": true
       * "example.com/score": 10.239
       *
       * Attribute keys MUST be unique (it is not allowed to have more than one
       * attribute with the same key).
       *
       * The attribute values SHOULD NOT contain empty values.
       * The attribute values SHOULD NOT contain bytes values.
       * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
       * double values.
       * The attribute values SHOULD NOT contain kvlist values.
       * The behavior of software that receives attributes containing such values can be unpredictable.
       * These restrictions can change in a minor release.
       * The restrictions take origin from the OpenTelemetry specification:
       * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 9;</code>
       */
      @java.lang.Override
      public opentelemetry.proto.mmap.v1.Mmap.KeyValueRefOrBuilder getAttributesOrBuilder(
          int index) {
        return attributes_.get(index);
      }

      private byte memoizedIsInitialized = -1;
      @java.lang.Override
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        memoizedIsInitialized = 1;
        return true;
      }

      @java.lang.Override
      public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        for (int i = 0; i < attributes_.size(); i++) {
          output.writeMessage(9, attributes_.get(i));
        }
        getUnknownFields().writeTo(output);
      }

      @java.lang.Override
      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        for (int i = 0; i < attributes_.size(); i++) {
          size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(9, attributes_.get(i));
        }
        size += getUnknownFields().getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof opentelemetry.proto.mmap.v1.Mmap.SpanEvent.UpdateAttributes)) {
          return super.equals(obj);
        }
        opentelemetry.proto.mmap.v1.Mmap.SpanEvent.UpdateAttributes other = (opentelemetry.proto.mmap.v1.Mmap.SpanEvent.UpdateAttributes) obj;

        if (!getAttributesList()
            .equals(other.getAttributesList())) return false;
        if (!getUnknownFields().equals(other.getUnknownFields())) return false;
        return true;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        if (getAttributesCount() > 0) {
          hash = (37 * hash) + ATTRIBUTES_FIELD_NUMBER;
          hash = (53 * hash) + getAttributesList().hashCode();
        }
        hash = (29 * hash) + getUnknownFields().hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static opentelemetry.proto.mmap.v1.Mmap.SpanEvent.UpdateAttributes parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static opentelemetry.proto.mmap.v1.Mmap.SpanEvent.UpdateAttributes parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static opentelemetry.proto.mmap.v1.Mmap.SpanEvent.UpdateAttributes parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static opentelemetry.proto.mmap.v1.Mmap.SpanEvent.UpdateAttributes parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static opentelemetry.proto.mmap.v1.Mmap.SpanEvent.UpdateAttributes parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static opentelemetry.proto.mmap.v1.Mmap.SpanEvent.UpdateAttributes parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static opentelemetry.proto.mmap.v1.Mmap.SpanEvent.UpdateAttributes parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input);
      }
      public static opentelemetry.proto.mmap.v1.Mmap.SpanEvent.UpdateAttributes parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      public static opentelemetry.proto.mmap.v1.Mmap.SpanEvent.UpdateAttributes parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseDelimitedWithIOException(PARSER, input);
      }

      public static opentelemetry.proto.mmap.v1.Mmap.SpanEvent.UpdateAttributes parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static opentelemetry.proto.mmap.v1.Mmap.SpanEvent.UpdateAttributes parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input);
      }
      public static opentelemetry.proto.mmap.v1.Mmap.SpanEvent.UpdateAttributes parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      @java.lang.Override
      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(opentelemetry.proto.mmap.v1.Mmap.SpanEvent.UpdateAttributes prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      @java.lang.Override
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * Protobuf type {@code opentelemetry.proto.mmap.v1.SpanEvent.UpdateAttributes}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessage.Builder<Builder> implements
          // @@protoc_insertion_point(builder_implements:opentelemetry.proto.mmap.v1.SpanEvent.UpdateAttributes)
          opentelemetry.proto.mmap.v1.Mmap.SpanEvent.UpdateAttributesOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_SpanEvent_UpdateAttributes_descriptor;
        }

        @java.lang.Override
        protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_SpanEvent_UpdateAttributes_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  opentelemetry.proto.mmap.v1.Mmap.SpanEvent.UpdateAttributes.class, opentelemetry.proto.mmap.v1.Mmap.SpanEvent.UpdateAttributes.Builder.class);
        }

        // Construct using opentelemetry.proto.mmap.v1.Mmap.SpanEvent.UpdateAttributes.newBuilder()
        private Builder() {

        }

        private Builder(
            com.google.protobuf.GeneratedMessage.BuilderParent parent) {
          super(parent);

        }
        @java.lang.Override
        public Builder clear() {
          super.clear();
          bitField0_ = 0;
          if (attributesBuilder_ == null) {
            attributes_ = java.util.Collections.emptyList();
          } else {
            attributes_ = null;
            attributesBuilder_.clear();
          }
          bitField0_ = (bitField0_ & ~0x00000001);
          return this;
        }

        @java.lang.Override
        public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_SpanEvent_UpdateAttributes_descriptor;
        }

        @java.lang.Override
        public opentelemetry.proto.mmap.v1.Mmap.SpanEvent.UpdateAttributes getDefaultInstanceForType() {
          return opentelemetry.proto.mmap.v1.Mmap.SpanEvent.UpdateAttributes.getDefaultInstance();
        }

        @java.lang.Override
        public opentelemetry.proto.mmap.v1.Mmap.SpanEvent.UpdateAttributes build() {
          opentelemetry.proto.mmap.v1.Mmap.SpanEvent.UpdateAttributes result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        @java.lang.Override
        public opentelemetry.proto.mmap.v1.Mmap.SpanEvent.UpdateAttributes buildPartial() {
          opentelemetry.proto.mmap.v1.Mmap.SpanEvent.UpdateAttributes result = new opentelemetry.proto.mmap.v1.Mmap.SpanEvent.UpdateAttributes(this);
          buildPartialRepeatedFields(result);
          if (bitField0_ != 0) { buildPartial0(result); }
          onBuilt();
          return result;
        }

        private void buildPartialRepeatedFields(opentelemetry.proto.mmap.v1.Mmap.SpanEvent.UpdateAttributes result) {
          if (attributesBuilder_ == null) {
            if (((bitField0_ & 0x00000001) != 0)) {
              attributes_ = java.util.Collections.unmodifiableList(attributes_);
              bitField0_ = (bitField0_ & ~0x00000001);
            }
            result.attributes_ = attributes_;
          } else {
            result.attributes_ = attributesBuilder_.build();
          }
        }

        private void buildPartial0(opentelemetry.proto.mmap.v1.Mmap.SpanEvent.UpdateAttributes result) {
          int from_bitField0_ = bitField0_;
        }

        @java.lang.Override
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other instanceof opentelemetry.proto.mmap.v1.Mmap.SpanEvent.UpdateAttributes) {
            return mergeFrom((opentelemetry.proto.mmap.v1.Mmap.SpanEvent.UpdateAttributes)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(opentelemetry.proto.mmap.v1.Mmap.SpanEvent.UpdateAttributes other) {
          if (other == opentelemetry.proto.mmap.v1.Mmap.SpanEvent.UpdateAttributes.getDefaultInstance()) return this;
          if (attributesBuilder_ == null) {
            if (!other.attributes_.isEmpty()) {
              if (attributes_.isEmpty()) {
                attributes_ = other.attributes_;
                bitField0_ = (bitField0_ & ~0x00000001);
              } else {
                ensureAttributesIsMutable();
                attributes_.addAll(other.attributes_);
              }
              onChanged();
            }
          } else {
            if (!other.attributes_.isEmpty()) {
              if (attributesBuilder_.isEmpty()) {
                attributesBuilder_.dispose();
                attributesBuilder_ = null;
                attributes_ = other.attributes_;
                bitField0_ = (bitField0_ & ~0x00000001);
                attributesBuilder_ = 
                  com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                     internalGetAttributesFieldBuilder() : null;
              } else {
                attributesBuilder_.addAllMessages(other.attributes_);
              }
            }
          }
          this.mergeUnknownFields(other.getUnknownFields());
          onChanged();
          return this;
        }

        @java.lang.Override
        public final boolean isInitialized() {
          return true;
        }

        @java.lang.Override
        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          if (extensionRegistry == null) {
            throw new java.lang.NullPointerException();
          }
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                case 74: {
                  opentelemetry.proto.mmap.v1.Mmap.KeyValueRef m =
                      input.readMessage(
                          opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.parser(),
                          extensionRegistry);
                  if (attributesBuilder_ == null) {
                    ensureAttributesIsMutable();
                    attributes_.add(m);
                  } else {
                    attributesBuilder_.addMessage(m);
                  }
                  break;
                } // case 74
                default: {
                  if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                    done = true; // was an endgroup tag
                  }
                  break;
                } // default:
              } // switch (tag)
            } // while (!done)
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.unwrapIOException();
          } finally {
            onChanged();
          } // finally
          return this;
        }
        private int bitField0_;

        private java.util.List<opentelemetry.proto.mmap.v1.Mmap.KeyValueRef> attributes_ =
          java.util.Collections.emptyList();
        private void ensureAttributesIsMutable() {
          if (!((bitField0_ & 0x00000001) != 0)) {
            attributes_ = new java.util.ArrayList<opentelemetry.proto.mmap.v1.Mmap.KeyValueRef>(attributes_);
            bitField0_ |= 0x00000001;
           }
        }

        private com.google.protobuf.RepeatedFieldBuilder<
            opentelemetry.proto.mmap.v1.Mmap.KeyValueRef, opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.Builder, opentelemetry.proto.mmap.v1.Mmap.KeyValueRefOrBuilder> attributesBuilder_;

        /**
         * <pre>
         * A collection of key/value pairs. Note, global attributes
         * like server name can be set using the resource API. Examples of attributes:
         *
         * "/http/user_agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"
         * "/http/server_latency": 300
         * "example.com/myattribute": true
         * "example.com/score": 10.239
         *
         * Attribute keys MUST be unique (it is not allowed to have more than one
         * attribute with the same key).
         *
         * The attribute values SHOULD NOT contain empty values.
         * The attribute values SHOULD NOT contain bytes values.
         * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
         * double values.
         * The attribute values SHOULD NOT contain kvlist values.
         * The behavior of software that receives attributes containing such values can be unpredictable.
         * These restrictions can change in a minor release.
         * The restrictions take origin from the OpenTelemetry specification:
         * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
         * </pre>
         *
         * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 9;</code>
         */
        public java.util.List<opentelemetry.proto.mmap.v1.Mmap.KeyValueRef> getAttributesList() {
          if (attributesBuilder_ == null) {
            return java.util.Collections.unmodifiableList(attributes_);
          } else {
            return attributesBuilder_.getMessageList();
          }
        }
        /**
         * <pre>
         * A collection of key/value pairs. Note, global attributes
         * like server name can be set using the resource API. Examples of attributes:
         *
         * "/http/user_agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"
         * "/http/server_latency": 300
         * "example.com/myattribute": true
         * "example.com/score": 10.239
         *
         * Attribute keys MUST be unique (it is not allowed to have more than one
         * attribute with the same key).
         *
         * The attribute values SHOULD NOT contain empty values.
         * The attribute values SHOULD NOT contain bytes values.
         * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
         * double values.
         * The attribute values SHOULD NOT contain kvlist values.
         * The behavior of software that receives attributes containing such values can be unpredictable.
         * These restrictions can change in a minor release.
         * The restrictions take origin from the OpenTelemetry specification:
         * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
         * </pre>
         *
         * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 9;</code>
         */
        public int getAttributesCount() {
          if (attributesBuilder_ == null) {
            return attributes_.size();
          } else {
            return attributesBuilder_.getCount();
          }
        }
        /**
         * <pre>
         * A collection of key/value pairs. Note, global attributes
         * like server name can be set using the resource API. Examples of attributes:
         *
         * "/http/user_agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"
         * "/http/server_latency": 300
         * "example.com/myattribute": true
         * "example.com/score": 10.239
         *
         * Attribute keys MUST be unique (it is not allowed to have more than one
         * attribute with the same key).
         *
         * The attribute values SHOULD NOT contain empty values.
         * The attribute values SHOULD NOT contain bytes values.
         * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
         * double values.
         * The attribute values SHOULD NOT contain kvlist values.
         * The behavior of software that receives attributes containing such values can be unpredictable.
         * These restrictions can change in a minor release.
         * The restrictions take origin from the OpenTelemetry specification:
         * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
         * </pre>
         *
         * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 9;</code>
         */
        public opentelemetry.proto.mmap.v1.Mmap.KeyValueRef getAttributes(int index) {
          if (attributesBuilder_ == null) {
            return attributes_.get(index);
          } else {
            return attributesBuilder_.getMessage(index);
          }
        }
        /**
         * <pre>
         * A collection of key/value pairs. Note, global attributes
         * like server name can be set using the resource API. Examples of attributes:
         *
         * "/http/user_agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"
         * "/http/server_latency": 300
         * "example.com/myattribute": true
         * "example.com/score": 10.239
         *
         * Attribute keys MUST be unique (it is not allowed to have more than one
         * attribute with the same key).
         *
         * The attribute values SHOULD NOT contain empty values.
         * The attribute values SHOULD NOT contain bytes values.
         * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
         * double values.
         * The attribute values SHOULD NOT contain kvlist values.
         * The behavior of software that receives attributes containing such values can be unpredictable.
         * These restrictions can change in a minor release.
         * The restrictions take origin from the OpenTelemetry specification:
         * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
         * </pre>
         *
         * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 9;</code>
         */
        public Builder setAttributes(
            int index, opentelemetry.proto.mmap.v1.Mmap.KeyValueRef value) {
          if (attributesBuilder_ == null) {
            if (value == null) {
              throw new NullPointerException();
            }
            ensureAttributesIsMutable();
            attributes_.set(index, value);
            onChanged();
          } else {
            attributesBuilder_.setMessage(index, value);
          }
          return this;
        }
        /**
         * <pre>
         * A collection of key/value pairs. Note, global attributes
         * like server name can be set using the resource API. Examples of attributes:
         *
         * "/http/user_agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"
         * "/http/server_latency": 300
         * "example.com/myattribute": true
         * "example.com/score": 10.239
         *
         * Attribute keys MUST be unique (it is not allowed to have more than one
         * attribute with the same key).
         *
         * The attribute values SHOULD NOT contain empty values.
         * The attribute values SHOULD NOT contain bytes values.
         * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
         * double values.
         * The attribute values SHOULD NOT contain kvlist values.
         * The behavior of software that receives attributes containing such values can be unpredictable.
         * These restrictions can change in a minor release.
         * The restrictions take origin from the OpenTelemetry specification:
         * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
         * </pre>
         *
         * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 9;</code>
         */
        public Builder setAttributes(
            int index, opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.Builder builderForValue) {
          if (attributesBuilder_ == null) {
            ensureAttributesIsMutable();
            attributes_.set(index, builderForValue.build());
            onChanged();
          } else {
            attributesBuilder_.setMessage(index, builderForValue.build());
          }
          return this;
        }
        /**
         * <pre>
         * A collection of key/value pairs. Note, global attributes
         * like server name can be set using the resource API. Examples of attributes:
         *
         * "/http/user_agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"
         * "/http/server_latency": 300
         * "example.com/myattribute": true
         * "example.com/score": 10.239
         *
         * Attribute keys MUST be unique (it is not allowed to have more than one
         * attribute with the same key).
         *
         * The attribute values SHOULD NOT contain empty values.
         * The attribute values SHOULD NOT contain bytes values.
         * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
         * double values.
         * The attribute values SHOULD NOT contain kvlist values.
         * The behavior of software that receives attributes containing such values can be unpredictable.
         * These restrictions can change in a minor release.
         * The restrictions take origin from the OpenTelemetry specification:
         * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
         * </pre>
         *
         * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 9;</code>
         */
        public Builder addAttributes(opentelemetry.proto.mmap.v1.Mmap.KeyValueRef value) {
          if (attributesBuilder_ == null) {
            if (value == null) {
              throw new NullPointerException();
            }
            ensureAttributesIsMutable();
            attributes_.add(value);
            onChanged();
          } else {
            attributesBuilder_.addMessage(value);
          }
          return this;
        }
        /**
         * <pre>
         * A collection of key/value pairs. Note, global attributes
         * like server name can be set using the resource API. Examples of attributes:
         *
         * "/http/user_agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"
         * "/http/server_latency": 300
         * "example.com/myattribute": true
         * "example.com/score": 10.239
         *
         * Attribute keys MUST be unique (it is not allowed to have more than one
         * attribute with the same key).
         *
         * The attribute values SHOULD NOT contain empty values.
         * The attribute values SHOULD NOT contain bytes values.
         * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
         * double values.
         * The attribute values SHOULD NOT contain kvlist values.
         * The behavior of software that receives attributes containing such values can be unpredictable.
         * These restrictions can change in a minor release.
         * The restrictions take origin from the OpenTelemetry specification:
         * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
         * </pre>
         *
         * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 9;</code>
         */
        public Builder addAttributes(
            int index, opentelemetry.proto.mmap.v1.Mmap.KeyValueRef value) {
          if (attributesBuilder_ == null) {
            if (value == null) {
              throw new NullPointerException();
            }
            ensureAttributesIsMutable();
            attributes_.add(index, value);
            onChanged();
          } else {
            attributesBuilder_.addMessage(index, value);
          }
          return this;
        }
        /**
         * <pre>
         * A collection of key/value pairs. Note, global attributes
         * like server name can be set using the resource API. Examples of attributes:
         *
         * "/http/user_agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"
         * "/http/server_latency": 300
         * "example.com/myattribute": true
         * "example.com/score": 10.239
         *
         * Attribute keys MUST be unique (it is not allowed to have more than one
         * attribute with the same key).
         *
         * The attribute values SHOULD NOT contain empty values.
         * The attribute values SHOULD NOT contain bytes values.
         * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
         * double values.
         * The attribute values SHOULD NOT contain kvlist values.
         * The behavior of software that receives attributes containing such values can be unpredictable.
         * These restrictions can change in a minor release.
         * The restrictions take origin from the OpenTelemetry specification:
         * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
         * </pre>
         *
         * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 9;</code>
         */
        public Builder addAttributes(
            opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.Builder builderForValue) {
          if (attributesBuilder_ == null) {
            ensureAttributesIsMutable();
            attributes_.add(builderForValue.build());
            onChanged();
          } else {
            attributesBuilder_.addMessage(builderForValue.build());
          }
          return this;
        }
        /**
         * <pre>
         * A collection of key/value pairs. Note, global attributes
         * like server name can be set using the resource API. Examples of attributes:
         *
         * "/http/user_agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"
         * "/http/server_latency": 300
         * "example.com/myattribute": true
         * "example.com/score": 10.239
         *
         * Attribute keys MUST be unique (it is not allowed to have more than one
         * attribute with the same key).
         *
         * The attribute values SHOULD NOT contain empty values.
         * The attribute values SHOULD NOT contain bytes values.
         * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
         * double values.
         * The attribute values SHOULD NOT contain kvlist values.
         * The behavior of software that receives attributes containing such values can be unpredictable.
         * These restrictions can change in a minor release.
         * The restrictions take origin from the OpenTelemetry specification:
         * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
         * </pre>
         *
         * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 9;</code>
         */
        public Builder addAttributes(
            int index, opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.Builder builderForValue) {
          if (attributesBuilder_ == null) {
            ensureAttributesIsMutable();
            attributes_.add(index, builderForValue.build());
            onChanged();
          } else {
            attributesBuilder_.addMessage(index, builderForValue.build());
          }
          return this;
        }
        /**
         * <pre>
         * A collection of key/value pairs. Note, global attributes
         * like server name can be set using the resource API. Examples of attributes:
         *
         * "/http/user_agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"
         * "/http/server_latency": 300
         * "example.com/myattribute": true
         * "example.com/score": 10.239
         *
         * Attribute keys MUST be unique (it is not allowed to have more than one
         * attribute with the same key).
         *
         * The attribute values SHOULD NOT contain empty values.
         * The attribute values SHOULD NOT contain bytes values.
         * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
         * double values.
         * The attribute values SHOULD NOT contain kvlist values.
         * The behavior of software that receives attributes containing such values can be unpredictable.
         * These restrictions can change in a minor release.
         * The restrictions take origin from the OpenTelemetry specification:
         * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
         * </pre>
         *
         * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 9;</code>
         */
        public Builder addAllAttributes(
            java.lang.Iterable<? extends opentelemetry.proto.mmap.v1.Mmap.KeyValueRef> values) {
          if (attributesBuilder_ == null) {
            ensureAttributesIsMutable();
            com.google.protobuf.AbstractMessageLite.Builder.addAll(
                values, attributes_);
            onChanged();
          } else {
            attributesBuilder_.addAllMessages(values);
          }
          return this;
        }
        /**
         * <pre>
         * A collection of key/value pairs. Note, global attributes
         * like server name can be set using the resource API. Examples of attributes:
         *
         * "/http/user_agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"
         * "/http/server_latency": 300
         * "example.com/myattribute": true
         * "example.com/score": 10.239
         *
         * Attribute keys MUST be unique (it is not allowed to have more than one
         * attribute with the same key).
         *
         * The attribute values SHOULD NOT contain empty values.
         * The attribute values SHOULD NOT contain bytes values.
         * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
         * double values.
         * The attribute values SHOULD NOT contain kvlist values.
         * The behavior of software that receives attributes containing such values can be unpredictable.
         * These restrictions can change in a minor release.
         * The restrictions take origin from the OpenTelemetry specification:
         * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
         * </pre>
         *
         * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 9;</code>
         */
        public Builder clearAttributes() {
          if (attributesBuilder_ == null) {
            attributes_ = java.util.Collections.emptyList();
            bitField0_ = (bitField0_ & ~0x00000001);
            onChanged();
          } else {
            attributesBuilder_.clear();
          }
          return this;
        }
        /**
         * <pre>
         * A collection of key/value pairs. Note, global attributes
         * like server name can be set using the resource API. Examples of attributes:
         *
         * "/http/user_agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"
         * "/http/server_latency": 300
         * "example.com/myattribute": true
         * "example.com/score": 10.239
         *
         * Attribute keys MUST be unique (it is not allowed to have more than one
         * attribute with the same key).
         *
         * The attribute values SHOULD NOT contain empty values.
         * The attribute values SHOULD NOT contain bytes values.
         * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
         * double values.
         * The attribute values SHOULD NOT contain kvlist values.
         * The behavior of software that receives attributes containing such values can be unpredictable.
         * These restrictions can change in a minor release.
         * The restrictions take origin from the OpenTelemetry specification:
         * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
         * </pre>
         *
         * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 9;</code>
         */
        public Builder removeAttributes(int index) {
          if (attributesBuilder_ == null) {
            ensureAttributesIsMutable();
            attributes_.remove(index);
            onChanged();
          } else {
            attributesBuilder_.remove(index);
          }
          return this;
        }
        /**
         * <pre>
         * A collection of key/value pairs. Note, global attributes
         * like server name can be set using the resource API. Examples of attributes:
         *
         * "/http/user_agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"
         * "/http/server_latency": 300
         * "example.com/myattribute": true
         * "example.com/score": 10.239
         *
         * Attribute keys MUST be unique (it is not allowed to have more than one
         * attribute with the same key).
         *
         * The attribute values SHOULD NOT contain empty values.
         * The attribute values SHOULD NOT contain bytes values.
         * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
         * double values.
         * The attribute values SHOULD NOT contain kvlist values.
         * The behavior of software that receives attributes containing such values can be unpredictable.
         * These restrictions can change in a minor release.
         * The restrictions take origin from the OpenTelemetry specification:
         * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
         * </pre>
         *
         * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 9;</code>
         */
        public opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.Builder getAttributesBuilder(
            int index) {
          return internalGetAttributesFieldBuilder().getBuilder(index);
        }
        /**
         * <pre>
         * A collection of key/value pairs. Note, global attributes
         * like server name can be set using the resource API. Examples of attributes:
         *
         * "/http/user_agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"
         * "/http/server_latency": 300
         * "example.com/myattribute": true
         * "example.com/score": 10.239
         *
         * Attribute keys MUST be unique (it is not allowed to have more than one
         * attribute with the same key).
         *
         * The attribute values SHOULD NOT contain empty values.
         * The attribute values SHOULD NOT contain bytes values.
         * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
         * double values.
         * The attribute values SHOULD NOT contain kvlist values.
         * The behavior of software that receives attributes containing such values can be unpredictable.
         * These restrictions can change in a minor release.
         * The restrictions take origin from the OpenTelemetry specification:
         * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
         * </pre>
         *
         * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 9;</code>
         */
        public opentelemetry.proto.mmap.v1.Mmap.KeyValueRefOrBuilder getAttributesOrBuilder(
            int index) {
          if (attributesBuilder_ == null) {
            return attributes_.get(index);  } else {
            return attributesBuilder_.getMessageOrBuilder(index);
          }
        }
        /**
         * <pre>
         * A collection of key/value pairs. Note, global attributes
         * like server name can be set using the resource API. Examples of attributes:
         *
         * "/http/user_agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"
         * "/http/server_latency": 300
         * "example.com/myattribute": true
         * "example.com/score": 10.239
         *
         * Attribute keys MUST be unique (it is not allowed to have more than one
         * attribute with the same key).
         *
         * The attribute values SHOULD NOT contain empty values.
         * The attribute values SHOULD NOT contain bytes values.
         * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
         * double values.
         * The attribute values SHOULD NOT contain kvlist values.
         * The behavior of software that receives attributes containing such values can be unpredictable.
         * These restrictions can change in a minor release.
         * The restrictions take origin from the OpenTelemetry specification:
         * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
         * </pre>
         *
         * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 9;</code>
         */
        public java.util.List<? extends opentelemetry.proto.mmap.v1.Mmap.KeyValueRefOrBuilder> 
             getAttributesOrBuilderList() {
          if (attributesBuilder_ != null) {
            return attributesBuilder_.getMessageOrBuilderList();
          } else {
            return java.util.Collections.unmodifiableList(attributes_);
          }
        }
        /**
         * <pre>
         * A collection of key/value pairs. Note, global attributes
         * like server name can be set using the resource API. Examples of attributes:
         *
         * "/http/user_agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"
         * "/http/server_latency": 300
         * "example.com/myattribute": true
         * "example.com/score": 10.239
         *
         * Attribute keys MUST be unique (it is not allowed to have more than one
         * attribute with the same key).
         *
         * The attribute values SHOULD NOT contain empty values.
         * The attribute values SHOULD NOT contain bytes values.
         * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
         * double values.
         * The attribute values SHOULD NOT contain kvlist values.
         * The behavior of software that receives attributes containing such values can be unpredictable.
         * These restrictions can change in a minor release.
         * The restrictions take origin from the OpenTelemetry specification:
         * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
         * </pre>
         *
         * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 9;</code>
         */
        public opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.Builder addAttributesBuilder() {
          return internalGetAttributesFieldBuilder().addBuilder(
              opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.getDefaultInstance());
        }
        /**
         * <pre>
         * A collection of key/value pairs. Note, global attributes
         * like server name can be set using the resource API. Examples of attributes:
         *
         * "/http/user_agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"
         * "/http/server_latency": 300
         * "example.com/myattribute": true
         * "example.com/score": 10.239
         *
         * Attribute keys MUST be unique (it is not allowed to have more than one
         * attribute with the same key).
         *
         * The attribute values SHOULD NOT contain empty values.
         * The attribute values SHOULD NOT contain bytes values.
         * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
         * double values.
         * The attribute values SHOULD NOT contain kvlist values.
         * The behavior of software that receives attributes containing such values can be unpredictable.
         * These restrictions can change in a minor release.
         * The restrictions take origin from the OpenTelemetry specification:
         * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
         * </pre>
         *
         * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 9;</code>
         */
        public opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.Builder addAttributesBuilder(
            int index) {
          return internalGetAttributesFieldBuilder().addBuilder(
              index, opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.getDefaultInstance());
        }
        /**
         * <pre>
         * A collection of key/value pairs. Note, global attributes
         * like server name can be set using the resource API. Examples of attributes:
         *
         * "/http/user_agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"
         * "/http/server_latency": 300
         * "example.com/myattribute": true
         * "example.com/score": 10.239
         *
         * Attribute keys MUST be unique (it is not allowed to have more than one
         * attribute with the same key).
         *
         * The attribute values SHOULD NOT contain empty values.
         * The attribute values SHOULD NOT contain bytes values.
         * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
         * double values.
         * The attribute values SHOULD NOT contain kvlist values.
         * The behavior of software that receives attributes containing such values can be unpredictable.
         * These restrictions can change in a minor release.
         * The restrictions take origin from the OpenTelemetry specification:
         * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
         * </pre>
         *
         * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 9;</code>
         */
        public java.util.List<opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.Builder> 
             getAttributesBuilderList() {
          return internalGetAttributesFieldBuilder().getBuilderList();
        }
        private com.google.protobuf.RepeatedFieldBuilder<
            opentelemetry.proto.mmap.v1.Mmap.KeyValueRef, opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.Builder, opentelemetry.proto.mmap.v1.Mmap.KeyValueRefOrBuilder> 
            internalGetAttributesFieldBuilder() {
          if (attributesBuilder_ == null) {
            attributesBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
                opentelemetry.proto.mmap.v1.Mmap.KeyValueRef, opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.Builder, opentelemetry.proto.mmap.v1.Mmap.KeyValueRefOrBuilder>(
                    attributes_,
                    ((bitField0_ & 0x00000001) != 0),
                    getParentForChildren(),
                    isClean());
            attributes_ = null;
          }
          return attributesBuilder_;
        }

        // @@protoc_insertion_point(builder_scope:opentelemetry.proto.mmap.v1.SpanEvent.UpdateAttributes)
      }

      // @@protoc_insertion_point(class_scope:opentelemetry.proto.mmap.v1.SpanEvent.UpdateAttributes)
      private static final opentelemetry.proto.mmap.v1.Mmap.SpanEvent.UpdateAttributes DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new opentelemetry.proto.mmap.v1.Mmap.SpanEvent.UpdateAttributes();
      }

      public static opentelemetry.proto.mmap.v1.Mmap.SpanEvent.UpdateAttributes getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static final com.google.protobuf.Parser<UpdateAttributes>
          PARSER = new com.google.protobuf.AbstractParser<UpdateAttributes>() {
        @java.lang.Override
        public UpdateAttributes parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          Builder builder = newBuilder();
          try {
            builder.mergeFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.setUnfinishedMessage(builder.buildPartial());
          } catch (com.google.protobuf.UninitializedMessageException e) {
            throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
          } catch (java.io.IOException e) {
            throw new com.google.protobuf.InvalidProtocolBufferException(e)
                .setUnfinishedMessage(builder.buildPartial());
          }
          return builder.buildPartial();
        }
      };

      public static com.google.protobuf.Parser<UpdateAttributes> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<UpdateAttributes> getParserForType() {
        return PARSER;
      }

      @java.lang.Override
      public opentelemetry.proto.mmap.v1.Mmap.SpanEvent.UpdateAttributes getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    public interface AddLinkOrBuilder extends
        // @@protoc_insertion_point(interface_extends:opentelemetry.proto.mmap.v1.SpanEvent.AddLink)
        com.google.protobuf.MessageOrBuilder {

      /**
       * <pre>
       * A collection of Links, which are references from this span to a span
       * in the same or different trace.
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.SpanEvent.AddLink.Link links = 13;</code>
       */
      java.util.List<opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink.Link> 
          getLinksList();
      /**
       * <pre>
       * A collection of Links, which are references from this span to a span
       * in the same or different trace.
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.SpanEvent.AddLink.Link links = 13;</code>
       */
      opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink.Link getLinks(int index);
      /**
       * <pre>
       * A collection of Links, which are references from this span to a span
       * in the same or different trace.
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.SpanEvent.AddLink.Link links = 13;</code>
       */
      int getLinksCount();
      /**
       * <pre>
       * A collection of Links, which are references from this span to a span
       * in the same or different trace.
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.SpanEvent.AddLink.Link links = 13;</code>
       */
      java.util.List<? extends opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink.LinkOrBuilder> 
          getLinksOrBuilderList();
      /**
       * <pre>
       * A collection of Links, which are references from this span to a span
       * in the same or different trace.
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.SpanEvent.AddLink.Link links = 13;</code>
       */
      opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink.LinkOrBuilder getLinksOrBuilder(
          int index);
    }
    /**
     * Protobuf type {@code opentelemetry.proto.mmap.v1.SpanEvent.AddLink}
     */
    public static final class AddLink extends
        com.google.protobuf.GeneratedMessage implements
        // @@protoc_insertion_point(message_implements:opentelemetry.proto.mmap.v1.SpanEvent.AddLink)
        AddLinkOrBuilder {
    private static final long serialVersionUID = 0L;
      static {
        com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
          com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
          /* major= */ 4,
          /* minor= */ 33,
          /* patch= */ 0,
          /* suffix= */ "",
          "AddLink");
      }
      // Use AddLink.newBuilder() to construct.
      private AddLink(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
        super(builder);
      }
      private AddLink() {
        links_ = java.util.Collections.emptyList();
      }

      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_SpanEvent_AddLink_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_SpanEvent_AddLink_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink.class, opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink.Builder.class);
      }

      public interface LinkOrBuilder extends
          // @@protoc_insertion_point(interface_extends:opentelemetry.proto.mmap.v1.SpanEvent.AddLink.Link)
          com.google.protobuf.MessageOrBuilder {

        /**
         * <pre>
         * A unique identifier of a trace that this linked span is part of. The ID is a
         * 16-byte array.
         * </pre>
         *
         * <code>bytes trace_id = 1;</code>
         * @return The traceId.
         */
        com.google.protobuf.ByteString getTraceId();

        /**
         * <pre>
         * A unique identifier for the linked span. The ID is an 8-byte array.
         * </pre>
         *
         * <code>bytes span_id = 2;</code>
         * @return The spanId.
         */
        com.google.protobuf.ByteString getSpanId();

        /**
         * <pre>
         * The trace_state associated with the link.
         * </pre>
         *
         * <code>string trace_state = 3;</code>
         * @return The traceState.
         */
        java.lang.String getTraceState();
        /**
         * <pre>
         * The trace_state associated with the link.
         * </pre>
         *
         * <code>string trace_state = 3;</code>
         * @return The bytes for traceState.
         */
        com.google.protobuf.ByteString
            getTraceStateBytes();

        /**
         * <pre>
         * A collection of attribute key/value pairs on the link.
         * Attribute keys MUST be unique (it is not allowed to have more than one
         * attribute with the same key).
         *
         * The attribute values SHOULD NOT contain empty values.
         * The attribute values SHOULD NOT contain bytes values.
         * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
         * double values.
         * The attribute values SHOULD NOT contain kvlist values.
         * The behavior of software that receives attributes containing such values can be unpredictable.
         * These restrictions can change in a minor release.
         * The restrictions take origin from the OpenTelemetry specification:
         * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
         * </pre>
         *
         * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 4;</code>
         */
        java.util.List<opentelemetry.proto.mmap.v1.Mmap.KeyValueRef> 
            getAttributesList();
        /**
         * <pre>
         * A collection of attribute key/value pairs on the link.
         * Attribute keys MUST be unique (it is not allowed to have more than one
         * attribute with the same key).
         *
         * The attribute values SHOULD NOT contain empty values.
         * The attribute values SHOULD NOT contain bytes values.
         * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
         * double values.
         * The attribute values SHOULD NOT contain kvlist values.
         * The behavior of software that receives attributes containing such values can be unpredictable.
         * These restrictions can change in a minor release.
         * The restrictions take origin from the OpenTelemetry specification:
         * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
         * </pre>
         *
         * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 4;</code>
         */
        opentelemetry.proto.mmap.v1.Mmap.KeyValueRef getAttributes(int index);
        /**
         * <pre>
         * A collection of attribute key/value pairs on the link.
         * Attribute keys MUST be unique (it is not allowed to have more than one
         * attribute with the same key).
         *
         * The attribute values SHOULD NOT contain empty values.
         * The attribute values SHOULD NOT contain bytes values.
         * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
         * double values.
         * The attribute values SHOULD NOT contain kvlist values.
         * The behavior of software that receives attributes containing such values can be unpredictable.
         * These restrictions can change in a minor release.
         * The restrictions take origin from the OpenTelemetry specification:
         * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
         * </pre>
         *
         * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 4;</code>
         */
        int getAttributesCount();
        /**
         * <pre>
         * A collection of attribute key/value pairs on the link.
         * Attribute keys MUST be unique (it is not allowed to have more than one
         * attribute with the same key).
         *
         * The attribute values SHOULD NOT contain empty values.
         * The attribute values SHOULD NOT contain bytes values.
         * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
         * double values.
         * The attribute values SHOULD NOT contain kvlist values.
         * The behavior of software that receives attributes containing such values can be unpredictable.
         * These restrictions can change in a minor release.
         * The restrictions take origin from the OpenTelemetry specification:
         * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
         * </pre>
         *
         * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 4;</code>
         */
        java.util.List<? extends opentelemetry.proto.mmap.v1.Mmap.KeyValueRefOrBuilder> 
            getAttributesOrBuilderList();
        /**
         * <pre>
         * A collection of attribute key/value pairs on the link.
         * Attribute keys MUST be unique (it is not allowed to have more than one
         * attribute with the same key).
         *
         * The attribute values SHOULD NOT contain empty values.
         * The attribute values SHOULD NOT contain bytes values.
         * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
         * double values.
         * The attribute values SHOULD NOT contain kvlist values.
         * The behavior of software that receives attributes containing such values can be unpredictable.
         * These restrictions can change in a minor release.
         * The restrictions take origin from the OpenTelemetry specification:
         * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
         * </pre>
         *
         * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 4;</code>
         */
        opentelemetry.proto.mmap.v1.Mmap.KeyValueRefOrBuilder getAttributesOrBuilder(
            int index);

        /**
         * <pre>
         * The number of dropped attributes. If the value is 0,
         * then no attributes were dropped.
         * </pre>
         *
         * <code>uint32 dropped_attributes_count = 5;</code>
         * @return The droppedAttributesCount.
         */
        int getDroppedAttributesCount();

        /**
         * <pre>
         * Flags, a bit field.
         *
         * Bits 0-7 (8 least significant bits) are the trace flags as defined in W3C Trace
         * Context specification. To read the 8-bit W3C trace flag, use
         * `flags &amp; SPAN_FLAGS_TRACE_FLAGS_MASK`.
         *
         * See https://www.w3.org/TR/trace-context-2/#trace-flags for the flag definitions.
         *
         * Bits 8 and 9 represent the 3 states of whether the link is remote.
         * The states are (unknown, is not remote, is remote).
         * To read whether the value is known, use `(flags &amp; SPAN_FLAGS_CONTEXT_HAS_IS_REMOTE_MASK) != 0`.
         * To read whether the link is remote, use `(flags &amp; SPAN_FLAGS_CONTEXT_IS_REMOTE_MASK) != 0`.
         *
         * Readers MUST NOT assume that bits 10-31 (22 most significant bits) will be zero.
         * When creating new spans, bits 10-31 (most-significant 22-bits) MUST be zero.
         *
         * [Optional].
         * </pre>
         *
         * <code>fixed32 flags = 6;</code>
         * @return The flags.
         */
        int getFlags();
      }
      /**
       * <pre>
       * A pointer from the current span to another span in the same trace or in a
       * different trace. For example, this can be used in batching operations,
       * where a single batch handler processes multiple requests from different
       * traces or when the handler receives a request from a different project.
       * </pre>
       *
       * Protobuf type {@code opentelemetry.proto.mmap.v1.SpanEvent.AddLink.Link}
       */
      public static final class Link extends
          com.google.protobuf.GeneratedMessage implements
          // @@protoc_insertion_point(message_implements:opentelemetry.proto.mmap.v1.SpanEvent.AddLink.Link)
          LinkOrBuilder {
      private static final long serialVersionUID = 0L;
        static {
          com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
            com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
            /* major= */ 4,
            /* minor= */ 33,
            /* patch= */ 0,
            /* suffix= */ "",
            "Link");
        }
        // Use Link.newBuilder() to construct.
        private Link(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
          super(builder);
        }
        private Link() {
          traceId_ = com.google.protobuf.ByteString.EMPTY;
          spanId_ = com.google.protobuf.ByteString.EMPTY;
          traceState_ = "";
          attributes_ = java.util.Collections.emptyList();
        }

        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_SpanEvent_AddLink_Link_descriptor;
        }

        @java.lang.Override
        protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_SpanEvent_AddLink_Link_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink.Link.class, opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink.Link.Builder.class);
        }

        public static final int TRACE_ID_FIELD_NUMBER = 1;
        private com.google.protobuf.ByteString traceId_ = com.google.protobuf.ByteString.EMPTY;
        /**
         * <pre>
         * A unique identifier of a trace that this linked span is part of. The ID is a
         * 16-byte array.
         * </pre>
         *
         * <code>bytes trace_id = 1;</code>
         * @return The traceId.
         */
        @java.lang.Override
        public com.google.protobuf.ByteString getTraceId() {
          return traceId_;
        }

        public static final int SPAN_ID_FIELD_NUMBER = 2;
        private com.google.protobuf.ByteString spanId_ = com.google.protobuf.ByteString.EMPTY;
        /**
         * <pre>
         * A unique identifier for the linked span. The ID is an 8-byte array.
         * </pre>
         *
         * <code>bytes span_id = 2;</code>
         * @return The spanId.
         */
        @java.lang.Override
        public com.google.protobuf.ByteString getSpanId() {
          return spanId_;
        }

        public static final int TRACE_STATE_FIELD_NUMBER = 3;
        @SuppressWarnings("serial")
        private volatile java.lang.Object traceState_ = "";
        /**
         * <pre>
         * The trace_state associated with the link.
         * </pre>
         *
         * <code>string trace_state = 3;</code>
         * @return The traceState.
         */
        @java.lang.Override
        public java.lang.String getTraceState() {
          java.lang.Object ref = traceState_;
          if (ref instanceof java.lang.String) {
            return (java.lang.String) ref;
          } else {
            com.google.protobuf.ByteString bs = 
                (com.google.protobuf.ByteString) ref;
            java.lang.String s = bs.toStringUtf8();
            traceState_ = s;
            return s;
          }
        }
        /**
         * <pre>
         * The trace_state associated with the link.
         * </pre>
         *
         * <code>string trace_state = 3;</code>
         * @return The bytes for traceState.
         */
        @java.lang.Override
        public com.google.protobuf.ByteString
            getTraceStateBytes() {
          java.lang.Object ref = traceState_;
          if (ref instanceof java.lang.String) {
            com.google.protobuf.ByteString b = 
                com.google.protobuf.ByteString.copyFromUtf8(
                    (java.lang.String) ref);
            traceState_ = b;
            return b;
          } else {
            return (com.google.protobuf.ByteString) ref;
          }
        }

        public static final int ATTRIBUTES_FIELD_NUMBER = 4;
        @SuppressWarnings("serial")
        private java.util.List<opentelemetry.proto.mmap.v1.Mmap.KeyValueRef> attributes_;
        /**
         * <pre>
         * A collection of attribute key/value pairs on the link.
         * Attribute keys MUST be unique (it is not allowed to have more than one
         * attribute with the same key).
         *
         * The attribute values SHOULD NOT contain empty values.
         * The attribute values SHOULD NOT contain bytes values.
         * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
         * double values.
         * The attribute values SHOULD NOT contain kvlist values.
         * The behavior of software that receives attributes containing such values can be unpredictable.
         * These restrictions can change in a minor release.
         * The restrictions take origin from the OpenTelemetry specification:
         * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
         * </pre>
         *
         * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 4;</code>
         */
        @java.lang.Override
        public java.util.List<opentelemetry.proto.mmap.v1.Mmap.KeyValueRef> getAttributesList() {
          return attributes_;
        }
        /**
         * <pre>
         * A collection of attribute key/value pairs on the link.
         * Attribute keys MUST be unique (it is not allowed to have more than one
         * attribute with the same key).
         *
         * The attribute values SHOULD NOT contain empty values.
         * The attribute values SHOULD NOT contain bytes values.
         * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
         * double values.
         * The attribute values SHOULD NOT contain kvlist values.
         * The behavior of software that receives attributes containing such values can be unpredictable.
         * These restrictions can change in a minor release.
         * The restrictions take origin from the OpenTelemetry specification:
         * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
         * </pre>
         *
         * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 4;</code>
         */
        @java.lang.Override
        public java.util.List<? extends opentelemetry.proto.mmap.v1.Mmap.KeyValueRefOrBuilder> 
            getAttributesOrBuilderList() {
          return attributes_;
        }
        /**
         * <pre>
         * A collection of attribute key/value pairs on the link.
         * Attribute keys MUST be unique (it is not allowed to have more than one
         * attribute with the same key).
         *
         * The attribute values SHOULD NOT contain empty values.
         * The attribute values SHOULD NOT contain bytes values.
         * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
         * double values.
         * The attribute values SHOULD NOT contain kvlist values.
         * The behavior of software that receives attributes containing such values can be unpredictable.
         * These restrictions can change in a minor release.
         * The restrictions take origin from the OpenTelemetry specification:
         * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
         * </pre>
         *
         * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 4;</code>
         */
        @java.lang.Override
        public int getAttributesCount() {
          return attributes_.size();
        }
        /**
         * <pre>
         * A collection of attribute key/value pairs on the link.
         * Attribute keys MUST be unique (it is not allowed to have more than one
         * attribute with the same key).
         *
         * The attribute values SHOULD NOT contain empty values.
         * The attribute values SHOULD NOT contain bytes values.
         * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
         * double values.
         * The attribute values SHOULD NOT contain kvlist values.
         * The behavior of software that receives attributes containing such values can be unpredictable.
         * These restrictions can change in a minor release.
         * The restrictions take origin from the OpenTelemetry specification:
         * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
         * </pre>
         *
         * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 4;</code>
         */
        @java.lang.Override
        public opentelemetry.proto.mmap.v1.Mmap.KeyValueRef getAttributes(int index) {
          return attributes_.get(index);
        }
        /**
         * <pre>
         * A collection of attribute key/value pairs on the link.
         * Attribute keys MUST be unique (it is not allowed to have more than one
         * attribute with the same key).
         *
         * The attribute values SHOULD NOT contain empty values.
         * The attribute values SHOULD NOT contain bytes values.
         * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
         * double values.
         * The attribute values SHOULD NOT contain kvlist values.
         * The behavior of software that receives attributes containing such values can be unpredictable.
         * These restrictions can change in a minor release.
         * The restrictions take origin from the OpenTelemetry specification:
         * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
         * </pre>
         *
         * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 4;</code>
         */
        @java.lang.Override
        public opentelemetry.proto.mmap.v1.Mmap.KeyValueRefOrBuilder getAttributesOrBuilder(
            int index) {
          return attributes_.get(index);
        }

        public static final int DROPPED_ATTRIBUTES_COUNT_FIELD_NUMBER = 5;
        private int droppedAttributesCount_ = 0;
        /**
         * <pre>
         * The number of dropped attributes. If the value is 0,
         * then no attributes were dropped.
         * </pre>
         *
         * <code>uint32 dropped_attributes_count = 5;</code>
         * @return The droppedAttributesCount.
         */
        @java.lang.Override
        public int getDroppedAttributesCount() {
          return droppedAttributesCount_;
        }

        public static final int FLAGS_FIELD_NUMBER = 6;
        private int flags_ = 0;
        /**
         * <pre>
         * Flags, a bit field.
         *
         * Bits 0-7 (8 least significant bits) are the trace flags as defined in W3C Trace
         * Context specification. To read the 8-bit W3C trace flag, use
         * `flags &amp; SPAN_FLAGS_TRACE_FLAGS_MASK`.
         *
         * See https://www.w3.org/TR/trace-context-2/#trace-flags for the flag definitions.
         *
         * Bits 8 and 9 represent the 3 states of whether the link is remote.
         * The states are (unknown, is not remote, is remote).
         * To read whether the value is known, use `(flags &amp; SPAN_FLAGS_CONTEXT_HAS_IS_REMOTE_MASK) != 0`.
         * To read whether the link is remote, use `(flags &amp; SPAN_FLAGS_CONTEXT_IS_REMOTE_MASK) != 0`.
         *
         * Readers MUST NOT assume that bits 10-31 (22 most significant bits) will be zero.
         * When creating new spans, bits 10-31 (most-significant 22-bits) MUST be zero.
         *
         * [Optional].
         * </pre>
         *
         * <code>fixed32 flags = 6;</code>
         * @return The flags.
         */
        @java.lang.Override
        public int getFlags() {
          return flags_;
        }

        private byte memoizedIsInitialized = -1;
        @java.lang.Override
        public final boolean isInitialized() {
          byte isInitialized = memoizedIsInitialized;
          if (isInitialized == 1) return true;
          if (isInitialized == 0) return false;

          memoizedIsInitialized = 1;
          return true;
        }

        @java.lang.Override
        public void writeTo(com.google.protobuf.CodedOutputStream output)
                            throws java.io.IOException {
          if (!traceId_.isEmpty()) {
            output.writeBytes(1, traceId_);
          }
          if (!spanId_.isEmpty()) {
            output.writeBytes(2, spanId_);
          }
          if (!com.google.protobuf.GeneratedMessage.isStringEmpty(traceState_)) {
            com.google.protobuf.GeneratedMessage.writeString(output, 3, traceState_);
          }
          for (int i = 0; i < attributes_.size(); i++) {
            output.writeMessage(4, attributes_.get(i));
          }
          if (droppedAttributesCount_ != 0) {
            output.writeUInt32(5, droppedAttributesCount_);
          }
          if (flags_ != 0) {
            output.writeFixed32(6, flags_);
          }
          getUnknownFields().writeTo(output);
        }

        @java.lang.Override
        public int getSerializedSize() {
          int size = memoizedSize;
          if (size != -1) return size;

          size = 0;
          if (!traceId_.isEmpty()) {
            size += com.google.protobuf.CodedOutputStream
              .computeBytesSize(1, traceId_);
          }
          if (!spanId_.isEmpty()) {
            size += com.google.protobuf.CodedOutputStream
              .computeBytesSize(2, spanId_);
          }
          if (!com.google.protobuf.GeneratedMessage.isStringEmpty(traceState_)) {
            size += com.google.protobuf.GeneratedMessage.computeStringSize(3, traceState_);
          }
          for (int i = 0; i < attributes_.size(); i++) {
            size += com.google.protobuf.CodedOutputStream
              .computeMessageSize(4, attributes_.get(i));
          }
          if (droppedAttributesCount_ != 0) {
            size += com.google.protobuf.CodedOutputStream
              .computeUInt32Size(5, droppedAttributesCount_);
          }
          if (flags_ != 0) {
            size += com.google.protobuf.CodedOutputStream
              .computeFixed32Size(6, flags_);
          }
          size += getUnknownFields().getSerializedSize();
          memoizedSize = size;
          return size;
        }

        @java.lang.Override
        public boolean equals(final java.lang.Object obj) {
          if (obj == this) {
           return true;
          }
          if (!(obj instanceof opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink.Link)) {
            return super.equals(obj);
          }
          opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink.Link other = (opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink.Link) obj;

          if (!getTraceId()
              .equals(other.getTraceId())) return false;
          if (!getSpanId()
              .equals(other.getSpanId())) return false;
          if (!getTraceState()
              .equals(other.getTraceState())) return false;
          if (!getAttributesList()
              .equals(other.getAttributesList())) return false;
          if (getDroppedAttributesCount()
              != other.getDroppedAttributesCount()) return false;
          if (getFlags()
              != other.getFlags()) return false;
          if (!getUnknownFields().equals(other.getUnknownFields())) return false;
          return true;
        }

        @java.lang.Override
        public int hashCode() {
          if (memoizedHashCode != 0) {
            return memoizedHashCode;
          }
          int hash = 41;
          hash = (19 * hash) + getDescriptor().hashCode();
          hash = (37 * hash) + TRACE_ID_FIELD_NUMBER;
          hash = (53 * hash) + getTraceId().hashCode();
          hash = (37 * hash) + SPAN_ID_FIELD_NUMBER;
          hash = (53 * hash) + getSpanId().hashCode();
          hash = (37 * hash) + TRACE_STATE_FIELD_NUMBER;
          hash = (53 * hash) + getTraceState().hashCode();
          if (getAttributesCount() > 0) {
            hash = (37 * hash) + ATTRIBUTES_FIELD_NUMBER;
            hash = (53 * hash) + getAttributesList().hashCode();
          }
          hash = (37 * hash) + DROPPED_ATTRIBUTES_COUNT_FIELD_NUMBER;
          hash = (53 * hash) + getDroppedAttributesCount();
          hash = (37 * hash) + FLAGS_FIELD_NUMBER;
          hash = (53 * hash) + getFlags();
          hash = (29 * hash) + getUnknownFields().hashCode();
          memoizedHashCode = hash;
          return hash;
        }

        public static opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink.Link parseFrom(
            java.nio.ByteBuffer data)
            throws com.google.protobuf.InvalidProtocolBufferException {
          return PARSER.parseFrom(data);
        }
        public static opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink.Link parseFrom(
            java.nio.ByteBuffer data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          return PARSER.parseFrom(data, extensionRegistry);
        }
        public static opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink.Link parseFrom(
            com.google.protobuf.ByteString data)
            throws com.google.protobuf.InvalidProtocolBufferException {
          return PARSER.parseFrom(data);
        }
        public static opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink.Link parseFrom(
            com.google.protobuf.ByteString data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          return PARSER.parseFrom(data, extensionRegistry);
        }
        public static opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink.Link parseFrom(byte[] data)
            throws com.google.protobuf.InvalidProtocolBufferException {
          return PARSER.parseFrom(data);
        }
        public static opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink.Link parseFrom(
            byte[] data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          return PARSER.parseFrom(data, extensionRegistry);
        }
        public static opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink.Link parseFrom(java.io.InputStream input)
            throws java.io.IOException {
          return com.google.protobuf.GeneratedMessage
              .parseWithIOException(PARSER, input);
        }
        public static opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink.Link parseFrom(
            java.io.InputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          return com.google.protobuf.GeneratedMessage
              .parseWithIOException(PARSER, input, extensionRegistry);
        }

        public static opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink.Link parseDelimitedFrom(java.io.InputStream input)
            throws java.io.IOException {
          return com.google.protobuf.GeneratedMessage
              .parseDelimitedWithIOException(PARSER, input);
        }

        public static opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink.Link parseDelimitedFrom(
            java.io.InputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          return com.google.protobuf.GeneratedMessage
              .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
        }
        public static opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink.Link parseFrom(
            com.google.protobuf.CodedInputStream input)
            throws java.io.IOException {
          return com.google.protobuf.GeneratedMessage
              .parseWithIOException(PARSER, input);
        }
        public static opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink.Link parseFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          return com.google.protobuf.GeneratedMessage
              .parseWithIOException(PARSER, input, extensionRegistry);
        }

        @java.lang.Override
        public Builder newBuilderForType() { return newBuilder(); }
        public static Builder newBuilder() {
          return DEFAULT_INSTANCE.toBuilder();
        }
        public static Builder newBuilder(opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink.Link prototype) {
          return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
        }
        @java.lang.Override
        public Builder toBuilder() {
          return this == DEFAULT_INSTANCE
              ? new Builder() : new Builder().mergeFrom(this);
        }

        @java.lang.Override
        protected Builder newBuilderForType(
            com.google.protobuf.GeneratedMessage.BuilderParent parent) {
          Builder builder = new Builder(parent);
          return builder;
        }
        /**
         * <pre>
         * A pointer from the current span to another span in the same trace or in a
         * different trace. For example, this can be used in batching operations,
         * where a single batch handler processes multiple requests from different
         * traces or when the handler receives a request from a different project.
         * </pre>
         *
         * Protobuf type {@code opentelemetry.proto.mmap.v1.SpanEvent.AddLink.Link}
         */
        public static final class Builder extends
            com.google.protobuf.GeneratedMessage.Builder<Builder> implements
            // @@protoc_insertion_point(builder_implements:opentelemetry.proto.mmap.v1.SpanEvent.AddLink.Link)
            opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink.LinkOrBuilder {
          public static final com.google.protobuf.Descriptors.Descriptor
              getDescriptor() {
            return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_SpanEvent_AddLink_Link_descriptor;
          }

          @java.lang.Override
          protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
              internalGetFieldAccessorTable() {
            return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_SpanEvent_AddLink_Link_fieldAccessorTable
                .ensureFieldAccessorsInitialized(
                    opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink.Link.class, opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink.Link.Builder.class);
          }

          // Construct using opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink.Link.newBuilder()
          private Builder() {

          }

          private Builder(
              com.google.protobuf.GeneratedMessage.BuilderParent parent) {
            super(parent);

          }
          @java.lang.Override
          public Builder clear() {
            super.clear();
            bitField0_ = 0;
            traceId_ = com.google.protobuf.ByteString.EMPTY;
            spanId_ = com.google.protobuf.ByteString.EMPTY;
            traceState_ = "";
            if (attributesBuilder_ == null) {
              attributes_ = java.util.Collections.emptyList();
            } else {
              attributes_ = null;
              attributesBuilder_.clear();
            }
            bitField0_ = (bitField0_ & ~0x00000008);
            droppedAttributesCount_ = 0;
            flags_ = 0;
            return this;
          }

          @java.lang.Override
          public com.google.protobuf.Descriptors.Descriptor
              getDescriptorForType() {
            return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_SpanEvent_AddLink_Link_descriptor;
          }

          @java.lang.Override
          public opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink.Link getDefaultInstanceForType() {
            return opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink.Link.getDefaultInstance();
          }

          @java.lang.Override
          public opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink.Link build() {
            opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink.Link result = buildPartial();
            if (!result.isInitialized()) {
              throw newUninitializedMessageException(result);
            }
            return result;
          }

          @java.lang.Override
          public opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink.Link buildPartial() {
            opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink.Link result = new opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink.Link(this);
            buildPartialRepeatedFields(result);
            if (bitField0_ != 0) { buildPartial0(result); }
            onBuilt();
            return result;
          }

          private void buildPartialRepeatedFields(opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink.Link result) {
            if (attributesBuilder_ == null) {
              if (((bitField0_ & 0x00000008) != 0)) {
                attributes_ = java.util.Collections.unmodifiableList(attributes_);
                bitField0_ = (bitField0_ & ~0x00000008);
              }
              result.attributes_ = attributes_;
            } else {
              result.attributes_ = attributesBuilder_.build();
            }
          }

          private void buildPartial0(opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink.Link result) {
            int from_bitField0_ = bitField0_;
            if (((from_bitField0_ & 0x00000001) != 0)) {
              result.traceId_ = traceId_;
            }
            if (((from_bitField0_ & 0x00000002) != 0)) {
              result.spanId_ = spanId_;
            }
            if (((from_bitField0_ & 0x00000004) != 0)) {
              result.traceState_ = traceState_;
            }
            if (((from_bitField0_ & 0x00000010) != 0)) {
              result.droppedAttributesCount_ = droppedAttributesCount_;
            }
            if (((from_bitField0_ & 0x00000020) != 0)) {
              result.flags_ = flags_;
            }
          }

          @java.lang.Override
          public Builder mergeFrom(com.google.protobuf.Message other) {
            if (other instanceof opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink.Link) {
              return mergeFrom((opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink.Link)other);
            } else {
              super.mergeFrom(other);
              return this;
            }
          }

          public Builder mergeFrom(opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink.Link other) {
            if (other == opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink.Link.getDefaultInstance()) return this;
            if (!other.getTraceId().isEmpty()) {
              setTraceId(other.getTraceId());
            }
            if (!other.getSpanId().isEmpty()) {
              setSpanId(other.getSpanId());
            }
            if (!other.getTraceState().isEmpty()) {
              traceState_ = other.traceState_;
              bitField0_ |= 0x00000004;
              onChanged();
            }
            if (attributesBuilder_ == null) {
              if (!other.attributes_.isEmpty()) {
                if (attributes_.isEmpty()) {
                  attributes_ = other.attributes_;
                  bitField0_ = (bitField0_ & ~0x00000008);
                } else {
                  ensureAttributesIsMutable();
                  attributes_.addAll(other.attributes_);
                }
                onChanged();
              }
            } else {
              if (!other.attributes_.isEmpty()) {
                if (attributesBuilder_.isEmpty()) {
                  attributesBuilder_.dispose();
                  attributesBuilder_ = null;
                  attributes_ = other.attributes_;
                  bitField0_ = (bitField0_ & ~0x00000008);
                  attributesBuilder_ = 
                    com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                       internalGetAttributesFieldBuilder() : null;
                } else {
                  attributesBuilder_.addAllMessages(other.attributes_);
                }
              }
            }
            if (other.getDroppedAttributesCount() != 0) {
              setDroppedAttributesCount(other.getDroppedAttributesCount());
            }
            if (other.getFlags() != 0) {
              setFlags(other.getFlags());
            }
            this.mergeUnknownFields(other.getUnknownFields());
            onChanged();
            return this;
          }

          @java.lang.Override
          public final boolean isInitialized() {
            return true;
          }

          @java.lang.Override
          public Builder mergeFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws java.io.IOException {
            if (extensionRegistry == null) {
              throw new java.lang.NullPointerException();
            }
            try {
              boolean done = false;
              while (!done) {
                int tag = input.readTag();
                switch (tag) {
                  case 0:
                    done = true;
                    break;
                  case 10: {
                    traceId_ = input.readBytes();
                    bitField0_ |= 0x00000001;
                    break;
                  } // case 10
                  case 18: {
                    spanId_ = input.readBytes();
                    bitField0_ |= 0x00000002;
                    break;
                  } // case 18
                  case 26: {
                    traceState_ = input.readStringRequireUtf8();
                    bitField0_ |= 0x00000004;
                    break;
                  } // case 26
                  case 34: {
                    opentelemetry.proto.mmap.v1.Mmap.KeyValueRef m =
                        input.readMessage(
                            opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.parser(),
                            extensionRegistry);
                    if (attributesBuilder_ == null) {
                      ensureAttributesIsMutable();
                      attributes_.add(m);
                    } else {
                      attributesBuilder_.addMessage(m);
                    }
                    break;
                  } // case 34
                  case 40: {
                    droppedAttributesCount_ = input.readUInt32();
                    bitField0_ |= 0x00000010;
                    break;
                  } // case 40
                  case 53: {
                    flags_ = input.readFixed32();
                    bitField0_ |= 0x00000020;
                    break;
                  } // case 53
                  default: {
                    if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                      done = true; // was an endgroup tag
                    }
                    break;
                  } // default:
                } // switch (tag)
              } // while (!done)
            } catch (com.google.protobuf.InvalidProtocolBufferException e) {
              throw e.unwrapIOException();
            } finally {
              onChanged();
            } // finally
            return this;
          }
          private int bitField0_;

          private com.google.protobuf.ByteString traceId_ = com.google.protobuf.ByteString.EMPTY;
          /**
           * <pre>
           * A unique identifier of a trace that this linked span is part of. The ID is a
           * 16-byte array.
           * </pre>
           *
           * <code>bytes trace_id = 1;</code>
           * @return The traceId.
           */
          @java.lang.Override
          public com.google.protobuf.ByteString getTraceId() {
            return traceId_;
          }
          /**
           * <pre>
           * A unique identifier of a trace that this linked span is part of. The ID is a
           * 16-byte array.
           * </pre>
           *
           * <code>bytes trace_id = 1;</code>
           * @param value The traceId to set.
           * @return This builder for chaining.
           */
          public Builder setTraceId(com.google.protobuf.ByteString value) {
            if (value == null) { throw new NullPointerException(); }
            traceId_ = value;
            bitField0_ |= 0x00000001;
            onChanged();
            return this;
          }
          /**
           * <pre>
           * A unique identifier of a trace that this linked span is part of. The ID is a
           * 16-byte array.
           * </pre>
           *
           * <code>bytes trace_id = 1;</code>
           * @return This builder for chaining.
           */
          public Builder clearTraceId() {
            bitField0_ = (bitField0_ & ~0x00000001);
            traceId_ = getDefaultInstance().getTraceId();
            onChanged();
            return this;
          }

          private com.google.protobuf.ByteString spanId_ = com.google.protobuf.ByteString.EMPTY;
          /**
           * <pre>
           * A unique identifier for the linked span. The ID is an 8-byte array.
           * </pre>
           *
           * <code>bytes span_id = 2;</code>
           * @return The spanId.
           */
          @java.lang.Override
          public com.google.protobuf.ByteString getSpanId() {
            return spanId_;
          }
          /**
           * <pre>
           * A unique identifier for the linked span. The ID is an 8-byte array.
           * </pre>
           *
           * <code>bytes span_id = 2;</code>
           * @param value The spanId to set.
           * @return This builder for chaining.
           */
          public Builder setSpanId(com.google.protobuf.ByteString value) {
            if (value == null) { throw new NullPointerException(); }
            spanId_ = value;
            bitField0_ |= 0x00000002;
            onChanged();
            return this;
          }
          /**
           * <pre>
           * A unique identifier for the linked span. The ID is an 8-byte array.
           * </pre>
           *
           * <code>bytes span_id = 2;</code>
           * @return This builder for chaining.
           */
          public Builder clearSpanId() {
            bitField0_ = (bitField0_ & ~0x00000002);
            spanId_ = getDefaultInstance().getSpanId();
            onChanged();
            return this;
          }

          private java.lang.Object traceState_ = "";
          /**
           * <pre>
           * The trace_state associated with the link.
           * </pre>
           *
           * <code>string trace_state = 3;</code>
           * @return The traceState.
           */
          public java.lang.String getTraceState() {
            java.lang.Object ref = traceState_;
            if (!(ref instanceof java.lang.String)) {
              com.google.protobuf.ByteString bs =
                  (com.google.protobuf.ByteString) ref;
              java.lang.String s = bs.toStringUtf8();
              traceState_ = s;
              return s;
            } else {
              return (java.lang.String) ref;
            }
          }
          /**
           * <pre>
           * The trace_state associated with the link.
           * </pre>
           *
           * <code>string trace_state = 3;</code>
           * @return The bytes for traceState.
           */
          public com.google.protobuf.ByteString
              getTraceStateBytes() {
            java.lang.Object ref = traceState_;
            if (ref instanceof String) {
              com.google.protobuf.ByteString b = 
                  com.google.protobuf.ByteString.copyFromUtf8(
                      (java.lang.String) ref);
              traceState_ = b;
              return b;
            } else {
              return (com.google.protobuf.ByteString) ref;
            }
          }
          /**
           * <pre>
           * The trace_state associated with the link.
           * </pre>
           *
           * <code>string trace_state = 3;</code>
           * @param value The traceState to set.
           * @return This builder for chaining.
           */
          public Builder setTraceState(
              java.lang.String value) {
            if (value == null) { throw new NullPointerException(); }
            traceState_ = value;
            bitField0_ |= 0x00000004;
            onChanged();
            return this;
          }
          /**
           * <pre>
           * The trace_state associated with the link.
           * </pre>
           *
           * <code>string trace_state = 3;</code>
           * @return This builder for chaining.
           */
          public Builder clearTraceState() {
            traceState_ = getDefaultInstance().getTraceState();
            bitField0_ = (bitField0_ & ~0x00000004);
            onChanged();
            return this;
          }
          /**
           * <pre>
           * The trace_state associated with the link.
           * </pre>
           *
           * <code>string trace_state = 3;</code>
           * @param value The bytes for traceState to set.
           * @return This builder for chaining.
           */
          public Builder setTraceStateBytes(
              com.google.protobuf.ByteString value) {
            if (value == null) { throw new NullPointerException(); }
            checkByteStringIsUtf8(value);
            traceState_ = value;
            bitField0_ |= 0x00000004;
            onChanged();
            return this;
          }

          private java.util.List<opentelemetry.proto.mmap.v1.Mmap.KeyValueRef> attributes_ =
            java.util.Collections.emptyList();
          private void ensureAttributesIsMutable() {
            if (!((bitField0_ & 0x00000008) != 0)) {
              attributes_ = new java.util.ArrayList<opentelemetry.proto.mmap.v1.Mmap.KeyValueRef>(attributes_);
              bitField0_ |= 0x00000008;
             }
          }

          private com.google.protobuf.RepeatedFieldBuilder<
              opentelemetry.proto.mmap.v1.Mmap.KeyValueRef, opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.Builder, opentelemetry.proto.mmap.v1.Mmap.KeyValueRefOrBuilder> attributesBuilder_;

          /**
           * <pre>
           * A collection of attribute key/value pairs on the link.
           * Attribute keys MUST be unique (it is not allowed to have more than one
           * attribute with the same key).
           *
           * The attribute values SHOULD NOT contain empty values.
           * The attribute values SHOULD NOT contain bytes values.
           * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
           * double values.
           * The attribute values SHOULD NOT contain kvlist values.
           * The behavior of software that receives attributes containing such values can be unpredictable.
           * These restrictions can change in a minor release.
           * The restrictions take origin from the OpenTelemetry specification:
           * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
           * </pre>
           *
           * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 4;</code>
           */
          public java.util.List<opentelemetry.proto.mmap.v1.Mmap.KeyValueRef> getAttributesList() {
            if (attributesBuilder_ == null) {
              return java.util.Collections.unmodifiableList(attributes_);
            } else {
              return attributesBuilder_.getMessageList();
            }
          }
          /**
           * <pre>
           * A collection of attribute key/value pairs on the link.
           * Attribute keys MUST be unique (it is not allowed to have more than one
           * attribute with the same key).
           *
           * The attribute values SHOULD NOT contain empty values.
           * The attribute values SHOULD NOT contain bytes values.
           * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
           * double values.
           * The attribute values SHOULD NOT contain kvlist values.
           * The behavior of software that receives attributes containing such values can be unpredictable.
           * These restrictions can change in a minor release.
           * The restrictions take origin from the OpenTelemetry specification:
           * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
           * </pre>
           *
           * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 4;</code>
           */
          public int getAttributesCount() {
            if (attributesBuilder_ == null) {
              return attributes_.size();
            } else {
              return attributesBuilder_.getCount();
            }
          }
          /**
           * <pre>
           * A collection of attribute key/value pairs on the link.
           * Attribute keys MUST be unique (it is not allowed to have more than one
           * attribute with the same key).
           *
           * The attribute values SHOULD NOT contain empty values.
           * The attribute values SHOULD NOT contain bytes values.
           * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
           * double values.
           * The attribute values SHOULD NOT contain kvlist values.
           * The behavior of software that receives attributes containing such values can be unpredictable.
           * These restrictions can change in a minor release.
           * The restrictions take origin from the OpenTelemetry specification:
           * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
           * </pre>
           *
           * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 4;</code>
           */
          public opentelemetry.proto.mmap.v1.Mmap.KeyValueRef getAttributes(int index) {
            if (attributesBuilder_ == null) {
              return attributes_.get(index);
            } else {
              return attributesBuilder_.getMessage(index);
            }
          }
          /**
           * <pre>
           * A collection of attribute key/value pairs on the link.
           * Attribute keys MUST be unique (it is not allowed to have more than one
           * attribute with the same key).
           *
           * The attribute values SHOULD NOT contain empty values.
           * The attribute values SHOULD NOT contain bytes values.
           * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
           * double values.
           * The attribute values SHOULD NOT contain kvlist values.
           * The behavior of software that receives attributes containing such values can be unpredictable.
           * These restrictions can change in a minor release.
           * The restrictions take origin from the OpenTelemetry specification:
           * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
           * </pre>
           *
           * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 4;</code>
           */
          public Builder setAttributes(
              int index, opentelemetry.proto.mmap.v1.Mmap.KeyValueRef value) {
            if (attributesBuilder_ == null) {
              if (value == null) {
                throw new NullPointerException();
              }
              ensureAttributesIsMutable();
              attributes_.set(index, value);
              onChanged();
            } else {
              attributesBuilder_.setMessage(index, value);
            }
            return this;
          }
          /**
           * <pre>
           * A collection of attribute key/value pairs on the link.
           * Attribute keys MUST be unique (it is not allowed to have more than one
           * attribute with the same key).
           *
           * The attribute values SHOULD NOT contain empty values.
           * The attribute values SHOULD NOT contain bytes values.
           * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
           * double values.
           * The attribute values SHOULD NOT contain kvlist values.
           * The behavior of software that receives attributes containing such values can be unpredictable.
           * These restrictions can change in a minor release.
           * The restrictions take origin from the OpenTelemetry specification:
           * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
           * </pre>
           *
           * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 4;</code>
           */
          public Builder setAttributes(
              int index, opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.Builder builderForValue) {
            if (attributesBuilder_ == null) {
              ensureAttributesIsMutable();
              attributes_.set(index, builderForValue.build());
              onChanged();
            } else {
              attributesBuilder_.setMessage(index, builderForValue.build());
            }
            return this;
          }
          /**
           * <pre>
           * A collection of attribute key/value pairs on the link.
           * Attribute keys MUST be unique (it is not allowed to have more than one
           * attribute with the same key).
           *
           * The attribute values SHOULD NOT contain empty values.
           * The attribute values SHOULD NOT contain bytes values.
           * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
           * double values.
           * The attribute values SHOULD NOT contain kvlist values.
           * The behavior of software that receives attributes containing such values can be unpredictable.
           * These restrictions can change in a minor release.
           * The restrictions take origin from the OpenTelemetry specification:
           * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
           * </pre>
           *
           * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 4;</code>
           */
          public Builder addAttributes(opentelemetry.proto.mmap.v1.Mmap.KeyValueRef value) {
            if (attributesBuilder_ == null) {
              if (value == null) {
                throw new NullPointerException();
              }
              ensureAttributesIsMutable();
              attributes_.add(value);
              onChanged();
            } else {
              attributesBuilder_.addMessage(value);
            }
            return this;
          }
          /**
           * <pre>
           * A collection of attribute key/value pairs on the link.
           * Attribute keys MUST be unique (it is not allowed to have more than one
           * attribute with the same key).
           *
           * The attribute values SHOULD NOT contain empty values.
           * The attribute values SHOULD NOT contain bytes values.
           * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
           * double values.
           * The attribute values SHOULD NOT contain kvlist values.
           * The behavior of software that receives attributes containing such values can be unpredictable.
           * These restrictions can change in a minor release.
           * The restrictions take origin from the OpenTelemetry specification:
           * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
           * </pre>
           *
           * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 4;</code>
           */
          public Builder addAttributes(
              int index, opentelemetry.proto.mmap.v1.Mmap.KeyValueRef value) {
            if (attributesBuilder_ == null) {
              if (value == null) {
                throw new NullPointerException();
              }
              ensureAttributesIsMutable();
              attributes_.add(index, value);
              onChanged();
            } else {
              attributesBuilder_.addMessage(index, value);
            }
            return this;
          }
          /**
           * <pre>
           * A collection of attribute key/value pairs on the link.
           * Attribute keys MUST be unique (it is not allowed to have more than one
           * attribute with the same key).
           *
           * The attribute values SHOULD NOT contain empty values.
           * The attribute values SHOULD NOT contain bytes values.
           * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
           * double values.
           * The attribute values SHOULD NOT contain kvlist values.
           * The behavior of software that receives attributes containing such values can be unpredictable.
           * These restrictions can change in a minor release.
           * The restrictions take origin from the OpenTelemetry specification:
           * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
           * </pre>
           *
           * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 4;</code>
           */
          public Builder addAttributes(
              opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.Builder builderForValue) {
            if (attributesBuilder_ == null) {
              ensureAttributesIsMutable();
              attributes_.add(builderForValue.build());
              onChanged();
            } else {
              attributesBuilder_.addMessage(builderForValue.build());
            }
            return this;
          }
          /**
           * <pre>
           * A collection of attribute key/value pairs on the link.
           * Attribute keys MUST be unique (it is not allowed to have more than one
           * attribute with the same key).
           *
           * The attribute values SHOULD NOT contain empty values.
           * The attribute values SHOULD NOT contain bytes values.
           * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
           * double values.
           * The attribute values SHOULD NOT contain kvlist values.
           * The behavior of software that receives attributes containing such values can be unpredictable.
           * These restrictions can change in a minor release.
           * The restrictions take origin from the OpenTelemetry specification:
           * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
           * </pre>
           *
           * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 4;</code>
           */
          public Builder addAttributes(
              int index, opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.Builder builderForValue) {
            if (attributesBuilder_ == null) {
              ensureAttributesIsMutable();
              attributes_.add(index, builderForValue.build());
              onChanged();
            } else {
              attributesBuilder_.addMessage(index, builderForValue.build());
            }
            return this;
          }
          /**
           * <pre>
           * A collection of attribute key/value pairs on the link.
           * Attribute keys MUST be unique (it is not allowed to have more than one
           * attribute with the same key).
           *
           * The attribute values SHOULD NOT contain empty values.
           * The attribute values SHOULD NOT contain bytes values.
           * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
           * double values.
           * The attribute values SHOULD NOT contain kvlist values.
           * The behavior of software that receives attributes containing such values can be unpredictable.
           * These restrictions can change in a minor release.
           * The restrictions take origin from the OpenTelemetry specification:
           * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
           * </pre>
           *
           * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 4;</code>
           */
          public Builder addAllAttributes(
              java.lang.Iterable<? extends opentelemetry.proto.mmap.v1.Mmap.KeyValueRef> values) {
            if (attributesBuilder_ == null) {
              ensureAttributesIsMutable();
              com.google.protobuf.AbstractMessageLite.Builder.addAll(
                  values, attributes_);
              onChanged();
            } else {
              attributesBuilder_.addAllMessages(values);
            }
            return this;
          }
          /**
           * <pre>
           * A collection of attribute key/value pairs on the link.
           * Attribute keys MUST be unique (it is not allowed to have more than one
           * attribute with the same key).
           *
           * The attribute values SHOULD NOT contain empty values.
           * The attribute values SHOULD NOT contain bytes values.
           * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
           * double values.
           * The attribute values SHOULD NOT contain kvlist values.
           * The behavior of software that receives attributes containing such values can be unpredictable.
           * These restrictions can change in a minor release.
           * The restrictions take origin from the OpenTelemetry specification:
           * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
           * </pre>
           *
           * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 4;</code>
           */
          public Builder clearAttributes() {
            if (attributesBuilder_ == null) {
              attributes_ = java.util.Collections.emptyList();
              bitField0_ = (bitField0_ & ~0x00000008);
              onChanged();
            } else {
              attributesBuilder_.clear();
            }
            return this;
          }
          /**
           * <pre>
           * A collection of attribute key/value pairs on the link.
           * Attribute keys MUST be unique (it is not allowed to have more than one
           * attribute with the same key).
           *
           * The attribute values SHOULD NOT contain empty values.
           * The attribute values SHOULD NOT contain bytes values.
           * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
           * double values.
           * The attribute values SHOULD NOT contain kvlist values.
           * The behavior of software that receives attributes containing such values can be unpredictable.
           * These restrictions can change in a minor release.
           * The restrictions take origin from the OpenTelemetry specification:
           * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
           * </pre>
           *
           * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 4;</code>
           */
          public Builder removeAttributes(int index) {
            if (attributesBuilder_ == null) {
              ensureAttributesIsMutable();
              attributes_.remove(index);
              onChanged();
            } else {
              attributesBuilder_.remove(index);
            }
            return this;
          }
          /**
           * <pre>
           * A collection of attribute key/value pairs on the link.
           * Attribute keys MUST be unique (it is not allowed to have more than one
           * attribute with the same key).
           *
           * The attribute values SHOULD NOT contain empty values.
           * The attribute values SHOULD NOT contain bytes values.
           * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
           * double values.
           * The attribute values SHOULD NOT contain kvlist values.
           * The behavior of software that receives attributes containing such values can be unpredictable.
           * These restrictions can change in a minor release.
           * The restrictions take origin from the OpenTelemetry specification:
           * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
           * </pre>
           *
           * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 4;</code>
           */
          public opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.Builder getAttributesBuilder(
              int index) {
            return internalGetAttributesFieldBuilder().getBuilder(index);
          }
          /**
           * <pre>
           * A collection of attribute key/value pairs on the link.
           * Attribute keys MUST be unique (it is not allowed to have more than one
           * attribute with the same key).
           *
           * The attribute values SHOULD NOT contain empty values.
           * The attribute values SHOULD NOT contain bytes values.
           * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
           * double values.
           * The attribute values SHOULD NOT contain kvlist values.
           * The behavior of software that receives attributes containing such values can be unpredictable.
           * These restrictions can change in a minor release.
           * The restrictions take origin from the OpenTelemetry specification:
           * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
           * </pre>
           *
           * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 4;</code>
           */
          public opentelemetry.proto.mmap.v1.Mmap.KeyValueRefOrBuilder getAttributesOrBuilder(
              int index) {
            if (attributesBuilder_ == null) {
              return attributes_.get(index);  } else {
              return attributesBuilder_.getMessageOrBuilder(index);
            }
          }
          /**
           * <pre>
           * A collection of attribute key/value pairs on the link.
           * Attribute keys MUST be unique (it is not allowed to have more than one
           * attribute with the same key).
           *
           * The attribute values SHOULD NOT contain empty values.
           * The attribute values SHOULD NOT contain bytes values.
           * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
           * double values.
           * The attribute values SHOULD NOT contain kvlist values.
           * The behavior of software that receives attributes containing such values can be unpredictable.
           * These restrictions can change in a minor release.
           * The restrictions take origin from the OpenTelemetry specification:
           * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
           * </pre>
           *
           * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 4;</code>
           */
          public java.util.List<? extends opentelemetry.proto.mmap.v1.Mmap.KeyValueRefOrBuilder> 
               getAttributesOrBuilderList() {
            if (attributesBuilder_ != null) {
              return attributesBuilder_.getMessageOrBuilderList();
            } else {
              return java.util.Collections.unmodifiableList(attributes_);
            }
          }
          /**
           * <pre>
           * A collection of attribute key/value pairs on the link.
           * Attribute keys MUST be unique (it is not allowed to have more than one
           * attribute with the same key).
           *
           * The attribute values SHOULD NOT contain empty values.
           * The attribute values SHOULD NOT contain bytes values.
           * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
           * double values.
           * The attribute values SHOULD NOT contain kvlist values.
           * The behavior of software that receives attributes containing such values can be unpredictable.
           * These restrictions can change in a minor release.
           * The restrictions take origin from the OpenTelemetry specification:
           * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
           * </pre>
           *
           * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 4;</code>
           */
          public opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.Builder addAttributesBuilder() {
            return internalGetAttributesFieldBuilder().addBuilder(
                opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.getDefaultInstance());
          }
          /**
           * <pre>
           * A collection of attribute key/value pairs on the link.
           * Attribute keys MUST be unique (it is not allowed to have more than one
           * attribute with the same key).
           *
           * The attribute values SHOULD NOT contain empty values.
           * The attribute values SHOULD NOT contain bytes values.
           * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
           * double values.
           * The attribute values SHOULD NOT contain kvlist values.
           * The behavior of software that receives attributes containing such values can be unpredictable.
           * These restrictions can change in a minor release.
           * The restrictions take origin from the OpenTelemetry specification:
           * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
           * </pre>
           *
           * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 4;</code>
           */
          public opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.Builder addAttributesBuilder(
              int index) {
            return internalGetAttributesFieldBuilder().addBuilder(
                index, opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.getDefaultInstance());
          }
          /**
           * <pre>
           * A collection of attribute key/value pairs on the link.
           * Attribute keys MUST be unique (it is not allowed to have more than one
           * attribute with the same key).
           *
           * The attribute values SHOULD NOT contain empty values.
           * The attribute values SHOULD NOT contain bytes values.
           * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
           * double values.
           * The attribute values SHOULD NOT contain kvlist values.
           * The behavior of software that receives attributes containing such values can be unpredictable.
           * These restrictions can change in a minor release.
           * The restrictions take origin from the OpenTelemetry specification:
           * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
           * </pre>
           *
           * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 4;</code>
           */
          public java.util.List<opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.Builder> 
               getAttributesBuilderList() {
            return internalGetAttributesFieldBuilder().getBuilderList();
          }
          private com.google.protobuf.RepeatedFieldBuilder<
              opentelemetry.proto.mmap.v1.Mmap.KeyValueRef, opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.Builder, opentelemetry.proto.mmap.v1.Mmap.KeyValueRefOrBuilder> 
              internalGetAttributesFieldBuilder() {
            if (attributesBuilder_ == null) {
              attributesBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
                  opentelemetry.proto.mmap.v1.Mmap.KeyValueRef, opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.Builder, opentelemetry.proto.mmap.v1.Mmap.KeyValueRefOrBuilder>(
                      attributes_,
                      ((bitField0_ & 0x00000008) != 0),
                      getParentForChildren(),
                      isClean());
              attributes_ = null;
            }
            return attributesBuilder_;
          }

          private int droppedAttributesCount_ ;
          /**
           * <pre>
           * The number of dropped attributes. If the value is 0,
           * then no attributes were dropped.
           * </pre>
           *
           * <code>uint32 dropped_attributes_count = 5;</code>
           * @return The droppedAttributesCount.
           */
          @java.lang.Override
          public int getDroppedAttributesCount() {
            return droppedAttributesCount_;
          }
          /**
           * <pre>
           * The number of dropped attributes. If the value is 0,
           * then no attributes were dropped.
           * </pre>
           *
           * <code>uint32 dropped_attributes_count = 5;</code>
           * @param value The droppedAttributesCount to set.
           * @return This builder for chaining.
           */
          public Builder setDroppedAttributesCount(int value) {

            droppedAttributesCount_ = value;
            bitField0_ |= 0x00000010;
            onChanged();
            return this;
          }
          /**
           * <pre>
           * The number of dropped attributes. If the value is 0,
           * then no attributes were dropped.
           * </pre>
           *
           * <code>uint32 dropped_attributes_count = 5;</code>
           * @return This builder for chaining.
           */
          public Builder clearDroppedAttributesCount() {
            bitField0_ = (bitField0_ & ~0x00000010);
            droppedAttributesCount_ = 0;
            onChanged();
            return this;
          }

          private int flags_ ;
          /**
           * <pre>
           * Flags, a bit field.
           *
           * Bits 0-7 (8 least significant bits) are the trace flags as defined in W3C Trace
           * Context specification. To read the 8-bit W3C trace flag, use
           * `flags &amp; SPAN_FLAGS_TRACE_FLAGS_MASK`.
           *
           * See https://www.w3.org/TR/trace-context-2/#trace-flags for the flag definitions.
           *
           * Bits 8 and 9 represent the 3 states of whether the link is remote.
           * The states are (unknown, is not remote, is remote).
           * To read whether the value is known, use `(flags &amp; SPAN_FLAGS_CONTEXT_HAS_IS_REMOTE_MASK) != 0`.
           * To read whether the link is remote, use `(flags &amp; SPAN_FLAGS_CONTEXT_IS_REMOTE_MASK) != 0`.
           *
           * Readers MUST NOT assume that bits 10-31 (22 most significant bits) will be zero.
           * When creating new spans, bits 10-31 (most-significant 22-bits) MUST be zero.
           *
           * [Optional].
           * </pre>
           *
           * <code>fixed32 flags = 6;</code>
           * @return The flags.
           */
          @java.lang.Override
          public int getFlags() {
            return flags_;
          }
          /**
           * <pre>
           * Flags, a bit field.
           *
           * Bits 0-7 (8 least significant bits) are the trace flags as defined in W3C Trace
           * Context specification. To read the 8-bit W3C trace flag, use
           * `flags &amp; SPAN_FLAGS_TRACE_FLAGS_MASK`.
           *
           * See https://www.w3.org/TR/trace-context-2/#trace-flags for the flag definitions.
           *
           * Bits 8 and 9 represent the 3 states of whether the link is remote.
           * The states are (unknown, is not remote, is remote).
           * To read whether the value is known, use `(flags &amp; SPAN_FLAGS_CONTEXT_HAS_IS_REMOTE_MASK) != 0`.
           * To read whether the link is remote, use `(flags &amp; SPAN_FLAGS_CONTEXT_IS_REMOTE_MASK) != 0`.
           *
           * Readers MUST NOT assume that bits 10-31 (22 most significant bits) will be zero.
           * When creating new spans, bits 10-31 (most-significant 22-bits) MUST be zero.
           *
           * [Optional].
           * </pre>
           *
           * <code>fixed32 flags = 6;</code>
           * @param value The flags to set.
           * @return This builder for chaining.
           */
          public Builder setFlags(int value) {

            flags_ = value;
            bitField0_ |= 0x00000020;
            onChanged();
            return this;
          }
          /**
           * <pre>
           * Flags, a bit field.
           *
           * Bits 0-7 (8 least significant bits) are the trace flags as defined in W3C Trace
           * Context specification. To read the 8-bit W3C trace flag, use
           * `flags &amp; SPAN_FLAGS_TRACE_FLAGS_MASK`.
           *
           * See https://www.w3.org/TR/trace-context-2/#trace-flags for the flag definitions.
           *
           * Bits 8 and 9 represent the 3 states of whether the link is remote.
           * The states are (unknown, is not remote, is remote).
           * To read whether the value is known, use `(flags &amp; SPAN_FLAGS_CONTEXT_HAS_IS_REMOTE_MASK) != 0`.
           * To read whether the link is remote, use `(flags &amp; SPAN_FLAGS_CONTEXT_IS_REMOTE_MASK) != 0`.
           *
           * Readers MUST NOT assume that bits 10-31 (22 most significant bits) will be zero.
           * When creating new spans, bits 10-31 (most-significant 22-bits) MUST be zero.
           *
           * [Optional].
           * </pre>
           *
           * <code>fixed32 flags = 6;</code>
           * @return This builder for chaining.
           */
          public Builder clearFlags() {
            bitField0_ = (bitField0_ & ~0x00000020);
            flags_ = 0;
            onChanged();
            return this;
          }

          // @@protoc_insertion_point(builder_scope:opentelemetry.proto.mmap.v1.SpanEvent.AddLink.Link)
        }

        // @@protoc_insertion_point(class_scope:opentelemetry.proto.mmap.v1.SpanEvent.AddLink.Link)
        private static final opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink.Link DEFAULT_INSTANCE;
        static {
          DEFAULT_INSTANCE = new opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink.Link();
        }

        public static opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink.Link getDefaultInstance() {
          return DEFAULT_INSTANCE;
        }

        private static final com.google.protobuf.Parser<Link>
            PARSER = new com.google.protobuf.AbstractParser<Link>() {
          @java.lang.Override
          public Link parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            Builder builder = newBuilder();
            try {
              builder.mergeFrom(input, extensionRegistry);
            } catch (com.google.protobuf.InvalidProtocolBufferException e) {
              throw e.setUnfinishedMessage(builder.buildPartial());
            } catch (com.google.protobuf.UninitializedMessageException e) {
              throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
            } catch (java.io.IOException e) {
              throw new com.google.protobuf.InvalidProtocolBufferException(e)
                  .setUnfinishedMessage(builder.buildPartial());
            }
            return builder.buildPartial();
          }
        };

        public static com.google.protobuf.Parser<Link> parser() {
          return PARSER;
        }

        @java.lang.Override
        public com.google.protobuf.Parser<Link> getParserForType() {
          return PARSER;
        }

        @java.lang.Override
        public opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink.Link getDefaultInstanceForType() {
          return DEFAULT_INSTANCE;
        }

      }

      public static final int LINKS_FIELD_NUMBER = 13;
      @SuppressWarnings("serial")
      private java.util.List<opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink.Link> links_;
      /**
       * <pre>
       * A collection of Links, which are references from this span to a span
       * in the same or different trace.
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.SpanEvent.AddLink.Link links = 13;</code>
       */
      @java.lang.Override
      public java.util.List<opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink.Link> getLinksList() {
        return links_;
      }
      /**
       * <pre>
       * A collection of Links, which are references from this span to a span
       * in the same or different trace.
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.SpanEvent.AddLink.Link links = 13;</code>
       */
      @java.lang.Override
      public java.util.List<? extends opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink.LinkOrBuilder> 
          getLinksOrBuilderList() {
        return links_;
      }
      /**
       * <pre>
       * A collection of Links, which are references from this span to a span
       * in the same or different trace.
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.SpanEvent.AddLink.Link links = 13;</code>
       */
      @java.lang.Override
      public int getLinksCount() {
        return links_.size();
      }
      /**
       * <pre>
       * A collection of Links, which are references from this span to a span
       * in the same or different trace.
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.SpanEvent.AddLink.Link links = 13;</code>
       */
      @java.lang.Override
      public opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink.Link getLinks(int index) {
        return links_.get(index);
      }
      /**
       * <pre>
       * A collection of Links, which are references from this span to a span
       * in the same or different trace.
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.SpanEvent.AddLink.Link links = 13;</code>
       */
      @java.lang.Override
      public opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink.LinkOrBuilder getLinksOrBuilder(
          int index) {
        return links_.get(index);
      }

      private byte memoizedIsInitialized = -1;
      @java.lang.Override
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        memoizedIsInitialized = 1;
        return true;
      }

      @java.lang.Override
      public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        for (int i = 0; i < links_.size(); i++) {
          output.writeMessage(13, links_.get(i));
        }
        getUnknownFields().writeTo(output);
      }

      @java.lang.Override
      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        for (int i = 0; i < links_.size(); i++) {
          size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(13, links_.get(i));
        }
        size += getUnknownFields().getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink)) {
          return super.equals(obj);
        }
        opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink other = (opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink) obj;

        if (!getLinksList()
            .equals(other.getLinksList())) return false;
        if (!getUnknownFields().equals(other.getUnknownFields())) return false;
        return true;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        if (getLinksCount() > 0) {
          hash = (37 * hash) + LINKS_FIELD_NUMBER;
          hash = (53 * hash) + getLinksList().hashCode();
        }
        hash = (29 * hash) + getUnknownFields().hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input);
      }
      public static opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      public static opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseDelimitedWithIOException(PARSER, input);
      }

      public static opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input);
      }
      public static opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      @java.lang.Override
      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      @java.lang.Override
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * Protobuf type {@code opentelemetry.proto.mmap.v1.SpanEvent.AddLink}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessage.Builder<Builder> implements
          // @@protoc_insertion_point(builder_implements:opentelemetry.proto.mmap.v1.SpanEvent.AddLink)
          opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLinkOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_SpanEvent_AddLink_descriptor;
        }

        @java.lang.Override
        protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_SpanEvent_AddLink_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink.class, opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink.Builder.class);
        }

        // Construct using opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink.newBuilder()
        private Builder() {

        }

        private Builder(
            com.google.protobuf.GeneratedMessage.BuilderParent parent) {
          super(parent);

        }
        @java.lang.Override
        public Builder clear() {
          super.clear();
          bitField0_ = 0;
          if (linksBuilder_ == null) {
            links_ = java.util.Collections.emptyList();
          } else {
            links_ = null;
            linksBuilder_.clear();
          }
          bitField0_ = (bitField0_ & ~0x00000001);
          return this;
        }

        @java.lang.Override
        public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_SpanEvent_AddLink_descriptor;
        }

        @java.lang.Override
        public opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink getDefaultInstanceForType() {
          return opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink.getDefaultInstance();
        }

        @java.lang.Override
        public opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink build() {
          opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        @java.lang.Override
        public opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink buildPartial() {
          opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink result = new opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink(this);
          buildPartialRepeatedFields(result);
          if (bitField0_ != 0) { buildPartial0(result); }
          onBuilt();
          return result;
        }

        private void buildPartialRepeatedFields(opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink result) {
          if (linksBuilder_ == null) {
            if (((bitField0_ & 0x00000001) != 0)) {
              links_ = java.util.Collections.unmodifiableList(links_);
              bitField0_ = (bitField0_ & ~0x00000001);
            }
            result.links_ = links_;
          } else {
            result.links_ = linksBuilder_.build();
          }
        }

        private void buildPartial0(opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink result) {
          int from_bitField0_ = bitField0_;
        }

        @java.lang.Override
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other instanceof opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink) {
            return mergeFrom((opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink other) {
          if (other == opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink.getDefaultInstance()) return this;
          if (linksBuilder_ == null) {
            if (!other.links_.isEmpty()) {
              if (links_.isEmpty()) {
                links_ = other.links_;
                bitField0_ = (bitField0_ & ~0x00000001);
              } else {
                ensureLinksIsMutable();
                links_.addAll(other.links_);
              }
              onChanged();
            }
          } else {
            if (!other.links_.isEmpty()) {
              if (linksBuilder_.isEmpty()) {
                linksBuilder_.dispose();
                linksBuilder_ = null;
                links_ = other.links_;
                bitField0_ = (bitField0_ & ~0x00000001);
                linksBuilder_ = 
                  com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                     internalGetLinksFieldBuilder() : null;
              } else {
                linksBuilder_.addAllMessages(other.links_);
              }
            }
          }
          this.mergeUnknownFields(other.getUnknownFields());
          onChanged();
          return this;
        }

        @java.lang.Override
        public final boolean isInitialized() {
          return true;
        }

        @java.lang.Override
        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          if (extensionRegistry == null) {
            throw new java.lang.NullPointerException();
          }
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                case 106: {
                  opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink.Link m =
                      input.readMessage(
                          opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink.Link.parser(),
                          extensionRegistry);
                  if (linksBuilder_ == null) {
                    ensureLinksIsMutable();
                    links_.add(m);
                  } else {
                    linksBuilder_.addMessage(m);
                  }
                  break;
                } // case 106
                default: {
                  if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                    done = true; // was an endgroup tag
                  }
                  break;
                } // default:
              } // switch (tag)
            } // while (!done)
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.unwrapIOException();
          } finally {
            onChanged();
          } // finally
          return this;
        }
        private int bitField0_;

        private java.util.List<opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink.Link> links_ =
          java.util.Collections.emptyList();
        private void ensureLinksIsMutable() {
          if (!((bitField0_ & 0x00000001) != 0)) {
            links_ = new java.util.ArrayList<opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink.Link>(links_);
            bitField0_ |= 0x00000001;
           }
        }

        private com.google.protobuf.RepeatedFieldBuilder<
            opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink.Link, opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink.Link.Builder, opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink.LinkOrBuilder> linksBuilder_;

        /**
         * <pre>
         * A collection of Links, which are references from this span to a span
         * in the same or different trace.
         * </pre>
         *
         * <code>repeated .opentelemetry.proto.mmap.v1.SpanEvent.AddLink.Link links = 13;</code>
         */
        public java.util.List<opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink.Link> getLinksList() {
          if (linksBuilder_ == null) {
            return java.util.Collections.unmodifiableList(links_);
          } else {
            return linksBuilder_.getMessageList();
          }
        }
        /**
         * <pre>
         * A collection of Links, which are references from this span to a span
         * in the same or different trace.
         * </pre>
         *
         * <code>repeated .opentelemetry.proto.mmap.v1.SpanEvent.AddLink.Link links = 13;</code>
         */
        public int getLinksCount() {
          if (linksBuilder_ == null) {
            return links_.size();
          } else {
            return linksBuilder_.getCount();
          }
        }
        /**
         * <pre>
         * A collection of Links, which are references from this span to a span
         * in the same or different trace.
         * </pre>
         *
         * <code>repeated .opentelemetry.proto.mmap.v1.SpanEvent.AddLink.Link links = 13;</code>
         */
        public opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink.Link getLinks(int index) {
          if (linksBuilder_ == null) {
            return links_.get(index);
          } else {
            return linksBuilder_.getMessage(index);
          }
        }
        /**
         * <pre>
         * A collection of Links, which are references from this span to a span
         * in the same or different trace.
         * </pre>
         *
         * <code>repeated .opentelemetry.proto.mmap.v1.SpanEvent.AddLink.Link links = 13;</code>
         */
        public Builder setLinks(
            int index, opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink.Link value) {
          if (linksBuilder_ == null) {
            if (value == null) {
              throw new NullPointerException();
            }
            ensureLinksIsMutable();
            links_.set(index, value);
            onChanged();
          } else {
            linksBuilder_.setMessage(index, value);
          }
          return this;
        }
        /**
         * <pre>
         * A collection of Links, which are references from this span to a span
         * in the same or different trace.
         * </pre>
         *
         * <code>repeated .opentelemetry.proto.mmap.v1.SpanEvent.AddLink.Link links = 13;</code>
         */
        public Builder setLinks(
            int index, opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink.Link.Builder builderForValue) {
          if (linksBuilder_ == null) {
            ensureLinksIsMutable();
            links_.set(index, builderForValue.build());
            onChanged();
          } else {
            linksBuilder_.setMessage(index, builderForValue.build());
          }
          return this;
        }
        /**
         * <pre>
         * A collection of Links, which are references from this span to a span
         * in the same or different trace.
         * </pre>
         *
         * <code>repeated .opentelemetry.proto.mmap.v1.SpanEvent.AddLink.Link links = 13;</code>
         */
        public Builder addLinks(opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink.Link value) {
          if (linksBuilder_ == null) {
            if (value == null) {
              throw new NullPointerException();
            }
            ensureLinksIsMutable();
            links_.add(value);
            onChanged();
          } else {
            linksBuilder_.addMessage(value);
          }
          return this;
        }
        /**
         * <pre>
         * A collection of Links, which are references from this span to a span
         * in the same or different trace.
         * </pre>
         *
         * <code>repeated .opentelemetry.proto.mmap.v1.SpanEvent.AddLink.Link links = 13;</code>
         */
        public Builder addLinks(
            int index, opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink.Link value) {
          if (linksBuilder_ == null) {
            if (value == null) {
              throw new NullPointerException();
            }
            ensureLinksIsMutable();
            links_.add(index, value);
            onChanged();
          } else {
            linksBuilder_.addMessage(index, value);
          }
          return this;
        }
        /**
         * <pre>
         * A collection of Links, which are references from this span to a span
         * in the same or different trace.
         * </pre>
         *
         * <code>repeated .opentelemetry.proto.mmap.v1.SpanEvent.AddLink.Link links = 13;</code>
         */
        public Builder addLinks(
            opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink.Link.Builder builderForValue) {
          if (linksBuilder_ == null) {
            ensureLinksIsMutable();
            links_.add(builderForValue.build());
            onChanged();
          } else {
            linksBuilder_.addMessage(builderForValue.build());
          }
          return this;
        }
        /**
         * <pre>
         * A collection of Links, which are references from this span to a span
         * in the same or different trace.
         * </pre>
         *
         * <code>repeated .opentelemetry.proto.mmap.v1.SpanEvent.AddLink.Link links = 13;</code>
         */
        public Builder addLinks(
            int index, opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink.Link.Builder builderForValue) {
          if (linksBuilder_ == null) {
            ensureLinksIsMutable();
            links_.add(index, builderForValue.build());
            onChanged();
          } else {
            linksBuilder_.addMessage(index, builderForValue.build());
          }
          return this;
        }
        /**
         * <pre>
         * A collection of Links, which are references from this span to a span
         * in the same or different trace.
         * </pre>
         *
         * <code>repeated .opentelemetry.proto.mmap.v1.SpanEvent.AddLink.Link links = 13;</code>
         */
        public Builder addAllLinks(
            java.lang.Iterable<? extends opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink.Link> values) {
          if (linksBuilder_ == null) {
            ensureLinksIsMutable();
            com.google.protobuf.AbstractMessageLite.Builder.addAll(
                values, links_);
            onChanged();
          } else {
            linksBuilder_.addAllMessages(values);
          }
          return this;
        }
        /**
         * <pre>
         * A collection of Links, which are references from this span to a span
         * in the same or different trace.
         * </pre>
         *
         * <code>repeated .opentelemetry.proto.mmap.v1.SpanEvent.AddLink.Link links = 13;</code>
         */
        public Builder clearLinks() {
          if (linksBuilder_ == null) {
            links_ = java.util.Collections.emptyList();
            bitField0_ = (bitField0_ & ~0x00000001);
            onChanged();
          } else {
            linksBuilder_.clear();
          }
          return this;
        }
        /**
         * <pre>
         * A collection of Links, which are references from this span to a span
         * in the same or different trace.
         * </pre>
         *
         * <code>repeated .opentelemetry.proto.mmap.v1.SpanEvent.AddLink.Link links = 13;</code>
         */
        public Builder removeLinks(int index) {
          if (linksBuilder_ == null) {
            ensureLinksIsMutable();
            links_.remove(index);
            onChanged();
          } else {
            linksBuilder_.remove(index);
          }
          return this;
        }
        /**
         * <pre>
         * A collection of Links, which are references from this span to a span
         * in the same or different trace.
         * </pre>
         *
         * <code>repeated .opentelemetry.proto.mmap.v1.SpanEvent.AddLink.Link links = 13;</code>
         */
        public opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink.Link.Builder getLinksBuilder(
            int index) {
          return internalGetLinksFieldBuilder().getBuilder(index);
        }
        /**
         * <pre>
         * A collection of Links, which are references from this span to a span
         * in the same or different trace.
         * </pre>
         *
         * <code>repeated .opentelemetry.proto.mmap.v1.SpanEvent.AddLink.Link links = 13;</code>
         */
        public opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink.LinkOrBuilder getLinksOrBuilder(
            int index) {
          if (linksBuilder_ == null) {
            return links_.get(index);  } else {
            return linksBuilder_.getMessageOrBuilder(index);
          }
        }
        /**
         * <pre>
         * A collection of Links, which are references from this span to a span
         * in the same or different trace.
         * </pre>
         *
         * <code>repeated .opentelemetry.proto.mmap.v1.SpanEvent.AddLink.Link links = 13;</code>
         */
        public java.util.List<? extends opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink.LinkOrBuilder> 
             getLinksOrBuilderList() {
          if (linksBuilder_ != null) {
            return linksBuilder_.getMessageOrBuilderList();
          } else {
            return java.util.Collections.unmodifiableList(links_);
          }
        }
        /**
         * <pre>
         * A collection of Links, which are references from this span to a span
         * in the same or different trace.
         * </pre>
         *
         * <code>repeated .opentelemetry.proto.mmap.v1.SpanEvent.AddLink.Link links = 13;</code>
         */
        public opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink.Link.Builder addLinksBuilder() {
          return internalGetLinksFieldBuilder().addBuilder(
              opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink.Link.getDefaultInstance());
        }
        /**
         * <pre>
         * A collection of Links, which are references from this span to a span
         * in the same or different trace.
         * </pre>
         *
         * <code>repeated .opentelemetry.proto.mmap.v1.SpanEvent.AddLink.Link links = 13;</code>
         */
        public opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink.Link.Builder addLinksBuilder(
            int index) {
          return internalGetLinksFieldBuilder().addBuilder(
              index, opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink.Link.getDefaultInstance());
        }
        /**
         * <pre>
         * A collection of Links, which are references from this span to a span
         * in the same or different trace.
         * </pre>
         *
         * <code>repeated .opentelemetry.proto.mmap.v1.SpanEvent.AddLink.Link links = 13;</code>
         */
        public java.util.List<opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink.Link.Builder> 
             getLinksBuilderList() {
          return internalGetLinksFieldBuilder().getBuilderList();
        }
        private com.google.protobuf.RepeatedFieldBuilder<
            opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink.Link, opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink.Link.Builder, opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink.LinkOrBuilder> 
            internalGetLinksFieldBuilder() {
          if (linksBuilder_ == null) {
            linksBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
                opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink.Link, opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink.Link.Builder, opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink.LinkOrBuilder>(
                    links_,
                    ((bitField0_ & 0x00000001) != 0),
                    getParentForChildren(),
                    isClean());
            links_ = null;
          }
          return linksBuilder_;
        }

        // @@protoc_insertion_point(builder_scope:opentelemetry.proto.mmap.v1.SpanEvent.AddLink)
      }

      // @@protoc_insertion_point(class_scope:opentelemetry.proto.mmap.v1.SpanEvent.AddLink)
      private static final opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink();
      }

      public static opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static final com.google.protobuf.Parser<AddLink>
          PARSER = new com.google.protobuf.AbstractParser<AddLink>() {
        @java.lang.Override
        public AddLink parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          Builder builder = newBuilder();
          try {
            builder.mergeFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.setUnfinishedMessage(builder.buildPartial());
          } catch (com.google.protobuf.UninitializedMessageException e) {
            throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
          } catch (java.io.IOException e) {
            throw new com.google.protobuf.InvalidProtocolBufferException(e)
                .setUnfinishedMessage(builder.buildPartial());
          }
          return builder.buildPartial();
        }
      };

      public static com.google.protobuf.Parser<AddLink> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<AddLink> getParserForType() {
        return PARSER;
      }

      @java.lang.Override
      public opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    private int eventCase_ = 0;
    @SuppressWarnings("serial")
    private java.lang.Object event_;
    public enum EventCase
        implements com.google.protobuf.Internal.EnumLite,
            com.google.protobuf.AbstractMessage.InternalOneOfEnum {
      START(11),
      END(12),
      NAME(13),
      ATTRIBUTES(14),
      LINK(15),
      EVENT_NOT_SET(0);
      private final int value;
      private EventCase(int value) {
        this.value = value;
      }
      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static EventCase valueOf(int value) {
        return forNumber(value);
      }

      public static EventCase forNumber(int value) {
        switch (value) {
          case 11: return START;
          case 12: return END;
          case 13: return NAME;
          case 14: return ATTRIBUTES;
          case 15: return LINK;
          case 0: return EVENT_NOT_SET;
          default: return null;
        }
      }
      public int getNumber() {
        return this.value;
      }
    };

    public EventCase
    getEventCase() {
      return EventCase.forNumber(
          eventCase_);
    }

    public static final int SCOPE_REF_FIELD_NUMBER = 20;
    private long scopeRef_ = 0L;
    /**
     * <pre>
     * InsturmentationScope from which this was recorded.
     * </pre>
     *
     * <code>int64 scope_ref = 20;</code>
     * @return The scopeRef.
     */
    @java.lang.Override
    public long getScopeRef() {
      return scopeRef_;
    }

    public static final int TRACE_ID_FIELD_NUMBER = 1;
    private com.google.protobuf.ByteString traceId_ = com.google.protobuf.ByteString.EMPTY;
    /**
     * <pre>
     * A unique identifier for a trace. All spans from the same trace share
     * the same `trace_id`. The ID is a 16-byte array. An ID with all zeroes OR
     * of length other than 16 bytes is considered invalid (empty string in OTLP/JSON
     * is zero-length and thus is also invalid).
     *
     * This field is required.
     * </pre>
     *
     * <code>bytes trace_id = 1;</code>
     * @return The traceId.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getTraceId() {
      return traceId_;
    }

    public static final int SPAN_ID_FIELD_NUMBER = 2;
    private com.google.protobuf.ByteString spanId_ = com.google.protobuf.ByteString.EMPTY;
    /**
     * <pre>
     * A unique identifier for a span within a trace, assigned when the span
     * is created. The ID is an 8-byte array. An ID with all zeroes OR of length
     * other than 8 bytes is considered invalid (empty string in OTLP/JSON
     * is zero-length and thus is also invalid).
     *
     * This field is required.
     * </pre>
     *
     * <code>bytes span_id = 2;</code>
     * @return The spanId.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getSpanId() {
      return spanId_;
    }

    public static final int START_FIELD_NUMBER = 11;
    /**
     * <code>.opentelemetry.proto.mmap.v1.SpanEvent.StartSpan start = 11;</code>
     * @return Whether the start field is set.
     */
    @java.lang.Override
    public boolean hasStart() {
      return eventCase_ == 11;
    }
    /**
     * <code>.opentelemetry.proto.mmap.v1.SpanEvent.StartSpan start = 11;</code>
     * @return The start.
     */
    @java.lang.Override
    public opentelemetry.proto.mmap.v1.Mmap.SpanEvent.StartSpan getStart() {
      if (eventCase_ == 11) {
         return (opentelemetry.proto.mmap.v1.Mmap.SpanEvent.StartSpan) event_;
      }
      return opentelemetry.proto.mmap.v1.Mmap.SpanEvent.StartSpan.getDefaultInstance();
    }
    /**
     * <code>.opentelemetry.proto.mmap.v1.SpanEvent.StartSpan start = 11;</code>
     */
    @java.lang.Override
    public opentelemetry.proto.mmap.v1.Mmap.SpanEvent.StartSpanOrBuilder getStartOrBuilder() {
      if (eventCase_ == 11) {
         return (opentelemetry.proto.mmap.v1.Mmap.SpanEvent.StartSpan) event_;
      }
      return opentelemetry.proto.mmap.v1.Mmap.SpanEvent.StartSpan.getDefaultInstance();
    }

    public static final int END_FIELD_NUMBER = 12;
    /**
     * <code>.opentelemetry.proto.mmap.v1.SpanEvent.EndSpan end = 12;</code>
     * @return Whether the end field is set.
     */
    @java.lang.Override
    public boolean hasEnd() {
      return eventCase_ == 12;
    }
    /**
     * <code>.opentelemetry.proto.mmap.v1.SpanEvent.EndSpan end = 12;</code>
     * @return The end.
     */
    @java.lang.Override
    public opentelemetry.proto.mmap.v1.Mmap.SpanEvent.EndSpan getEnd() {
      if (eventCase_ == 12) {
         return (opentelemetry.proto.mmap.v1.Mmap.SpanEvent.EndSpan) event_;
      }
      return opentelemetry.proto.mmap.v1.Mmap.SpanEvent.EndSpan.getDefaultInstance();
    }
    /**
     * <code>.opentelemetry.proto.mmap.v1.SpanEvent.EndSpan end = 12;</code>
     */
    @java.lang.Override
    public opentelemetry.proto.mmap.v1.Mmap.SpanEvent.EndSpanOrBuilder getEndOrBuilder() {
      if (eventCase_ == 12) {
         return (opentelemetry.proto.mmap.v1.Mmap.SpanEvent.EndSpan) event_;
      }
      return opentelemetry.proto.mmap.v1.Mmap.SpanEvent.EndSpan.getDefaultInstance();
    }

    public static final int NAME_FIELD_NUMBER = 13;
    /**
     * <code>.opentelemetry.proto.mmap.v1.SpanEvent.ChangeSpanName name = 13;</code>
     * @return Whether the name field is set.
     */
    @java.lang.Override
    public boolean hasName() {
      return eventCase_ == 13;
    }
    /**
     * <code>.opentelemetry.proto.mmap.v1.SpanEvent.ChangeSpanName name = 13;</code>
     * @return The name.
     */
    @java.lang.Override
    public opentelemetry.proto.mmap.v1.Mmap.SpanEvent.ChangeSpanName getName() {
      if (eventCase_ == 13) {
         return (opentelemetry.proto.mmap.v1.Mmap.SpanEvent.ChangeSpanName) event_;
      }
      return opentelemetry.proto.mmap.v1.Mmap.SpanEvent.ChangeSpanName.getDefaultInstance();
    }
    /**
     * <code>.opentelemetry.proto.mmap.v1.SpanEvent.ChangeSpanName name = 13;</code>
     */
    @java.lang.Override
    public opentelemetry.proto.mmap.v1.Mmap.SpanEvent.ChangeSpanNameOrBuilder getNameOrBuilder() {
      if (eventCase_ == 13) {
         return (opentelemetry.proto.mmap.v1.Mmap.SpanEvent.ChangeSpanName) event_;
      }
      return opentelemetry.proto.mmap.v1.Mmap.SpanEvent.ChangeSpanName.getDefaultInstance();
    }

    public static final int ATTRIBUTES_FIELD_NUMBER = 14;
    /**
     * <code>.opentelemetry.proto.mmap.v1.SpanEvent.UpdateAttributes attributes = 14;</code>
     * @return Whether the attributes field is set.
     */
    @java.lang.Override
    public boolean hasAttributes() {
      return eventCase_ == 14;
    }
    /**
     * <code>.opentelemetry.proto.mmap.v1.SpanEvent.UpdateAttributes attributes = 14;</code>
     * @return The attributes.
     */
    @java.lang.Override
    public opentelemetry.proto.mmap.v1.Mmap.SpanEvent.UpdateAttributes getAttributes() {
      if (eventCase_ == 14) {
         return (opentelemetry.proto.mmap.v1.Mmap.SpanEvent.UpdateAttributes) event_;
      }
      return opentelemetry.proto.mmap.v1.Mmap.SpanEvent.UpdateAttributes.getDefaultInstance();
    }
    /**
     * <code>.opentelemetry.proto.mmap.v1.SpanEvent.UpdateAttributes attributes = 14;</code>
     */
    @java.lang.Override
    public opentelemetry.proto.mmap.v1.Mmap.SpanEvent.UpdateAttributesOrBuilder getAttributesOrBuilder() {
      if (eventCase_ == 14) {
         return (opentelemetry.proto.mmap.v1.Mmap.SpanEvent.UpdateAttributes) event_;
      }
      return opentelemetry.proto.mmap.v1.Mmap.SpanEvent.UpdateAttributes.getDefaultInstance();
    }

    public static final int LINK_FIELD_NUMBER = 15;
    /**
     * <code>.opentelemetry.proto.mmap.v1.SpanEvent.AddLink link = 15;</code>
     * @return Whether the link field is set.
     */
    @java.lang.Override
    public boolean hasLink() {
      return eventCase_ == 15;
    }
    /**
     * <code>.opentelemetry.proto.mmap.v1.SpanEvent.AddLink link = 15;</code>
     * @return The link.
     */
    @java.lang.Override
    public opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink getLink() {
      if (eventCase_ == 15) {
         return (opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink) event_;
      }
      return opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink.getDefaultInstance();
    }
    /**
     * <code>.opentelemetry.proto.mmap.v1.SpanEvent.AddLink link = 15;</code>
     */
    @java.lang.Override
    public opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLinkOrBuilder getLinkOrBuilder() {
      if (eventCase_ == 15) {
         return (opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink) event_;
      }
      return opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink.getDefaultInstance();
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!traceId_.isEmpty()) {
        output.writeBytes(1, traceId_);
      }
      if (!spanId_.isEmpty()) {
        output.writeBytes(2, spanId_);
      }
      if (eventCase_ == 11) {
        output.writeMessage(11, (opentelemetry.proto.mmap.v1.Mmap.SpanEvent.StartSpan) event_);
      }
      if (eventCase_ == 12) {
        output.writeMessage(12, (opentelemetry.proto.mmap.v1.Mmap.SpanEvent.EndSpan) event_);
      }
      if (eventCase_ == 13) {
        output.writeMessage(13, (opentelemetry.proto.mmap.v1.Mmap.SpanEvent.ChangeSpanName) event_);
      }
      if (eventCase_ == 14) {
        output.writeMessage(14, (opentelemetry.proto.mmap.v1.Mmap.SpanEvent.UpdateAttributes) event_);
      }
      if (eventCase_ == 15) {
        output.writeMessage(15, (opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink) event_);
      }
      if (scopeRef_ != 0L) {
        output.writeInt64(20, scopeRef_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!traceId_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(1, traceId_);
      }
      if (!spanId_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(2, spanId_);
      }
      if (eventCase_ == 11) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(11, (opentelemetry.proto.mmap.v1.Mmap.SpanEvent.StartSpan) event_);
      }
      if (eventCase_ == 12) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(12, (opentelemetry.proto.mmap.v1.Mmap.SpanEvent.EndSpan) event_);
      }
      if (eventCase_ == 13) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(13, (opentelemetry.proto.mmap.v1.Mmap.SpanEvent.ChangeSpanName) event_);
      }
      if (eventCase_ == 14) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(14, (opentelemetry.proto.mmap.v1.Mmap.SpanEvent.UpdateAttributes) event_);
      }
      if (eventCase_ == 15) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(15, (opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink) event_);
      }
      if (scopeRef_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(20, scopeRef_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof opentelemetry.proto.mmap.v1.Mmap.SpanEvent)) {
        return super.equals(obj);
      }
      opentelemetry.proto.mmap.v1.Mmap.SpanEvent other = (opentelemetry.proto.mmap.v1.Mmap.SpanEvent) obj;

      if (getScopeRef()
          != other.getScopeRef()) return false;
      if (!getTraceId()
          .equals(other.getTraceId())) return false;
      if (!getSpanId()
          .equals(other.getSpanId())) return false;
      if (!getEventCase().equals(other.getEventCase())) return false;
      switch (eventCase_) {
        case 11:
          if (!getStart()
              .equals(other.getStart())) return false;
          break;
        case 12:
          if (!getEnd()
              .equals(other.getEnd())) return false;
          break;
        case 13:
          if (!getName()
              .equals(other.getName())) return false;
          break;
        case 14:
          if (!getAttributes()
              .equals(other.getAttributes())) return false;
          break;
        case 15:
          if (!getLink()
              .equals(other.getLink())) return false;
          break;
        case 0:
        default:
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + SCOPE_REF_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getScopeRef());
      hash = (37 * hash) + TRACE_ID_FIELD_NUMBER;
      hash = (53 * hash) + getTraceId().hashCode();
      hash = (37 * hash) + SPAN_ID_FIELD_NUMBER;
      hash = (53 * hash) + getSpanId().hashCode();
      switch (eventCase_) {
        case 11:
          hash = (37 * hash) + START_FIELD_NUMBER;
          hash = (53 * hash) + getStart().hashCode();
          break;
        case 12:
          hash = (37 * hash) + END_FIELD_NUMBER;
          hash = (53 * hash) + getEnd().hashCode();
          break;
        case 13:
          hash = (37 * hash) + NAME_FIELD_NUMBER;
          hash = (53 * hash) + getName().hashCode();
          break;
        case 14:
          hash = (37 * hash) + ATTRIBUTES_FIELD_NUMBER;
          hash = (53 * hash) + getAttributes().hashCode();
          break;
        case 15:
          hash = (37 * hash) + LINK_FIELD_NUMBER;
          hash = (53 * hash) + getLink().hashCode();
          break;
        case 0:
        default:
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static opentelemetry.proto.mmap.v1.Mmap.SpanEvent parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.SpanEvent parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.SpanEvent parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.SpanEvent parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.SpanEvent parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.SpanEvent parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.SpanEvent parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.SpanEvent parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static opentelemetry.proto.mmap.v1.Mmap.SpanEvent parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static opentelemetry.proto.mmap.v1.Mmap.SpanEvent parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.SpanEvent parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.SpanEvent parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(opentelemetry.proto.mmap.v1.Mmap.SpanEvent prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code opentelemetry.proto.mmap.v1.SpanEvent}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:opentelemetry.proto.mmap.v1.SpanEvent)
        opentelemetry.proto.mmap.v1.Mmap.SpanEventOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_SpanEvent_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_SpanEvent_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                opentelemetry.proto.mmap.v1.Mmap.SpanEvent.class, opentelemetry.proto.mmap.v1.Mmap.SpanEvent.Builder.class);
      }

      // Construct using opentelemetry.proto.mmap.v1.Mmap.SpanEvent.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        scopeRef_ = 0L;
        traceId_ = com.google.protobuf.ByteString.EMPTY;
        spanId_ = com.google.protobuf.ByteString.EMPTY;
        if (startBuilder_ != null) {
          startBuilder_.clear();
        }
        if (endBuilder_ != null) {
          endBuilder_.clear();
        }
        if (nameBuilder_ != null) {
          nameBuilder_.clear();
        }
        if (attributesBuilder_ != null) {
          attributesBuilder_.clear();
        }
        if (linkBuilder_ != null) {
          linkBuilder_.clear();
        }
        eventCase_ = 0;
        event_ = null;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_SpanEvent_descriptor;
      }

      @java.lang.Override
      public opentelemetry.proto.mmap.v1.Mmap.SpanEvent getDefaultInstanceForType() {
        return opentelemetry.proto.mmap.v1.Mmap.SpanEvent.getDefaultInstance();
      }

      @java.lang.Override
      public opentelemetry.proto.mmap.v1.Mmap.SpanEvent build() {
        opentelemetry.proto.mmap.v1.Mmap.SpanEvent result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public opentelemetry.proto.mmap.v1.Mmap.SpanEvent buildPartial() {
        opentelemetry.proto.mmap.v1.Mmap.SpanEvent result = new opentelemetry.proto.mmap.v1.Mmap.SpanEvent(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        buildPartialOneofs(result);
        onBuilt();
        return result;
      }

      private void buildPartial0(opentelemetry.proto.mmap.v1.Mmap.SpanEvent result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.scopeRef_ = scopeRef_;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.traceId_ = traceId_;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.spanId_ = spanId_;
        }
      }

      private void buildPartialOneofs(opentelemetry.proto.mmap.v1.Mmap.SpanEvent result) {
        result.eventCase_ = eventCase_;
        result.event_ = this.event_;
        if (eventCase_ == 11 &&
            startBuilder_ != null) {
          result.event_ = startBuilder_.build();
        }
        if (eventCase_ == 12 &&
            endBuilder_ != null) {
          result.event_ = endBuilder_.build();
        }
        if (eventCase_ == 13 &&
            nameBuilder_ != null) {
          result.event_ = nameBuilder_.build();
        }
        if (eventCase_ == 14 &&
            attributesBuilder_ != null) {
          result.event_ = attributesBuilder_.build();
        }
        if (eventCase_ == 15 &&
            linkBuilder_ != null) {
          result.event_ = linkBuilder_.build();
        }
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof opentelemetry.proto.mmap.v1.Mmap.SpanEvent) {
          return mergeFrom((opentelemetry.proto.mmap.v1.Mmap.SpanEvent)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(opentelemetry.proto.mmap.v1.Mmap.SpanEvent other) {
        if (other == opentelemetry.proto.mmap.v1.Mmap.SpanEvent.getDefaultInstance()) return this;
        if (other.getScopeRef() != 0L) {
          setScopeRef(other.getScopeRef());
        }
        if (!other.getTraceId().isEmpty()) {
          setTraceId(other.getTraceId());
        }
        if (!other.getSpanId().isEmpty()) {
          setSpanId(other.getSpanId());
        }
        switch (other.getEventCase()) {
          case START: {
            mergeStart(other.getStart());
            break;
          }
          case END: {
            mergeEnd(other.getEnd());
            break;
          }
          case NAME: {
            mergeName(other.getName());
            break;
          }
          case ATTRIBUTES: {
            mergeAttributes(other.getAttributes());
            break;
          }
          case LINK: {
            mergeLink(other.getLink());
            break;
          }
          case EVENT_NOT_SET: {
            break;
          }
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                traceId_ = input.readBytes();
                bitField0_ |= 0x00000002;
                break;
              } // case 10
              case 18: {
                spanId_ = input.readBytes();
                bitField0_ |= 0x00000004;
                break;
              } // case 18
              case 90: {
                input.readMessage(
                    internalGetStartFieldBuilder().getBuilder(),
                    extensionRegistry);
                eventCase_ = 11;
                break;
              } // case 90
              case 98: {
                input.readMessage(
                    internalGetEndFieldBuilder().getBuilder(),
                    extensionRegistry);
                eventCase_ = 12;
                break;
              } // case 98
              case 106: {
                input.readMessage(
                    internalGetNameFieldBuilder().getBuilder(),
                    extensionRegistry);
                eventCase_ = 13;
                break;
              } // case 106
              case 114: {
                input.readMessage(
                    internalGetAttributesFieldBuilder().getBuilder(),
                    extensionRegistry);
                eventCase_ = 14;
                break;
              } // case 114
              case 122: {
                input.readMessage(
                    internalGetLinkFieldBuilder().getBuilder(),
                    extensionRegistry);
                eventCase_ = 15;
                break;
              } // case 122
              case 160: {
                scopeRef_ = input.readInt64();
                bitField0_ |= 0x00000001;
                break;
              } // case 160
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int eventCase_ = 0;
      private java.lang.Object event_;
      public EventCase
          getEventCase() {
        return EventCase.forNumber(
            eventCase_);
      }

      public Builder clearEvent() {
        eventCase_ = 0;
        event_ = null;
        onChanged();
        return this;
      }

      private int bitField0_;

      private long scopeRef_ ;
      /**
       * <pre>
       * InsturmentationScope from which this was recorded.
       * </pre>
       *
       * <code>int64 scope_ref = 20;</code>
       * @return The scopeRef.
       */
      @java.lang.Override
      public long getScopeRef() {
        return scopeRef_;
      }
      /**
       * <pre>
       * InsturmentationScope from which this was recorded.
       * </pre>
       *
       * <code>int64 scope_ref = 20;</code>
       * @param value The scopeRef to set.
       * @return This builder for chaining.
       */
      public Builder setScopeRef(long value) {

        scopeRef_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * InsturmentationScope from which this was recorded.
       * </pre>
       *
       * <code>int64 scope_ref = 20;</code>
       * @return This builder for chaining.
       */
      public Builder clearScopeRef() {
        bitField0_ = (bitField0_ & ~0x00000001);
        scopeRef_ = 0L;
        onChanged();
        return this;
      }

      private com.google.protobuf.ByteString traceId_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       * A unique identifier for a trace. All spans from the same trace share
       * the same `trace_id`. The ID is a 16-byte array. An ID with all zeroes OR
       * of length other than 16 bytes is considered invalid (empty string in OTLP/JSON
       * is zero-length and thus is also invalid).
       *
       * This field is required.
       * </pre>
       *
       * <code>bytes trace_id = 1;</code>
       * @return The traceId.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getTraceId() {
        return traceId_;
      }
      /**
       * <pre>
       * A unique identifier for a trace. All spans from the same trace share
       * the same `trace_id`. The ID is a 16-byte array. An ID with all zeroes OR
       * of length other than 16 bytes is considered invalid (empty string in OTLP/JSON
       * is zero-length and thus is also invalid).
       *
       * This field is required.
       * </pre>
       *
       * <code>bytes trace_id = 1;</code>
       * @param value The traceId to set.
       * @return This builder for chaining.
       */
      public Builder setTraceId(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        traceId_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A unique identifier for a trace. All spans from the same trace share
       * the same `trace_id`. The ID is a 16-byte array. An ID with all zeroes OR
       * of length other than 16 bytes is considered invalid (empty string in OTLP/JSON
       * is zero-length and thus is also invalid).
       *
       * This field is required.
       * </pre>
       *
       * <code>bytes trace_id = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearTraceId() {
        bitField0_ = (bitField0_ & ~0x00000002);
        traceId_ = getDefaultInstance().getTraceId();
        onChanged();
        return this;
      }

      private com.google.protobuf.ByteString spanId_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       * A unique identifier for a span within a trace, assigned when the span
       * is created. The ID is an 8-byte array. An ID with all zeroes OR of length
       * other than 8 bytes is considered invalid (empty string in OTLP/JSON
       * is zero-length and thus is also invalid).
       *
       * This field is required.
       * </pre>
       *
       * <code>bytes span_id = 2;</code>
       * @return The spanId.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getSpanId() {
        return spanId_;
      }
      /**
       * <pre>
       * A unique identifier for a span within a trace, assigned when the span
       * is created. The ID is an 8-byte array. An ID with all zeroes OR of length
       * other than 8 bytes is considered invalid (empty string in OTLP/JSON
       * is zero-length and thus is also invalid).
       *
       * This field is required.
       * </pre>
       *
       * <code>bytes span_id = 2;</code>
       * @param value The spanId to set.
       * @return This builder for chaining.
       */
      public Builder setSpanId(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        spanId_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A unique identifier for a span within a trace, assigned when the span
       * is created. The ID is an 8-byte array. An ID with all zeroes OR of length
       * other than 8 bytes is considered invalid (empty string in OTLP/JSON
       * is zero-length and thus is also invalid).
       *
       * This field is required.
       * </pre>
       *
       * <code>bytes span_id = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearSpanId() {
        bitField0_ = (bitField0_ & ~0x00000004);
        spanId_ = getDefaultInstance().getSpanId();
        onChanged();
        return this;
      }

      private com.google.protobuf.SingleFieldBuilder<
          opentelemetry.proto.mmap.v1.Mmap.SpanEvent.StartSpan, opentelemetry.proto.mmap.v1.Mmap.SpanEvent.StartSpan.Builder, opentelemetry.proto.mmap.v1.Mmap.SpanEvent.StartSpanOrBuilder> startBuilder_;
      /**
       * <code>.opentelemetry.proto.mmap.v1.SpanEvent.StartSpan start = 11;</code>
       * @return Whether the start field is set.
       */
      @java.lang.Override
      public boolean hasStart() {
        return eventCase_ == 11;
      }
      /**
       * <code>.opentelemetry.proto.mmap.v1.SpanEvent.StartSpan start = 11;</code>
       * @return The start.
       */
      @java.lang.Override
      public opentelemetry.proto.mmap.v1.Mmap.SpanEvent.StartSpan getStart() {
        if (startBuilder_ == null) {
          if (eventCase_ == 11) {
            return (opentelemetry.proto.mmap.v1.Mmap.SpanEvent.StartSpan) event_;
          }
          return opentelemetry.proto.mmap.v1.Mmap.SpanEvent.StartSpan.getDefaultInstance();
        } else {
          if (eventCase_ == 11) {
            return startBuilder_.getMessage();
          }
          return opentelemetry.proto.mmap.v1.Mmap.SpanEvent.StartSpan.getDefaultInstance();
        }
      }
      /**
       * <code>.opentelemetry.proto.mmap.v1.SpanEvent.StartSpan start = 11;</code>
       */
      public Builder setStart(opentelemetry.proto.mmap.v1.Mmap.SpanEvent.StartSpan value) {
        if (startBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          event_ = value;
          onChanged();
        } else {
          startBuilder_.setMessage(value);
        }
        eventCase_ = 11;
        return this;
      }
      /**
       * <code>.opentelemetry.proto.mmap.v1.SpanEvent.StartSpan start = 11;</code>
       */
      public Builder setStart(
          opentelemetry.proto.mmap.v1.Mmap.SpanEvent.StartSpan.Builder builderForValue) {
        if (startBuilder_ == null) {
          event_ = builderForValue.build();
          onChanged();
        } else {
          startBuilder_.setMessage(builderForValue.build());
        }
        eventCase_ = 11;
        return this;
      }
      /**
       * <code>.opentelemetry.proto.mmap.v1.SpanEvent.StartSpan start = 11;</code>
       */
      public Builder mergeStart(opentelemetry.proto.mmap.v1.Mmap.SpanEvent.StartSpan value) {
        if (startBuilder_ == null) {
          if (eventCase_ == 11 &&
              event_ != opentelemetry.proto.mmap.v1.Mmap.SpanEvent.StartSpan.getDefaultInstance()) {
            event_ = opentelemetry.proto.mmap.v1.Mmap.SpanEvent.StartSpan.newBuilder((opentelemetry.proto.mmap.v1.Mmap.SpanEvent.StartSpan) event_)
                .mergeFrom(value).buildPartial();
          } else {
            event_ = value;
          }
          onChanged();
        } else {
          if (eventCase_ == 11) {
            startBuilder_.mergeFrom(value);
          } else {
            startBuilder_.setMessage(value);
          }
        }
        eventCase_ = 11;
        return this;
      }
      /**
       * <code>.opentelemetry.proto.mmap.v1.SpanEvent.StartSpan start = 11;</code>
       */
      public Builder clearStart() {
        if (startBuilder_ == null) {
          if (eventCase_ == 11) {
            eventCase_ = 0;
            event_ = null;
            onChanged();
          }
        } else {
          if (eventCase_ == 11) {
            eventCase_ = 0;
            event_ = null;
          }
          startBuilder_.clear();
        }
        return this;
      }
      /**
       * <code>.opentelemetry.proto.mmap.v1.SpanEvent.StartSpan start = 11;</code>
       */
      public opentelemetry.proto.mmap.v1.Mmap.SpanEvent.StartSpan.Builder getStartBuilder() {
        return internalGetStartFieldBuilder().getBuilder();
      }
      /**
       * <code>.opentelemetry.proto.mmap.v1.SpanEvent.StartSpan start = 11;</code>
       */
      @java.lang.Override
      public opentelemetry.proto.mmap.v1.Mmap.SpanEvent.StartSpanOrBuilder getStartOrBuilder() {
        if ((eventCase_ == 11) && (startBuilder_ != null)) {
          return startBuilder_.getMessageOrBuilder();
        } else {
          if (eventCase_ == 11) {
            return (opentelemetry.proto.mmap.v1.Mmap.SpanEvent.StartSpan) event_;
          }
          return opentelemetry.proto.mmap.v1.Mmap.SpanEvent.StartSpan.getDefaultInstance();
        }
      }
      /**
       * <code>.opentelemetry.proto.mmap.v1.SpanEvent.StartSpan start = 11;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          opentelemetry.proto.mmap.v1.Mmap.SpanEvent.StartSpan, opentelemetry.proto.mmap.v1.Mmap.SpanEvent.StartSpan.Builder, opentelemetry.proto.mmap.v1.Mmap.SpanEvent.StartSpanOrBuilder> 
          internalGetStartFieldBuilder() {
        if (startBuilder_ == null) {
          if (!(eventCase_ == 11)) {
            event_ = opentelemetry.proto.mmap.v1.Mmap.SpanEvent.StartSpan.getDefaultInstance();
          }
          startBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              opentelemetry.proto.mmap.v1.Mmap.SpanEvent.StartSpan, opentelemetry.proto.mmap.v1.Mmap.SpanEvent.StartSpan.Builder, opentelemetry.proto.mmap.v1.Mmap.SpanEvent.StartSpanOrBuilder>(
                  (opentelemetry.proto.mmap.v1.Mmap.SpanEvent.StartSpan) event_,
                  getParentForChildren(),
                  isClean());
          event_ = null;
        }
        eventCase_ = 11;
        onChanged();
        return startBuilder_;
      }

      private com.google.protobuf.SingleFieldBuilder<
          opentelemetry.proto.mmap.v1.Mmap.SpanEvent.EndSpan, opentelemetry.proto.mmap.v1.Mmap.SpanEvent.EndSpan.Builder, opentelemetry.proto.mmap.v1.Mmap.SpanEvent.EndSpanOrBuilder> endBuilder_;
      /**
       * <code>.opentelemetry.proto.mmap.v1.SpanEvent.EndSpan end = 12;</code>
       * @return Whether the end field is set.
       */
      @java.lang.Override
      public boolean hasEnd() {
        return eventCase_ == 12;
      }
      /**
       * <code>.opentelemetry.proto.mmap.v1.SpanEvent.EndSpan end = 12;</code>
       * @return The end.
       */
      @java.lang.Override
      public opentelemetry.proto.mmap.v1.Mmap.SpanEvent.EndSpan getEnd() {
        if (endBuilder_ == null) {
          if (eventCase_ == 12) {
            return (opentelemetry.proto.mmap.v1.Mmap.SpanEvent.EndSpan) event_;
          }
          return opentelemetry.proto.mmap.v1.Mmap.SpanEvent.EndSpan.getDefaultInstance();
        } else {
          if (eventCase_ == 12) {
            return endBuilder_.getMessage();
          }
          return opentelemetry.proto.mmap.v1.Mmap.SpanEvent.EndSpan.getDefaultInstance();
        }
      }
      /**
       * <code>.opentelemetry.proto.mmap.v1.SpanEvent.EndSpan end = 12;</code>
       */
      public Builder setEnd(opentelemetry.proto.mmap.v1.Mmap.SpanEvent.EndSpan value) {
        if (endBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          event_ = value;
          onChanged();
        } else {
          endBuilder_.setMessage(value);
        }
        eventCase_ = 12;
        return this;
      }
      /**
       * <code>.opentelemetry.proto.mmap.v1.SpanEvent.EndSpan end = 12;</code>
       */
      public Builder setEnd(
          opentelemetry.proto.mmap.v1.Mmap.SpanEvent.EndSpan.Builder builderForValue) {
        if (endBuilder_ == null) {
          event_ = builderForValue.build();
          onChanged();
        } else {
          endBuilder_.setMessage(builderForValue.build());
        }
        eventCase_ = 12;
        return this;
      }
      /**
       * <code>.opentelemetry.proto.mmap.v1.SpanEvent.EndSpan end = 12;</code>
       */
      public Builder mergeEnd(opentelemetry.proto.mmap.v1.Mmap.SpanEvent.EndSpan value) {
        if (endBuilder_ == null) {
          if (eventCase_ == 12 &&
              event_ != opentelemetry.proto.mmap.v1.Mmap.SpanEvent.EndSpan.getDefaultInstance()) {
            event_ = opentelemetry.proto.mmap.v1.Mmap.SpanEvent.EndSpan.newBuilder((opentelemetry.proto.mmap.v1.Mmap.SpanEvent.EndSpan) event_)
                .mergeFrom(value).buildPartial();
          } else {
            event_ = value;
          }
          onChanged();
        } else {
          if (eventCase_ == 12) {
            endBuilder_.mergeFrom(value);
          } else {
            endBuilder_.setMessage(value);
          }
        }
        eventCase_ = 12;
        return this;
      }
      /**
       * <code>.opentelemetry.proto.mmap.v1.SpanEvent.EndSpan end = 12;</code>
       */
      public Builder clearEnd() {
        if (endBuilder_ == null) {
          if (eventCase_ == 12) {
            eventCase_ = 0;
            event_ = null;
            onChanged();
          }
        } else {
          if (eventCase_ == 12) {
            eventCase_ = 0;
            event_ = null;
          }
          endBuilder_.clear();
        }
        return this;
      }
      /**
       * <code>.opentelemetry.proto.mmap.v1.SpanEvent.EndSpan end = 12;</code>
       */
      public opentelemetry.proto.mmap.v1.Mmap.SpanEvent.EndSpan.Builder getEndBuilder() {
        return internalGetEndFieldBuilder().getBuilder();
      }
      /**
       * <code>.opentelemetry.proto.mmap.v1.SpanEvent.EndSpan end = 12;</code>
       */
      @java.lang.Override
      public opentelemetry.proto.mmap.v1.Mmap.SpanEvent.EndSpanOrBuilder getEndOrBuilder() {
        if ((eventCase_ == 12) && (endBuilder_ != null)) {
          return endBuilder_.getMessageOrBuilder();
        } else {
          if (eventCase_ == 12) {
            return (opentelemetry.proto.mmap.v1.Mmap.SpanEvent.EndSpan) event_;
          }
          return opentelemetry.proto.mmap.v1.Mmap.SpanEvent.EndSpan.getDefaultInstance();
        }
      }
      /**
       * <code>.opentelemetry.proto.mmap.v1.SpanEvent.EndSpan end = 12;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          opentelemetry.proto.mmap.v1.Mmap.SpanEvent.EndSpan, opentelemetry.proto.mmap.v1.Mmap.SpanEvent.EndSpan.Builder, opentelemetry.proto.mmap.v1.Mmap.SpanEvent.EndSpanOrBuilder> 
          internalGetEndFieldBuilder() {
        if (endBuilder_ == null) {
          if (!(eventCase_ == 12)) {
            event_ = opentelemetry.proto.mmap.v1.Mmap.SpanEvent.EndSpan.getDefaultInstance();
          }
          endBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              opentelemetry.proto.mmap.v1.Mmap.SpanEvent.EndSpan, opentelemetry.proto.mmap.v1.Mmap.SpanEvent.EndSpan.Builder, opentelemetry.proto.mmap.v1.Mmap.SpanEvent.EndSpanOrBuilder>(
                  (opentelemetry.proto.mmap.v1.Mmap.SpanEvent.EndSpan) event_,
                  getParentForChildren(),
                  isClean());
          event_ = null;
        }
        eventCase_ = 12;
        onChanged();
        return endBuilder_;
      }

      private com.google.protobuf.SingleFieldBuilder<
          opentelemetry.proto.mmap.v1.Mmap.SpanEvent.ChangeSpanName, opentelemetry.proto.mmap.v1.Mmap.SpanEvent.ChangeSpanName.Builder, opentelemetry.proto.mmap.v1.Mmap.SpanEvent.ChangeSpanNameOrBuilder> nameBuilder_;
      /**
       * <code>.opentelemetry.proto.mmap.v1.SpanEvent.ChangeSpanName name = 13;</code>
       * @return Whether the name field is set.
       */
      @java.lang.Override
      public boolean hasName() {
        return eventCase_ == 13;
      }
      /**
       * <code>.opentelemetry.proto.mmap.v1.SpanEvent.ChangeSpanName name = 13;</code>
       * @return The name.
       */
      @java.lang.Override
      public opentelemetry.proto.mmap.v1.Mmap.SpanEvent.ChangeSpanName getName() {
        if (nameBuilder_ == null) {
          if (eventCase_ == 13) {
            return (opentelemetry.proto.mmap.v1.Mmap.SpanEvent.ChangeSpanName) event_;
          }
          return opentelemetry.proto.mmap.v1.Mmap.SpanEvent.ChangeSpanName.getDefaultInstance();
        } else {
          if (eventCase_ == 13) {
            return nameBuilder_.getMessage();
          }
          return opentelemetry.proto.mmap.v1.Mmap.SpanEvent.ChangeSpanName.getDefaultInstance();
        }
      }
      /**
       * <code>.opentelemetry.proto.mmap.v1.SpanEvent.ChangeSpanName name = 13;</code>
       */
      public Builder setName(opentelemetry.proto.mmap.v1.Mmap.SpanEvent.ChangeSpanName value) {
        if (nameBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          event_ = value;
          onChanged();
        } else {
          nameBuilder_.setMessage(value);
        }
        eventCase_ = 13;
        return this;
      }
      /**
       * <code>.opentelemetry.proto.mmap.v1.SpanEvent.ChangeSpanName name = 13;</code>
       */
      public Builder setName(
          opentelemetry.proto.mmap.v1.Mmap.SpanEvent.ChangeSpanName.Builder builderForValue) {
        if (nameBuilder_ == null) {
          event_ = builderForValue.build();
          onChanged();
        } else {
          nameBuilder_.setMessage(builderForValue.build());
        }
        eventCase_ = 13;
        return this;
      }
      /**
       * <code>.opentelemetry.proto.mmap.v1.SpanEvent.ChangeSpanName name = 13;</code>
       */
      public Builder mergeName(opentelemetry.proto.mmap.v1.Mmap.SpanEvent.ChangeSpanName value) {
        if (nameBuilder_ == null) {
          if (eventCase_ == 13 &&
              event_ != opentelemetry.proto.mmap.v1.Mmap.SpanEvent.ChangeSpanName.getDefaultInstance()) {
            event_ = opentelemetry.proto.mmap.v1.Mmap.SpanEvent.ChangeSpanName.newBuilder((opentelemetry.proto.mmap.v1.Mmap.SpanEvent.ChangeSpanName) event_)
                .mergeFrom(value).buildPartial();
          } else {
            event_ = value;
          }
          onChanged();
        } else {
          if (eventCase_ == 13) {
            nameBuilder_.mergeFrom(value);
          } else {
            nameBuilder_.setMessage(value);
          }
        }
        eventCase_ = 13;
        return this;
      }
      /**
       * <code>.opentelemetry.proto.mmap.v1.SpanEvent.ChangeSpanName name = 13;</code>
       */
      public Builder clearName() {
        if (nameBuilder_ == null) {
          if (eventCase_ == 13) {
            eventCase_ = 0;
            event_ = null;
            onChanged();
          }
        } else {
          if (eventCase_ == 13) {
            eventCase_ = 0;
            event_ = null;
          }
          nameBuilder_.clear();
        }
        return this;
      }
      /**
       * <code>.opentelemetry.proto.mmap.v1.SpanEvent.ChangeSpanName name = 13;</code>
       */
      public opentelemetry.proto.mmap.v1.Mmap.SpanEvent.ChangeSpanName.Builder getNameBuilder() {
        return internalGetNameFieldBuilder().getBuilder();
      }
      /**
       * <code>.opentelemetry.proto.mmap.v1.SpanEvent.ChangeSpanName name = 13;</code>
       */
      @java.lang.Override
      public opentelemetry.proto.mmap.v1.Mmap.SpanEvent.ChangeSpanNameOrBuilder getNameOrBuilder() {
        if ((eventCase_ == 13) && (nameBuilder_ != null)) {
          return nameBuilder_.getMessageOrBuilder();
        } else {
          if (eventCase_ == 13) {
            return (opentelemetry.proto.mmap.v1.Mmap.SpanEvent.ChangeSpanName) event_;
          }
          return opentelemetry.proto.mmap.v1.Mmap.SpanEvent.ChangeSpanName.getDefaultInstance();
        }
      }
      /**
       * <code>.opentelemetry.proto.mmap.v1.SpanEvent.ChangeSpanName name = 13;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          opentelemetry.proto.mmap.v1.Mmap.SpanEvent.ChangeSpanName, opentelemetry.proto.mmap.v1.Mmap.SpanEvent.ChangeSpanName.Builder, opentelemetry.proto.mmap.v1.Mmap.SpanEvent.ChangeSpanNameOrBuilder> 
          internalGetNameFieldBuilder() {
        if (nameBuilder_ == null) {
          if (!(eventCase_ == 13)) {
            event_ = opentelemetry.proto.mmap.v1.Mmap.SpanEvent.ChangeSpanName.getDefaultInstance();
          }
          nameBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              opentelemetry.proto.mmap.v1.Mmap.SpanEvent.ChangeSpanName, opentelemetry.proto.mmap.v1.Mmap.SpanEvent.ChangeSpanName.Builder, opentelemetry.proto.mmap.v1.Mmap.SpanEvent.ChangeSpanNameOrBuilder>(
                  (opentelemetry.proto.mmap.v1.Mmap.SpanEvent.ChangeSpanName) event_,
                  getParentForChildren(),
                  isClean());
          event_ = null;
        }
        eventCase_ = 13;
        onChanged();
        return nameBuilder_;
      }

      private com.google.protobuf.SingleFieldBuilder<
          opentelemetry.proto.mmap.v1.Mmap.SpanEvent.UpdateAttributes, opentelemetry.proto.mmap.v1.Mmap.SpanEvent.UpdateAttributes.Builder, opentelemetry.proto.mmap.v1.Mmap.SpanEvent.UpdateAttributesOrBuilder> attributesBuilder_;
      /**
       * <code>.opentelemetry.proto.mmap.v1.SpanEvent.UpdateAttributes attributes = 14;</code>
       * @return Whether the attributes field is set.
       */
      @java.lang.Override
      public boolean hasAttributes() {
        return eventCase_ == 14;
      }
      /**
       * <code>.opentelemetry.proto.mmap.v1.SpanEvent.UpdateAttributes attributes = 14;</code>
       * @return The attributes.
       */
      @java.lang.Override
      public opentelemetry.proto.mmap.v1.Mmap.SpanEvent.UpdateAttributes getAttributes() {
        if (attributesBuilder_ == null) {
          if (eventCase_ == 14) {
            return (opentelemetry.proto.mmap.v1.Mmap.SpanEvent.UpdateAttributes) event_;
          }
          return opentelemetry.proto.mmap.v1.Mmap.SpanEvent.UpdateAttributes.getDefaultInstance();
        } else {
          if (eventCase_ == 14) {
            return attributesBuilder_.getMessage();
          }
          return opentelemetry.proto.mmap.v1.Mmap.SpanEvent.UpdateAttributes.getDefaultInstance();
        }
      }
      /**
       * <code>.opentelemetry.proto.mmap.v1.SpanEvent.UpdateAttributes attributes = 14;</code>
       */
      public Builder setAttributes(opentelemetry.proto.mmap.v1.Mmap.SpanEvent.UpdateAttributes value) {
        if (attributesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          event_ = value;
          onChanged();
        } else {
          attributesBuilder_.setMessage(value);
        }
        eventCase_ = 14;
        return this;
      }
      /**
       * <code>.opentelemetry.proto.mmap.v1.SpanEvent.UpdateAttributes attributes = 14;</code>
       */
      public Builder setAttributes(
          opentelemetry.proto.mmap.v1.Mmap.SpanEvent.UpdateAttributes.Builder builderForValue) {
        if (attributesBuilder_ == null) {
          event_ = builderForValue.build();
          onChanged();
        } else {
          attributesBuilder_.setMessage(builderForValue.build());
        }
        eventCase_ = 14;
        return this;
      }
      /**
       * <code>.opentelemetry.proto.mmap.v1.SpanEvent.UpdateAttributes attributes = 14;</code>
       */
      public Builder mergeAttributes(opentelemetry.proto.mmap.v1.Mmap.SpanEvent.UpdateAttributes value) {
        if (attributesBuilder_ == null) {
          if (eventCase_ == 14 &&
              event_ != opentelemetry.proto.mmap.v1.Mmap.SpanEvent.UpdateAttributes.getDefaultInstance()) {
            event_ = opentelemetry.proto.mmap.v1.Mmap.SpanEvent.UpdateAttributes.newBuilder((opentelemetry.proto.mmap.v1.Mmap.SpanEvent.UpdateAttributes) event_)
                .mergeFrom(value).buildPartial();
          } else {
            event_ = value;
          }
          onChanged();
        } else {
          if (eventCase_ == 14) {
            attributesBuilder_.mergeFrom(value);
          } else {
            attributesBuilder_.setMessage(value);
          }
        }
        eventCase_ = 14;
        return this;
      }
      /**
       * <code>.opentelemetry.proto.mmap.v1.SpanEvent.UpdateAttributes attributes = 14;</code>
       */
      public Builder clearAttributes() {
        if (attributesBuilder_ == null) {
          if (eventCase_ == 14) {
            eventCase_ = 0;
            event_ = null;
            onChanged();
          }
        } else {
          if (eventCase_ == 14) {
            eventCase_ = 0;
            event_ = null;
          }
          attributesBuilder_.clear();
        }
        return this;
      }
      /**
       * <code>.opentelemetry.proto.mmap.v1.SpanEvent.UpdateAttributes attributes = 14;</code>
       */
      public opentelemetry.proto.mmap.v1.Mmap.SpanEvent.UpdateAttributes.Builder getAttributesBuilder() {
        return internalGetAttributesFieldBuilder().getBuilder();
      }
      /**
       * <code>.opentelemetry.proto.mmap.v1.SpanEvent.UpdateAttributes attributes = 14;</code>
       */
      @java.lang.Override
      public opentelemetry.proto.mmap.v1.Mmap.SpanEvent.UpdateAttributesOrBuilder getAttributesOrBuilder() {
        if ((eventCase_ == 14) && (attributesBuilder_ != null)) {
          return attributesBuilder_.getMessageOrBuilder();
        } else {
          if (eventCase_ == 14) {
            return (opentelemetry.proto.mmap.v1.Mmap.SpanEvent.UpdateAttributes) event_;
          }
          return opentelemetry.proto.mmap.v1.Mmap.SpanEvent.UpdateAttributes.getDefaultInstance();
        }
      }
      /**
       * <code>.opentelemetry.proto.mmap.v1.SpanEvent.UpdateAttributes attributes = 14;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          opentelemetry.proto.mmap.v1.Mmap.SpanEvent.UpdateAttributes, opentelemetry.proto.mmap.v1.Mmap.SpanEvent.UpdateAttributes.Builder, opentelemetry.proto.mmap.v1.Mmap.SpanEvent.UpdateAttributesOrBuilder> 
          internalGetAttributesFieldBuilder() {
        if (attributesBuilder_ == null) {
          if (!(eventCase_ == 14)) {
            event_ = opentelemetry.proto.mmap.v1.Mmap.SpanEvent.UpdateAttributes.getDefaultInstance();
          }
          attributesBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              opentelemetry.proto.mmap.v1.Mmap.SpanEvent.UpdateAttributes, opentelemetry.proto.mmap.v1.Mmap.SpanEvent.UpdateAttributes.Builder, opentelemetry.proto.mmap.v1.Mmap.SpanEvent.UpdateAttributesOrBuilder>(
                  (opentelemetry.proto.mmap.v1.Mmap.SpanEvent.UpdateAttributes) event_,
                  getParentForChildren(),
                  isClean());
          event_ = null;
        }
        eventCase_ = 14;
        onChanged();
        return attributesBuilder_;
      }

      private com.google.protobuf.SingleFieldBuilder<
          opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink, opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink.Builder, opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLinkOrBuilder> linkBuilder_;
      /**
       * <code>.opentelemetry.proto.mmap.v1.SpanEvent.AddLink link = 15;</code>
       * @return Whether the link field is set.
       */
      @java.lang.Override
      public boolean hasLink() {
        return eventCase_ == 15;
      }
      /**
       * <code>.opentelemetry.proto.mmap.v1.SpanEvent.AddLink link = 15;</code>
       * @return The link.
       */
      @java.lang.Override
      public opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink getLink() {
        if (linkBuilder_ == null) {
          if (eventCase_ == 15) {
            return (opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink) event_;
          }
          return opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink.getDefaultInstance();
        } else {
          if (eventCase_ == 15) {
            return linkBuilder_.getMessage();
          }
          return opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink.getDefaultInstance();
        }
      }
      /**
       * <code>.opentelemetry.proto.mmap.v1.SpanEvent.AddLink link = 15;</code>
       */
      public Builder setLink(opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink value) {
        if (linkBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          event_ = value;
          onChanged();
        } else {
          linkBuilder_.setMessage(value);
        }
        eventCase_ = 15;
        return this;
      }
      /**
       * <code>.opentelemetry.proto.mmap.v1.SpanEvent.AddLink link = 15;</code>
       */
      public Builder setLink(
          opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink.Builder builderForValue) {
        if (linkBuilder_ == null) {
          event_ = builderForValue.build();
          onChanged();
        } else {
          linkBuilder_.setMessage(builderForValue.build());
        }
        eventCase_ = 15;
        return this;
      }
      /**
       * <code>.opentelemetry.proto.mmap.v1.SpanEvent.AddLink link = 15;</code>
       */
      public Builder mergeLink(opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink value) {
        if (linkBuilder_ == null) {
          if (eventCase_ == 15 &&
              event_ != opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink.getDefaultInstance()) {
            event_ = opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink.newBuilder((opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink) event_)
                .mergeFrom(value).buildPartial();
          } else {
            event_ = value;
          }
          onChanged();
        } else {
          if (eventCase_ == 15) {
            linkBuilder_.mergeFrom(value);
          } else {
            linkBuilder_.setMessage(value);
          }
        }
        eventCase_ = 15;
        return this;
      }
      /**
       * <code>.opentelemetry.proto.mmap.v1.SpanEvent.AddLink link = 15;</code>
       */
      public Builder clearLink() {
        if (linkBuilder_ == null) {
          if (eventCase_ == 15) {
            eventCase_ = 0;
            event_ = null;
            onChanged();
          }
        } else {
          if (eventCase_ == 15) {
            eventCase_ = 0;
            event_ = null;
          }
          linkBuilder_.clear();
        }
        return this;
      }
      /**
       * <code>.opentelemetry.proto.mmap.v1.SpanEvent.AddLink link = 15;</code>
       */
      public opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink.Builder getLinkBuilder() {
        return internalGetLinkFieldBuilder().getBuilder();
      }
      /**
       * <code>.opentelemetry.proto.mmap.v1.SpanEvent.AddLink link = 15;</code>
       */
      @java.lang.Override
      public opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLinkOrBuilder getLinkOrBuilder() {
        if ((eventCase_ == 15) && (linkBuilder_ != null)) {
          return linkBuilder_.getMessageOrBuilder();
        } else {
          if (eventCase_ == 15) {
            return (opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink) event_;
          }
          return opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink.getDefaultInstance();
        }
      }
      /**
       * <code>.opentelemetry.proto.mmap.v1.SpanEvent.AddLink link = 15;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink, opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink.Builder, opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLinkOrBuilder> 
          internalGetLinkFieldBuilder() {
        if (linkBuilder_ == null) {
          if (!(eventCase_ == 15)) {
            event_ = opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink.getDefaultInstance();
          }
          linkBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink, opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink.Builder, opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLinkOrBuilder>(
                  (opentelemetry.proto.mmap.v1.Mmap.SpanEvent.AddLink) event_,
                  getParentForChildren(),
                  isClean());
          event_ = null;
        }
        eventCase_ = 15;
        onChanged();
        return linkBuilder_;
      }

      // @@protoc_insertion_point(builder_scope:opentelemetry.proto.mmap.v1.SpanEvent)
    }

    // @@protoc_insertion_point(class_scope:opentelemetry.proto.mmap.v1.SpanEvent)
    private static final opentelemetry.proto.mmap.v1.Mmap.SpanEvent DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new opentelemetry.proto.mmap.v1.Mmap.SpanEvent();
    }

    public static opentelemetry.proto.mmap.v1.Mmap.SpanEvent getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<SpanEvent>
        PARSER = new com.google.protobuf.AbstractParser<SpanEvent>() {
      @java.lang.Override
      public SpanEvent parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<SpanEvent> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<SpanEvent> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public opentelemetry.proto.mmap.v1.Mmap.SpanEvent getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface StatusOrBuilder extends
      // @@protoc_insertion_point(interface_extends:opentelemetry.proto.mmap.v1.Status)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * A developer-facing human readable error message.
     * </pre>
     *
     * <code>string message = 2;</code>
     * @return The message.
     */
    java.lang.String getMessage();
    /**
     * <pre>
     * A developer-facing human readable error message.
     * </pre>
     *
     * <code>string message = 2;</code>
     * @return The bytes for message.
     */
    com.google.protobuf.ByteString
        getMessageBytes();

    /**
     * <pre>
     * The status code.
     * </pre>
     *
     * <code>.opentelemetry.proto.mmap.v1.Status.StatusCode code = 3;</code>
     * @return The enum numeric value on the wire for code.
     */
    int getCodeValue();
    /**
     * <pre>
     * The status code.
     * </pre>
     *
     * <code>.opentelemetry.proto.mmap.v1.Status.StatusCode code = 3;</code>
     * @return The code.
     */
    opentelemetry.proto.mmap.v1.Mmap.Status.StatusCode getCode();
  }
  /**
   * <pre>
   * The Status type defines a logical error model that is suitable for different
   * programming environments, including REST APIs and RPC APIs.
   * </pre>
   *
   * Protobuf type {@code opentelemetry.proto.mmap.v1.Status}
   */
  public static final class Status extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:opentelemetry.proto.mmap.v1.Status)
      StatusOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 33,
        /* patch= */ 0,
        /* suffix= */ "",
        "Status");
    }
    // Use Status.newBuilder() to construct.
    private Status(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private Status() {
      message_ = "";
      code_ = 0;
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_Status_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_Status_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              opentelemetry.proto.mmap.v1.Mmap.Status.class, opentelemetry.proto.mmap.v1.Mmap.Status.Builder.class);
    }

    /**
     * <pre>
     * For the semantics of status codes see
     * https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/trace/api.md#set-status
     * </pre>
     *
     * Protobuf enum {@code opentelemetry.proto.mmap.v1.Status.StatusCode}
     */
    public enum StatusCode
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <pre>
       * The default status.
       * </pre>
       *
       * <code>STATUS_CODE_UNSET = 0;</code>
       */
      STATUS_CODE_UNSET(0),
      /**
       * <pre>
       * The Span has been validated by an Application developer or Operator to 
       * have completed successfully.
       * </pre>
       *
       * <code>STATUS_CODE_OK = 1;</code>
       */
      STATUS_CODE_OK(1),
      /**
       * <pre>
       * The Span contains an error.
       * </pre>
       *
       * <code>STATUS_CODE_ERROR = 2;</code>
       */
      STATUS_CODE_ERROR(2),
      UNRECOGNIZED(-1),
      ;

      static {
        com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
          com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
          /* major= */ 4,
          /* minor= */ 33,
          /* patch= */ 0,
          /* suffix= */ "",
          "StatusCode");
      }
      /**
       * <pre>
       * The default status.
       * </pre>
       *
       * <code>STATUS_CODE_UNSET = 0;</code>
       */
      public static final int STATUS_CODE_UNSET_VALUE = 0;
      /**
       * <pre>
       * The Span has been validated by an Application developer or Operator to 
       * have completed successfully.
       * </pre>
       *
       * <code>STATUS_CODE_OK = 1;</code>
       */
      public static final int STATUS_CODE_OK_VALUE = 1;
      /**
       * <pre>
       * The Span contains an error.
       * </pre>
       *
       * <code>STATUS_CODE_ERROR = 2;</code>
       */
      public static final int STATUS_CODE_ERROR_VALUE = 2;


      public final int getNumber() {
        if (this == UNRECOGNIZED) {
          throw new java.lang.IllegalArgumentException(
              "Can't get the number of an unknown enum value.");
        }
        return value;
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static StatusCode valueOf(int value) {
        return forNumber(value);
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       */
      public static StatusCode forNumber(int value) {
        switch (value) {
          case 0: return STATUS_CODE_UNSET;
          case 1: return STATUS_CODE_OK;
          case 2: return STATUS_CODE_ERROR;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<StatusCode>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          StatusCode> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<StatusCode>() {
              public StatusCode findValueByNumber(int number) {
                return StatusCode.forNumber(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        if (this == UNRECOGNIZED) {
          throw new java.lang.IllegalStateException(
              "Can't get the descriptor of an unrecognized enum value.");
        }
        return getDescriptor().getValues().get(ordinal());
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return opentelemetry.proto.mmap.v1.Mmap.Status.getDescriptor().getEnumTypes().get(0);
      }

      private static final StatusCode[] VALUES = values();

      public static StatusCode valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        if (desc.getIndex() == -1) {
          return UNRECOGNIZED;
        }
        return VALUES[desc.getIndex()];
      }

      private final int value;

      private StatusCode(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:opentelemetry.proto.mmap.v1.Status.StatusCode)
    }

    public static final int MESSAGE_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private volatile java.lang.Object message_ = "";
    /**
     * <pre>
     * A developer-facing human readable error message.
     * </pre>
     *
     * <code>string message = 2;</code>
     * @return The message.
     */
    @java.lang.Override
    public java.lang.String getMessage() {
      java.lang.Object ref = message_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        message_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * A developer-facing human readable error message.
     * </pre>
     *
     * <code>string message = 2;</code>
     * @return The bytes for message.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getMessageBytes() {
      java.lang.Object ref = message_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        message_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int CODE_FIELD_NUMBER = 3;
    private int code_ = 0;
    /**
     * <pre>
     * The status code.
     * </pre>
     *
     * <code>.opentelemetry.proto.mmap.v1.Status.StatusCode code = 3;</code>
     * @return The enum numeric value on the wire for code.
     */
    @java.lang.Override public int getCodeValue() {
      return code_;
    }
    /**
     * <pre>
     * The status code.
     * </pre>
     *
     * <code>.opentelemetry.proto.mmap.v1.Status.StatusCode code = 3;</code>
     * @return The code.
     */
    @java.lang.Override public opentelemetry.proto.mmap.v1.Mmap.Status.StatusCode getCode() {
      opentelemetry.proto.mmap.v1.Mmap.Status.StatusCode result = opentelemetry.proto.mmap.v1.Mmap.Status.StatusCode.forNumber(code_);
      return result == null ? opentelemetry.proto.mmap.v1.Mmap.Status.StatusCode.UNRECOGNIZED : result;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!com.google.protobuf.GeneratedMessage.isStringEmpty(message_)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 2, message_);
      }
      if (code_ != opentelemetry.proto.mmap.v1.Mmap.Status.StatusCode.STATUS_CODE_UNSET.getNumber()) {
        output.writeEnum(3, code_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!com.google.protobuf.GeneratedMessage.isStringEmpty(message_)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(2, message_);
      }
      if (code_ != opentelemetry.proto.mmap.v1.Mmap.Status.StatusCode.STATUS_CODE_UNSET.getNumber()) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(3, code_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof opentelemetry.proto.mmap.v1.Mmap.Status)) {
        return super.equals(obj);
      }
      opentelemetry.proto.mmap.v1.Mmap.Status other = (opentelemetry.proto.mmap.v1.Mmap.Status) obj;

      if (!getMessage()
          .equals(other.getMessage())) return false;
      if (code_ != other.code_) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + MESSAGE_FIELD_NUMBER;
      hash = (53 * hash) + getMessage().hashCode();
      hash = (37 * hash) + CODE_FIELD_NUMBER;
      hash = (53 * hash) + code_;
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static opentelemetry.proto.mmap.v1.Mmap.Status parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.Status parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.Status parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.Status parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.Status parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.Status parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.Status parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.Status parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static opentelemetry.proto.mmap.v1.Mmap.Status parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static opentelemetry.proto.mmap.v1.Mmap.Status parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.Status parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.Status parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(opentelemetry.proto.mmap.v1.Mmap.Status prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * The Status type defines a logical error model that is suitable for different
     * programming environments, including REST APIs and RPC APIs.
     * </pre>
     *
     * Protobuf type {@code opentelemetry.proto.mmap.v1.Status}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:opentelemetry.proto.mmap.v1.Status)
        opentelemetry.proto.mmap.v1.Mmap.StatusOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_Status_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_Status_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                opentelemetry.proto.mmap.v1.Mmap.Status.class, opentelemetry.proto.mmap.v1.Mmap.Status.Builder.class);
      }

      // Construct using opentelemetry.proto.mmap.v1.Mmap.Status.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        message_ = "";
        code_ = 0;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_Status_descriptor;
      }

      @java.lang.Override
      public opentelemetry.proto.mmap.v1.Mmap.Status getDefaultInstanceForType() {
        return opentelemetry.proto.mmap.v1.Mmap.Status.getDefaultInstance();
      }

      @java.lang.Override
      public opentelemetry.proto.mmap.v1.Mmap.Status build() {
        opentelemetry.proto.mmap.v1.Mmap.Status result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public opentelemetry.proto.mmap.v1.Mmap.Status buildPartial() {
        opentelemetry.proto.mmap.v1.Mmap.Status result = new opentelemetry.proto.mmap.v1.Mmap.Status(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(opentelemetry.proto.mmap.v1.Mmap.Status result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.message_ = message_;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.code_ = code_;
        }
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof opentelemetry.proto.mmap.v1.Mmap.Status) {
          return mergeFrom((opentelemetry.proto.mmap.v1.Mmap.Status)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(opentelemetry.proto.mmap.v1.Mmap.Status other) {
        if (other == opentelemetry.proto.mmap.v1.Mmap.Status.getDefaultInstance()) return this;
        if (!other.getMessage().isEmpty()) {
          message_ = other.message_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        if (other.code_ != 0) {
          setCodeValue(other.getCodeValue());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 18: {
                message_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000001;
                break;
              } // case 18
              case 24: {
                code_ = input.readEnum();
                bitField0_ |= 0x00000002;
                break;
              } // case 24
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.lang.Object message_ = "";
      /**
       * <pre>
       * A developer-facing human readable error message.
       * </pre>
       *
       * <code>string message = 2;</code>
       * @return The message.
       */
      public java.lang.String getMessage() {
        java.lang.Object ref = message_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          message_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * A developer-facing human readable error message.
       * </pre>
       *
       * <code>string message = 2;</code>
       * @return The bytes for message.
       */
      public com.google.protobuf.ByteString
          getMessageBytes() {
        java.lang.Object ref = message_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          message_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * A developer-facing human readable error message.
       * </pre>
       *
       * <code>string message = 2;</code>
       * @param value The message to set.
       * @return This builder for chaining.
       */
      public Builder setMessage(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        message_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A developer-facing human readable error message.
       * </pre>
       *
       * <code>string message = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearMessage() {
        message_ = getDefaultInstance().getMessage();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A developer-facing human readable error message.
       * </pre>
       *
       * <code>string message = 2;</code>
       * @param value The bytes for message to set.
       * @return This builder for chaining.
       */
      public Builder setMessageBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        message_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private int code_ = 0;
      /**
       * <pre>
       * The status code.
       * </pre>
       *
       * <code>.opentelemetry.proto.mmap.v1.Status.StatusCode code = 3;</code>
       * @return The enum numeric value on the wire for code.
       */
      @java.lang.Override public int getCodeValue() {
        return code_;
      }
      /**
       * <pre>
       * The status code.
       * </pre>
       *
       * <code>.opentelemetry.proto.mmap.v1.Status.StatusCode code = 3;</code>
       * @param value The enum numeric value on the wire for code to set.
       * @return This builder for chaining.
       */
      public Builder setCodeValue(int value) {
        code_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The status code.
       * </pre>
       *
       * <code>.opentelemetry.proto.mmap.v1.Status.StatusCode code = 3;</code>
       * @return The code.
       */
      @java.lang.Override
      public opentelemetry.proto.mmap.v1.Mmap.Status.StatusCode getCode() {
        opentelemetry.proto.mmap.v1.Mmap.Status.StatusCode result = opentelemetry.proto.mmap.v1.Mmap.Status.StatusCode.forNumber(code_);
        return result == null ? opentelemetry.proto.mmap.v1.Mmap.Status.StatusCode.UNRECOGNIZED : result;
      }
      /**
       * <pre>
       * The status code.
       * </pre>
       *
       * <code>.opentelemetry.proto.mmap.v1.Status.StatusCode code = 3;</code>
       * @param value The code to set.
       * @return This builder for chaining.
       */
      public Builder setCode(opentelemetry.proto.mmap.v1.Mmap.Status.StatusCode value) {
        if (value == null) { throw new NullPointerException(); }
        bitField0_ |= 0x00000002;
        code_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The status code.
       * </pre>
       *
       * <code>.opentelemetry.proto.mmap.v1.Status.StatusCode code = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearCode() {
        bitField0_ = (bitField0_ & ~0x00000002);
        code_ = 0;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:opentelemetry.proto.mmap.v1.Status)
    }

    // @@protoc_insertion_point(class_scope:opentelemetry.proto.mmap.v1.Status)
    private static final opentelemetry.proto.mmap.v1.Mmap.Status DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new opentelemetry.proto.mmap.v1.Mmap.Status();
    }

    public static opentelemetry.proto.mmap.v1.Mmap.Status getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<Status>
        PARSER = new com.google.protobuf.AbstractParser<Status>() {
      @java.lang.Override
      public Status parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<Status> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<Status> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public opentelemetry.proto.mmap.v1.Mmap.Status getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface MeasurementOrBuilder extends
      // @@protoc_insertion_point(interface_extends:opentelemetry.proto.mmap.v1.Measurement)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Reference to the definitiion of this metric.
     * </pre>
     *
     * <code>int64 metric_ref = 1;</code>
     * @return The metricRef.
     */
    long getMetricRef();

    /**
     * <pre>
     * TODO- use a ref for this?
     * A collection of attribute key/value pairs on the link.
     * Attribute keys MUST be unique (it is not allowed to have more than one
     * attribute with the same key).
     *
     * The attribute values SHOULD NOT contain empty values.
     * The attribute values SHOULD NOT contain bytes values.
     * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
     * double values.
     * The attribute values SHOULD NOT contain kvlist values.
     * The behavior of software that receives attributes containing such values can be unpredictable.
     * These restrictions can change in a minor release.
     * The restrictions take origin from the OpenTelemetry specification:
     * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 2;</code>
     */
    java.util.List<opentelemetry.proto.mmap.v1.Mmap.KeyValueRef> 
        getAttributesList();
    /**
     * <pre>
     * TODO- use a ref for this?
     * A collection of attribute key/value pairs on the link.
     * Attribute keys MUST be unique (it is not allowed to have more than one
     * attribute with the same key).
     *
     * The attribute values SHOULD NOT contain empty values.
     * The attribute values SHOULD NOT contain bytes values.
     * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
     * double values.
     * The attribute values SHOULD NOT contain kvlist values.
     * The behavior of software that receives attributes containing such values can be unpredictable.
     * These restrictions can change in a minor release.
     * The restrictions take origin from the OpenTelemetry specification:
     * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 2;</code>
     */
    opentelemetry.proto.mmap.v1.Mmap.KeyValueRef getAttributes(int index);
    /**
     * <pre>
     * TODO- use a ref for this?
     * A collection of attribute key/value pairs on the link.
     * Attribute keys MUST be unique (it is not allowed to have more than one
     * attribute with the same key).
     *
     * The attribute values SHOULD NOT contain empty values.
     * The attribute values SHOULD NOT contain bytes values.
     * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
     * double values.
     * The attribute values SHOULD NOT contain kvlist values.
     * The behavior of software that receives attributes containing such values can be unpredictable.
     * These restrictions can change in a minor release.
     * The restrictions take origin from the OpenTelemetry specification:
     * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 2;</code>
     */
    int getAttributesCount();
    /**
     * <pre>
     * TODO- use a ref for this?
     * A collection of attribute key/value pairs on the link.
     * Attribute keys MUST be unique (it is not allowed to have more than one
     * attribute with the same key).
     *
     * The attribute values SHOULD NOT contain empty values.
     * The attribute values SHOULD NOT contain bytes values.
     * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
     * double values.
     * The attribute values SHOULD NOT contain kvlist values.
     * The behavior of software that receives attributes containing such values can be unpredictable.
     * These restrictions can change in a minor release.
     * The restrictions take origin from the OpenTelemetry specification:
     * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 2;</code>
     */
    java.util.List<? extends opentelemetry.proto.mmap.v1.Mmap.KeyValueRefOrBuilder> 
        getAttributesOrBuilderList();
    /**
     * <pre>
     * TODO- use a ref for this?
     * A collection of attribute key/value pairs on the link.
     * Attribute keys MUST be unique (it is not allowed to have more than one
     * attribute with the same key).
     *
     * The attribute values SHOULD NOT contain empty values.
     * The attribute values SHOULD NOT contain bytes values.
     * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
     * double values.
     * The attribute values SHOULD NOT contain kvlist values.
     * The behavior of software that receives attributes containing such values can be unpredictable.
     * These restrictions can change in a minor release.
     * The restrictions take origin from the OpenTelemetry specification:
     * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 2;</code>
     */
    opentelemetry.proto.mmap.v1.Mmap.KeyValueRefOrBuilder getAttributesOrBuilder(
        int index);

    /**
     * <pre>
     * Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January
     * 1970.
     * </pre>
     *
     * <code>fixed64 time_unix_nano = 3;</code>
     * @return The timeUnixNano.
     */
    long getTimeUnixNano();

    /**
     * <code>int64 as_long = 4;</code>
     * @return Whether the asLong field is set.
     */
    boolean hasAsLong();
    /**
     * <code>int64 as_long = 4;</code>
     * @return The asLong.
     */
    long getAsLong();

    /**
     * <code>double as_double = 5;</code>
     * @return Whether the asDouble field is set.
     */
    boolean hasAsDouble();
    /**
     * <code>double as_double = 5;</code>
     * @return The asDouble.
     */
    double getAsDouble();

    /**
     * <pre>
     * (optional) Span context information if this measurement was
     * recorded within a span.
     * </pre>
     *
     * <code>.opentelemetry.proto.mmap.v1.SpanContext span_context = 6;</code>
     * @return Whether the spanContext field is set.
     */
    boolean hasSpanContext();
    /**
     * <pre>
     * (optional) Span context information if this measurement was
     * recorded within a span.
     * </pre>
     *
     * <code>.opentelemetry.proto.mmap.v1.SpanContext span_context = 6;</code>
     * @return The spanContext.
     */
    opentelemetry.proto.mmap.v1.Mmap.SpanContext getSpanContext();
    /**
     * <pre>
     * (optional) Span context information if this measurement was
     * recorded within a span.
     * </pre>
     *
     * <code>.opentelemetry.proto.mmap.v1.SpanContext span_context = 6;</code>
     */
    opentelemetry.proto.mmap.v1.Mmap.SpanContextOrBuilder getSpanContextOrBuilder();

    opentelemetry.proto.mmap.v1.Mmap.Measurement.ValueCase getValueCase();
  }
  /**
   * <pre>
   * Passes a single metric measurement from the source to the
   * collector.  This MUST use the metric_ref to determine
   * how to aggregate the measurement into a real OTLP metric.
   * </pre>
   *
   * Protobuf type {@code opentelemetry.proto.mmap.v1.Measurement}
   */
  public static final class Measurement extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:opentelemetry.proto.mmap.v1.Measurement)
      MeasurementOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 33,
        /* patch= */ 0,
        /* suffix= */ "",
        "Measurement");
    }
    // Use Measurement.newBuilder() to construct.
    private Measurement(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private Measurement() {
      attributes_ = java.util.Collections.emptyList();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_Measurement_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_Measurement_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              opentelemetry.proto.mmap.v1.Mmap.Measurement.class, opentelemetry.proto.mmap.v1.Mmap.Measurement.Builder.class);
    }

    private int bitField0_;
    private int valueCase_ = 0;
    @SuppressWarnings("serial")
    private java.lang.Object value_;
    public enum ValueCase
        implements com.google.protobuf.Internal.EnumLite,
            com.google.protobuf.AbstractMessage.InternalOneOfEnum {
      AS_LONG(4),
      AS_DOUBLE(5),
      VALUE_NOT_SET(0);
      private final int value;
      private ValueCase(int value) {
        this.value = value;
      }
      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static ValueCase valueOf(int value) {
        return forNumber(value);
      }

      public static ValueCase forNumber(int value) {
        switch (value) {
          case 4: return AS_LONG;
          case 5: return AS_DOUBLE;
          case 0: return VALUE_NOT_SET;
          default: return null;
        }
      }
      public int getNumber() {
        return this.value;
      }
    };

    public ValueCase
    getValueCase() {
      return ValueCase.forNumber(
          valueCase_);
    }

    public static final int METRIC_REF_FIELD_NUMBER = 1;
    private long metricRef_ = 0L;
    /**
     * <pre>
     * Reference to the definitiion of this metric.
     * </pre>
     *
     * <code>int64 metric_ref = 1;</code>
     * @return The metricRef.
     */
    @java.lang.Override
    public long getMetricRef() {
      return metricRef_;
    }

    public static final int ATTRIBUTES_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private java.util.List<opentelemetry.proto.mmap.v1.Mmap.KeyValueRef> attributes_;
    /**
     * <pre>
     * TODO- use a ref for this?
     * A collection of attribute key/value pairs on the link.
     * Attribute keys MUST be unique (it is not allowed to have more than one
     * attribute with the same key).
     *
     * The attribute values SHOULD NOT contain empty values.
     * The attribute values SHOULD NOT contain bytes values.
     * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
     * double values.
     * The attribute values SHOULD NOT contain kvlist values.
     * The behavior of software that receives attributes containing such values can be unpredictable.
     * These restrictions can change in a minor release.
     * The restrictions take origin from the OpenTelemetry specification:
     * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 2;</code>
     */
    @java.lang.Override
    public java.util.List<opentelemetry.proto.mmap.v1.Mmap.KeyValueRef> getAttributesList() {
      return attributes_;
    }
    /**
     * <pre>
     * TODO- use a ref for this?
     * A collection of attribute key/value pairs on the link.
     * Attribute keys MUST be unique (it is not allowed to have more than one
     * attribute with the same key).
     *
     * The attribute values SHOULD NOT contain empty values.
     * The attribute values SHOULD NOT contain bytes values.
     * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
     * double values.
     * The attribute values SHOULD NOT contain kvlist values.
     * The behavior of software that receives attributes containing such values can be unpredictable.
     * These restrictions can change in a minor release.
     * The restrictions take origin from the OpenTelemetry specification:
     * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 2;</code>
     */
    @java.lang.Override
    public java.util.List<? extends opentelemetry.proto.mmap.v1.Mmap.KeyValueRefOrBuilder> 
        getAttributesOrBuilderList() {
      return attributes_;
    }
    /**
     * <pre>
     * TODO- use a ref for this?
     * A collection of attribute key/value pairs on the link.
     * Attribute keys MUST be unique (it is not allowed to have more than one
     * attribute with the same key).
     *
     * The attribute values SHOULD NOT contain empty values.
     * The attribute values SHOULD NOT contain bytes values.
     * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
     * double values.
     * The attribute values SHOULD NOT contain kvlist values.
     * The behavior of software that receives attributes containing such values can be unpredictable.
     * These restrictions can change in a minor release.
     * The restrictions take origin from the OpenTelemetry specification:
     * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 2;</code>
     */
    @java.lang.Override
    public int getAttributesCount() {
      return attributes_.size();
    }
    /**
     * <pre>
     * TODO- use a ref for this?
     * A collection of attribute key/value pairs on the link.
     * Attribute keys MUST be unique (it is not allowed to have more than one
     * attribute with the same key).
     *
     * The attribute values SHOULD NOT contain empty values.
     * The attribute values SHOULD NOT contain bytes values.
     * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
     * double values.
     * The attribute values SHOULD NOT contain kvlist values.
     * The behavior of software that receives attributes containing such values can be unpredictable.
     * These restrictions can change in a minor release.
     * The restrictions take origin from the OpenTelemetry specification:
     * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 2;</code>
     */
    @java.lang.Override
    public opentelemetry.proto.mmap.v1.Mmap.KeyValueRef getAttributes(int index) {
      return attributes_.get(index);
    }
    /**
     * <pre>
     * TODO- use a ref for this?
     * A collection of attribute key/value pairs on the link.
     * Attribute keys MUST be unique (it is not allowed to have more than one
     * attribute with the same key).
     *
     * The attribute values SHOULD NOT contain empty values.
     * The attribute values SHOULD NOT contain bytes values.
     * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
     * double values.
     * The attribute values SHOULD NOT contain kvlist values.
     * The behavior of software that receives attributes containing such values can be unpredictable.
     * These restrictions can change in a minor release.
     * The restrictions take origin from the OpenTelemetry specification:
     * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 2;</code>
     */
    @java.lang.Override
    public opentelemetry.proto.mmap.v1.Mmap.KeyValueRefOrBuilder getAttributesOrBuilder(
        int index) {
      return attributes_.get(index);
    }

    public static final int TIME_UNIX_NANO_FIELD_NUMBER = 3;
    private long timeUnixNano_ = 0L;
    /**
     * <pre>
     * Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January
     * 1970.
     * </pre>
     *
     * <code>fixed64 time_unix_nano = 3;</code>
     * @return The timeUnixNano.
     */
    @java.lang.Override
    public long getTimeUnixNano() {
      return timeUnixNano_;
    }

    public static final int AS_LONG_FIELD_NUMBER = 4;
    /**
     * <code>int64 as_long = 4;</code>
     * @return Whether the asLong field is set.
     */
    @java.lang.Override
    public boolean hasAsLong() {
      return valueCase_ == 4;
    }
    /**
     * <code>int64 as_long = 4;</code>
     * @return The asLong.
     */
    @java.lang.Override
    public long getAsLong() {
      if (valueCase_ == 4) {
        return (java.lang.Long) value_;
      }
      return 0L;
    }

    public static final int AS_DOUBLE_FIELD_NUMBER = 5;
    /**
     * <code>double as_double = 5;</code>
     * @return Whether the asDouble field is set.
     */
    @java.lang.Override
    public boolean hasAsDouble() {
      return valueCase_ == 5;
    }
    /**
     * <code>double as_double = 5;</code>
     * @return The asDouble.
     */
    @java.lang.Override
    public double getAsDouble() {
      if (valueCase_ == 5) {
        return (java.lang.Double) value_;
      }
      return 0D;
    }

    public static final int SPAN_CONTEXT_FIELD_NUMBER = 6;
    private opentelemetry.proto.mmap.v1.Mmap.SpanContext spanContext_;
    /**
     * <pre>
     * (optional) Span context information if this measurement was
     * recorded within a span.
     * </pre>
     *
     * <code>.opentelemetry.proto.mmap.v1.SpanContext span_context = 6;</code>
     * @return Whether the spanContext field is set.
     */
    @java.lang.Override
    public boolean hasSpanContext() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * (optional) Span context information if this measurement was
     * recorded within a span.
     * </pre>
     *
     * <code>.opentelemetry.proto.mmap.v1.SpanContext span_context = 6;</code>
     * @return The spanContext.
     */
    @java.lang.Override
    public opentelemetry.proto.mmap.v1.Mmap.SpanContext getSpanContext() {
      return spanContext_ == null ? opentelemetry.proto.mmap.v1.Mmap.SpanContext.getDefaultInstance() : spanContext_;
    }
    /**
     * <pre>
     * (optional) Span context information if this measurement was
     * recorded within a span.
     * </pre>
     *
     * <code>.opentelemetry.proto.mmap.v1.SpanContext span_context = 6;</code>
     */
    @java.lang.Override
    public opentelemetry.proto.mmap.v1.Mmap.SpanContextOrBuilder getSpanContextOrBuilder() {
      return spanContext_ == null ? opentelemetry.proto.mmap.v1.Mmap.SpanContext.getDefaultInstance() : spanContext_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (metricRef_ != 0L) {
        output.writeInt64(1, metricRef_);
      }
      for (int i = 0; i < attributes_.size(); i++) {
        output.writeMessage(2, attributes_.get(i));
      }
      if (timeUnixNano_ != 0L) {
        output.writeFixed64(3, timeUnixNano_);
      }
      if (valueCase_ == 4) {
        output.writeInt64(
            4, (long)((java.lang.Long) value_));
      }
      if (valueCase_ == 5) {
        output.writeDouble(
            5, (double)((java.lang.Double) value_));
      }
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeMessage(6, getSpanContext());
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (metricRef_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(1, metricRef_);
      }
      for (int i = 0; i < attributes_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, attributes_.get(i));
      }
      if (timeUnixNano_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeFixed64Size(3, timeUnixNano_);
      }
      if (valueCase_ == 4) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(
              4, (long)((java.lang.Long) value_));
      }
      if (valueCase_ == 5) {
        size += com.google.protobuf.CodedOutputStream
          .computeDoubleSize(
              5, (double)((java.lang.Double) value_));
      }
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(6, getSpanContext());
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof opentelemetry.proto.mmap.v1.Mmap.Measurement)) {
        return super.equals(obj);
      }
      opentelemetry.proto.mmap.v1.Mmap.Measurement other = (opentelemetry.proto.mmap.v1.Mmap.Measurement) obj;

      if (getMetricRef()
          != other.getMetricRef()) return false;
      if (!getAttributesList()
          .equals(other.getAttributesList())) return false;
      if (getTimeUnixNano()
          != other.getTimeUnixNano()) return false;
      if (hasSpanContext() != other.hasSpanContext()) return false;
      if (hasSpanContext()) {
        if (!getSpanContext()
            .equals(other.getSpanContext())) return false;
      }
      if (!getValueCase().equals(other.getValueCase())) return false;
      switch (valueCase_) {
        case 4:
          if (getAsLong()
              != other.getAsLong()) return false;
          break;
        case 5:
          if (java.lang.Double.doubleToLongBits(getAsDouble())
              != java.lang.Double.doubleToLongBits(
                  other.getAsDouble())) return false;
          break;
        case 0:
        default:
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + METRIC_REF_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getMetricRef());
      if (getAttributesCount() > 0) {
        hash = (37 * hash) + ATTRIBUTES_FIELD_NUMBER;
        hash = (53 * hash) + getAttributesList().hashCode();
      }
      hash = (37 * hash) + TIME_UNIX_NANO_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getTimeUnixNano());
      if (hasSpanContext()) {
        hash = (37 * hash) + SPAN_CONTEXT_FIELD_NUMBER;
        hash = (53 * hash) + getSpanContext().hashCode();
      }
      switch (valueCase_) {
        case 4:
          hash = (37 * hash) + AS_LONG_FIELD_NUMBER;
          hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
              getAsLong());
          break;
        case 5:
          hash = (37 * hash) + AS_DOUBLE_FIELD_NUMBER;
          hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
              java.lang.Double.doubleToLongBits(getAsDouble()));
          break;
        case 0:
        default:
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static opentelemetry.proto.mmap.v1.Mmap.Measurement parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.Measurement parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.Measurement parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.Measurement parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.Measurement parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.Measurement parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.Measurement parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.Measurement parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static opentelemetry.proto.mmap.v1.Mmap.Measurement parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static opentelemetry.proto.mmap.v1.Mmap.Measurement parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.Measurement parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.Measurement parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(opentelemetry.proto.mmap.v1.Mmap.Measurement prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Passes a single metric measurement from the source to the
     * collector.  This MUST use the metric_ref to determine
     * how to aggregate the measurement into a real OTLP metric.
     * </pre>
     *
     * Protobuf type {@code opentelemetry.proto.mmap.v1.Measurement}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:opentelemetry.proto.mmap.v1.Measurement)
        opentelemetry.proto.mmap.v1.Mmap.MeasurementOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_Measurement_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_Measurement_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                opentelemetry.proto.mmap.v1.Mmap.Measurement.class, opentelemetry.proto.mmap.v1.Mmap.Measurement.Builder.class);
      }

      // Construct using opentelemetry.proto.mmap.v1.Mmap.Measurement.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage
                .alwaysUseFieldBuilders) {
          internalGetAttributesFieldBuilder();
          internalGetSpanContextFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        metricRef_ = 0L;
        if (attributesBuilder_ == null) {
          attributes_ = java.util.Collections.emptyList();
        } else {
          attributes_ = null;
          attributesBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        timeUnixNano_ = 0L;
        spanContext_ = null;
        if (spanContextBuilder_ != null) {
          spanContextBuilder_.dispose();
          spanContextBuilder_ = null;
        }
        valueCase_ = 0;
        value_ = null;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_Measurement_descriptor;
      }

      @java.lang.Override
      public opentelemetry.proto.mmap.v1.Mmap.Measurement getDefaultInstanceForType() {
        return opentelemetry.proto.mmap.v1.Mmap.Measurement.getDefaultInstance();
      }

      @java.lang.Override
      public opentelemetry.proto.mmap.v1.Mmap.Measurement build() {
        opentelemetry.proto.mmap.v1.Mmap.Measurement result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public opentelemetry.proto.mmap.v1.Mmap.Measurement buildPartial() {
        opentelemetry.proto.mmap.v1.Mmap.Measurement result = new opentelemetry.proto.mmap.v1.Mmap.Measurement(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        buildPartialOneofs(result);
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(opentelemetry.proto.mmap.v1.Mmap.Measurement result) {
        if (attributesBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0)) {
            attributes_ = java.util.Collections.unmodifiableList(attributes_);
            bitField0_ = (bitField0_ & ~0x00000002);
          }
          result.attributes_ = attributes_;
        } else {
          result.attributes_ = attributesBuilder_.build();
        }
      }

      private void buildPartial0(opentelemetry.proto.mmap.v1.Mmap.Measurement result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.metricRef_ = metricRef_;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.timeUnixNano_ = timeUnixNano_;
        }
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000020) != 0)) {
          result.spanContext_ = spanContextBuilder_ == null
              ? spanContext_
              : spanContextBuilder_.build();
          to_bitField0_ |= 0x00000001;
        }
        result.bitField0_ |= to_bitField0_;
      }

      private void buildPartialOneofs(opentelemetry.proto.mmap.v1.Mmap.Measurement result) {
        result.valueCase_ = valueCase_;
        result.value_ = this.value_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof opentelemetry.proto.mmap.v1.Mmap.Measurement) {
          return mergeFrom((opentelemetry.proto.mmap.v1.Mmap.Measurement)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(opentelemetry.proto.mmap.v1.Mmap.Measurement other) {
        if (other == opentelemetry.proto.mmap.v1.Mmap.Measurement.getDefaultInstance()) return this;
        if (other.getMetricRef() != 0L) {
          setMetricRef(other.getMetricRef());
        }
        if (attributesBuilder_ == null) {
          if (!other.attributes_.isEmpty()) {
            if (attributes_.isEmpty()) {
              attributes_ = other.attributes_;
              bitField0_ = (bitField0_ & ~0x00000002);
            } else {
              ensureAttributesIsMutable();
              attributes_.addAll(other.attributes_);
            }
            onChanged();
          }
        } else {
          if (!other.attributes_.isEmpty()) {
            if (attributesBuilder_.isEmpty()) {
              attributesBuilder_.dispose();
              attributesBuilder_ = null;
              attributes_ = other.attributes_;
              bitField0_ = (bitField0_ & ~0x00000002);
              attributesBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   internalGetAttributesFieldBuilder() : null;
            } else {
              attributesBuilder_.addAllMessages(other.attributes_);
            }
          }
        }
        if (other.getTimeUnixNano() != 0L) {
          setTimeUnixNano(other.getTimeUnixNano());
        }
        if (other.hasSpanContext()) {
          mergeSpanContext(other.getSpanContext());
        }
        switch (other.getValueCase()) {
          case AS_LONG: {
            setAsLong(other.getAsLong());
            break;
          }
          case AS_DOUBLE: {
            setAsDouble(other.getAsDouble());
            break;
          }
          case VALUE_NOT_SET: {
            break;
          }
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8: {
                metricRef_ = input.readInt64();
                bitField0_ |= 0x00000001;
                break;
              } // case 8
              case 18: {
                opentelemetry.proto.mmap.v1.Mmap.KeyValueRef m =
                    input.readMessage(
                        opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.parser(),
                        extensionRegistry);
                if (attributesBuilder_ == null) {
                  ensureAttributesIsMutable();
                  attributes_.add(m);
                } else {
                  attributesBuilder_.addMessage(m);
                }
                break;
              } // case 18
              case 25: {
                timeUnixNano_ = input.readFixed64();
                bitField0_ |= 0x00000004;
                break;
              } // case 25
              case 32: {
                value_ = input.readInt64();
                valueCase_ = 4;
                break;
              } // case 32
              case 41: {
                value_ = input.readDouble();
                valueCase_ = 5;
                break;
              } // case 41
              case 50: {
                input.readMessage(
                    internalGetSpanContextFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000020;
                break;
              } // case 50
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int valueCase_ = 0;
      private java.lang.Object value_;
      public ValueCase
          getValueCase() {
        return ValueCase.forNumber(
            valueCase_);
      }

      public Builder clearValue() {
        valueCase_ = 0;
        value_ = null;
        onChanged();
        return this;
      }

      private int bitField0_;

      private long metricRef_ ;
      /**
       * <pre>
       * Reference to the definitiion of this metric.
       * </pre>
       *
       * <code>int64 metric_ref = 1;</code>
       * @return The metricRef.
       */
      @java.lang.Override
      public long getMetricRef() {
        return metricRef_;
      }
      /**
       * <pre>
       * Reference to the definitiion of this metric.
       * </pre>
       *
       * <code>int64 metric_ref = 1;</code>
       * @param value The metricRef to set.
       * @return This builder for chaining.
       */
      public Builder setMetricRef(long value) {

        metricRef_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Reference to the definitiion of this metric.
       * </pre>
       *
       * <code>int64 metric_ref = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearMetricRef() {
        bitField0_ = (bitField0_ & ~0x00000001);
        metricRef_ = 0L;
        onChanged();
        return this;
      }

      private java.util.List<opentelemetry.proto.mmap.v1.Mmap.KeyValueRef> attributes_ =
        java.util.Collections.emptyList();
      private void ensureAttributesIsMutable() {
        if (!((bitField0_ & 0x00000002) != 0)) {
          attributes_ = new java.util.ArrayList<opentelemetry.proto.mmap.v1.Mmap.KeyValueRef>(attributes_);
          bitField0_ |= 0x00000002;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          opentelemetry.proto.mmap.v1.Mmap.KeyValueRef, opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.Builder, opentelemetry.proto.mmap.v1.Mmap.KeyValueRefOrBuilder> attributesBuilder_;

      /**
       * <pre>
       * TODO- use a ref for this?
       * A collection of attribute key/value pairs on the link.
       * Attribute keys MUST be unique (it is not allowed to have more than one
       * attribute with the same key).
       *
       * The attribute values SHOULD NOT contain empty values.
       * The attribute values SHOULD NOT contain bytes values.
       * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
       * double values.
       * The attribute values SHOULD NOT contain kvlist values.
       * The behavior of software that receives attributes containing such values can be unpredictable.
       * These restrictions can change in a minor release.
       * The restrictions take origin from the OpenTelemetry specification:
       * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 2;</code>
       */
      public java.util.List<opentelemetry.proto.mmap.v1.Mmap.KeyValueRef> getAttributesList() {
        if (attributesBuilder_ == null) {
          return java.util.Collections.unmodifiableList(attributes_);
        } else {
          return attributesBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * TODO- use a ref for this?
       * A collection of attribute key/value pairs on the link.
       * Attribute keys MUST be unique (it is not allowed to have more than one
       * attribute with the same key).
       *
       * The attribute values SHOULD NOT contain empty values.
       * The attribute values SHOULD NOT contain bytes values.
       * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
       * double values.
       * The attribute values SHOULD NOT contain kvlist values.
       * The behavior of software that receives attributes containing such values can be unpredictable.
       * These restrictions can change in a minor release.
       * The restrictions take origin from the OpenTelemetry specification:
       * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 2;</code>
       */
      public int getAttributesCount() {
        if (attributesBuilder_ == null) {
          return attributes_.size();
        } else {
          return attributesBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * TODO- use a ref for this?
       * A collection of attribute key/value pairs on the link.
       * Attribute keys MUST be unique (it is not allowed to have more than one
       * attribute with the same key).
       *
       * The attribute values SHOULD NOT contain empty values.
       * The attribute values SHOULD NOT contain bytes values.
       * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
       * double values.
       * The attribute values SHOULD NOT contain kvlist values.
       * The behavior of software that receives attributes containing such values can be unpredictable.
       * These restrictions can change in a minor release.
       * The restrictions take origin from the OpenTelemetry specification:
       * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 2;</code>
       */
      public opentelemetry.proto.mmap.v1.Mmap.KeyValueRef getAttributes(int index) {
        if (attributesBuilder_ == null) {
          return attributes_.get(index);
        } else {
          return attributesBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * TODO- use a ref for this?
       * A collection of attribute key/value pairs on the link.
       * Attribute keys MUST be unique (it is not allowed to have more than one
       * attribute with the same key).
       *
       * The attribute values SHOULD NOT contain empty values.
       * The attribute values SHOULD NOT contain bytes values.
       * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
       * double values.
       * The attribute values SHOULD NOT contain kvlist values.
       * The behavior of software that receives attributes containing such values can be unpredictable.
       * These restrictions can change in a minor release.
       * The restrictions take origin from the OpenTelemetry specification:
       * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 2;</code>
       */
      public Builder setAttributes(
          int index, opentelemetry.proto.mmap.v1.Mmap.KeyValueRef value) {
        if (attributesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureAttributesIsMutable();
          attributes_.set(index, value);
          onChanged();
        } else {
          attributesBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * TODO- use a ref for this?
       * A collection of attribute key/value pairs on the link.
       * Attribute keys MUST be unique (it is not allowed to have more than one
       * attribute with the same key).
       *
       * The attribute values SHOULD NOT contain empty values.
       * The attribute values SHOULD NOT contain bytes values.
       * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
       * double values.
       * The attribute values SHOULD NOT contain kvlist values.
       * The behavior of software that receives attributes containing such values can be unpredictable.
       * These restrictions can change in a minor release.
       * The restrictions take origin from the OpenTelemetry specification:
       * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 2;</code>
       */
      public Builder setAttributes(
          int index, opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.Builder builderForValue) {
        if (attributesBuilder_ == null) {
          ensureAttributesIsMutable();
          attributes_.set(index, builderForValue.build());
          onChanged();
        } else {
          attributesBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * TODO- use a ref for this?
       * A collection of attribute key/value pairs on the link.
       * Attribute keys MUST be unique (it is not allowed to have more than one
       * attribute with the same key).
       *
       * The attribute values SHOULD NOT contain empty values.
       * The attribute values SHOULD NOT contain bytes values.
       * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
       * double values.
       * The attribute values SHOULD NOT contain kvlist values.
       * The behavior of software that receives attributes containing such values can be unpredictable.
       * These restrictions can change in a minor release.
       * The restrictions take origin from the OpenTelemetry specification:
       * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 2;</code>
       */
      public Builder addAttributes(opentelemetry.proto.mmap.v1.Mmap.KeyValueRef value) {
        if (attributesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureAttributesIsMutable();
          attributes_.add(value);
          onChanged();
        } else {
          attributesBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * TODO- use a ref for this?
       * A collection of attribute key/value pairs on the link.
       * Attribute keys MUST be unique (it is not allowed to have more than one
       * attribute with the same key).
       *
       * The attribute values SHOULD NOT contain empty values.
       * The attribute values SHOULD NOT contain bytes values.
       * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
       * double values.
       * The attribute values SHOULD NOT contain kvlist values.
       * The behavior of software that receives attributes containing such values can be unpredictable.
       * These restrictions can change in a minor release.
       * The restrictions take origin from the OpenTelemetry specification:
       * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 2;</code>
       */
      public Builder addAttributes(
          int index, opentelemetry.proto.mmap.v1.Mmap.KeyValueRef value) {
        if (attributesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureAttributesIsMutable();
          attributes_.add(index, value);
          onChanged();
        } else {
          attributesBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * TODO- use a ref for this?
       * A collection of attribute key/value pairs on the link.
       * Attribute keys MUST be unique (it is not allowed to have more than one
       * attribute with the same key).
       *
       * The attribute values SHOULD NOT contain empty values.
       * The attribute values SHOULD NOT contain bytes values.
       * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
       * double values.
       * The attribute values SHOULD NOT contain kvlist values.
       * The behavior of software that receives attributes containing such values can be unpredictable.
       * These restrictions can change in a minor release.
       * The restrictions take origin from the OpenTelemetry specification:
       * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 2;</code>
       */
      public Builder addAttributes(
          opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.Builder builderForValue) {
        if (attributesBuilder_ == null) {
          ensureAttributesIsMutable();
          attributes_.add(builderForValue.build());
          onChanged();
        } else {
          attributesBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * TODO- use a ref for this?
       * A collection of attribute key/value pairs on the link.
       * Attribute keys MUST be unique (it is not allowed to have more than one
       * attribute with the same key).
       *
       * The attribute values SHOULD NOT contain empty values.
       * The attribute values SHOULD NOT contain bytes values.
       * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
       * double values.
       * The attribute values SHOULD NOT contain kvlist values.
       * The behavior of software that receives attributes containing such values can be unpredictable.
       * These restrictions can change in a minor release.
       * The restrictions take origin from the OpenTelemetry specification:
       * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 2;</code>
       */
      public Builder addAttributes(
          int index, opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.Builder builderForValue) {
        if (attributesBuilder_ == null) {
          ensureAttributesIsMutable();
          attributes_.add(index, builderForValue.build());
          onChanged();
        } else {
          attributesBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * TODO- use a ref for this?
       * A collection of attribute key/value pairs on the link.
       * Attribute keys MUST be unique (it is not allowed to have more than one
       * attribute with the same key).
       *
       * The attribute values SHOULD NOT contain empty values.
       * The attribute values SHOULD NOT contain bytes values.
       * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
       * double values.
       * The attribute values SHOULD NOT contain kvlist values.
       * The behavior of software that receives attributes containing such values can be unpredictable.
       * These restrictions can change in a minor release.
       * The restrictions take origin from the OpenTelemetry specification:
       * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 2;</code>
       */
      public Builder addAllAttributes(
          java.lang.Iterable<? extends opentelemetry.proto.mmap.v1.Mmap.KeyValueRef> values) {
        if (attributesBuilder_ == null) {
          ensureAttributesIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, attributes_);
          onChanged();
        } else {
          attributesBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * TODO- use a ref for this?
       * A collection of attribute key/value pairs on the link.
       * Attribute keys MUST be unique (it is not allowed to have more than one
       * attribute with the same key).
       *
       * The attribute values SHOULD NOT contain empty values.
       * The attribute values SHOULD NOT contain bytes values.
       * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
       * double values.
       * The attribute values SHOULD NOT contain kvlist values.
       * The behavior of software that receives attributes containing such values can be unpredictable.
       * These restrictions can change in a minor release.
       * The restrictions take origin from the OpenTelemetry specification:
       * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 2;</code>
       */
      public Builder clearAttributes() {
        if (attributesBuilder_ == null) {
          attributes_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
        } else {
          attributesBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * TODO- use a ref for this?
       * A collection of attribute key/value pairs on the link.
       * Attribute keys MUST be unique (it is not allowed to have more than one
       * attribute with the same key).
       *
       * The attribute values SHOULD NOT contain empty values.
       * The attribute values SHOULD NOT contain bytes values.
       * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
       * double values.
       * The attribute values SHOULD NOT contain kvlist values.
       * The behavior of software that receives attributes containing such values can be unpredictable.
       * These restrictions can change in a minor release.
       * The restrictions take origin from the OpenTelemetry specification:
       * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 2;</code>
       */
      public Builder removeAttributes(int index) {
        if (attributesBuilder_ == null) {
          ensureAttributesIsMutable();
          attributes_.remove(index);
          onChanged();
        } else {
          attributesBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * TODO- use a ref for this?
       * A collection of attribute key/value pairs on the link.
       * Attribute keys MUST be unique (it is not allowed to have more than one
       * attribute with the same key).
       *
       * The attribute values SHOULD NOT contain empty values.
       * The attribute values SHOULD NOT contain bytes values.
       * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
       * double values.
       * The attribute values SHOULD NOT contain kvlist values.
       * The behavior of software that receives attributes containing such values can be unpredictable.
       * These restrictions can change in a minor release.
       * The restrictions take origin from the OpenTelemetry specification:
       * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 2;</code>
       */
      public opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.Builder getAttributesBuilder(
          int index) {
        return internalGetAttributesFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * TODO- use a ref for this?
       * A collection of attribute key/value pairs on the link.
       * Attribute keys MUST be unique (it is not allowed to have more than one
       * attribute with the same key).
       *
       * The attribute values SHOULD NOT contain empty values.
       * The attribute values SHOULD NOT contain bytes values.
       * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
       * double values.
       * The attribute values SHOULD NOT contain kvlist values.
       * The behavior of software that receives attributes containing such values can be unpredictable.
       * These restrictions can change in a minor release.
       * The restrictions take origin from the OpenTelemetry specification:
       * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 2;</code>
       */
      public opentelemetry.proto.mmap.v1.Mmap.KeyValueRefOrBuilder getAttributesOrBuilder(
          int index) {
        if (attributesBuilder_ == null) {
          return attributes_.get(index);  } else {
          return attributesBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * TODO- use a ref for this?
       * A collection of attribute key/value pairs on the link.
       * Attribute keys MUST be unique (it is not allowed to have more than one
       * attribute with the same key).
       *
       * The attribute values SHOULD NOT contain empty values.
       * The attribute values SHOULD NOT contain bytes values.
       * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
       * double values.
       * The attribute values SHOULD NOT contain kvlist values.
       * The behavior of software that receives attributes containing such values can be unpredictable.
       * These restrictions can change in a minor release.
       * The restrictions take origin from the OpenTelemetry specification:
       * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 2;</code>
       */
      public java.util.List<? extends opentelemetry.proto.mmap.v1.Mmap.KeyValueRefOrBuilder> 
           getAttributesOrBuilderList() {
        if (attributesBuilder_ != null) {
          return attributesBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(attributes_);
        }
      }
      /**
       * <pre>
       * TODO- use a ref for this?
       * A collection of attribute key/value pairs on the link.
       * Attribute keys MUST be unique (it is not allowed to have more than one
       * attribute with the same key).
       *
       * The attribute values SHOULD NOT contain empty values.
       * The attribute values SHOULD NOT contain bytes values.
       * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
       * double values.
       * The attribute values SHOULD NOT contain kvlist values.
       * The behavior of software that receives attributes containing such values can be unpredictable.
       * These restrictions can change in a minor release.
       * The restrictions take origin from the OpenTelemetry specification:
       * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 2;</code>
       */
      public opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.Builder addAttributesBuilder() {
        return internalGetAttributesFieldBuilder().addBuilder(
            opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.getDefaultInstance());
      }
      /**
       * <pre>
       * TODO- use a ref for this?
       * A collection of attribute key/value pairs on the link.
       * Attribute keys MUST be unique (it is not allowed to have more than one
       * attribute with the same key).
       *
       * The attribute values SHOULD NOT contain empty values.
       * The attribute values SHOULD NOT contain bytes values.
       * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
       * double values.
       * The attribute values SHOULD NOT contain kvlist values.
       * The behavior of software that receives attributes containing such values can be unpredictable.
       * These restrictions can change in a minor release.
       * The restrictions take origin from the OpenTelemetry specification:
       * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 2;</code>
       */
      public opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.Builder addAttributesBuilder(
          int index) {
        return internalGetAttributesFieldBuilder().addBuilder(
            index, opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.getDefaultInstance());
      }
      /**
       * <pre>
       * TODO- use a ref for this?
       * A collection of attribute key/value pairs on the link.
       * Attribute keys MUST be unique (it is not allowed to have more than one
       * attribute with the same key).
       *
       * The attribute values SHOULD NOT contain empty values.
       * The attribute values SHOULD NOT contain bytes values.
       * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
       * double values.
       * The attribute values SHOULD NOT contain kvlist values.
       * The behavior of software that receives attributes containing such values can be unpredictable.
       * These restrictions can change in a minor release.
       * The restrictions take origin from the OpenTelemetry specification:
       * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 2;</code>
       */
      public java.util.List<opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.Builder> 
           getAttributesBuilderList() {
        return internalGetAttributesFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          opentelemetry.proto.mmap.v1.Mmap.KeyValueRef, opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.Builder, opentelemetry.proto.mmap.v1.Mmap.KeyValueRefOrBuilder> 
          internalGetAttributesFieldBuilder() {
        if (attributesBuilder_ == null) {
          attributesBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              opentelemetry.proto.mmap.v1.Mmap.KeyValueRef, opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.Builder, opentelemetry.proto.mmap.v1.Mmap.KeyValueRefOrBuilder>(
                  attributes_,
                  ((bitField0_ & 0x00000002) != 0),
                  getParentForChildren(),
                  isClean());
          attributes_ = null;
        }
        return attributesBuilder_;
      }

      private long timeUnixNano_ ;
      /**
       * <pre>
       * Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January
       * 1970.
       * </pre>
       *
       * <code>fixed64 time_unix_nano = 3;</code>
       * @return The timeUnixNano.
       */
      @java.lang.Override
      public long getTimeUnixNano() {
        return timeUnixNano_;
      }
      /**
       * <pre>
       * Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January
       * 1970.
       * </pre>
       *
       * <code>fixed64 time_unix_nano = 3;</code>
       * @param value The timeUnixNano to set.
       * @return This builder for chaining.
       */
      public Builder setTimeUnixNano(long value) {

        timeUnixNano_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January
       * 1970.
       * </pre>
       *
       * <code>fixed64 time_unix_nano = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearTimeUnixNano() {
        bitField0_ = (bitField0_ & ~0x00000004);
        timeUnixNano_ = 0L;
        onChanged();
        return this;
      }

      /**
       * <code>int64 as_long = 4;</code>
       * @return Whether the asLong field is set.
       */
      public boolean hasAsLong() {
        return valueCase_ == 4;
      }
      /**
       * <code>int64 as_long = 4;</code>
       * @return The asLong.
       */
      public long getAsLong() {
        if (valueCase_ == 4) {
          return (java.lang.Long) value_;
        }
        return 0L;
      }
      /**
       * <code>int64 as_long = 4;</code>
       * @param value The asLong to set.
       * @return This builder for chaining.
       */
      public Builder setAsLong(long value) {

        valueCase_ = 4;
        value_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>int64 as_long = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearAsLong() {
        if (valueCase_ == 4) {
          valueCase_ = 0;
          value_ = null;
          onChanged();
        }
        return this;
      }

      /**
       * <code>double as_double = 5;</code>
       * @return Whether the asDouble field is set.
       */
      public boolean hasAsDouble() {
        return valueCase_ == 5;
      }
      /**
       * <code>double as_double = 5;</code>
       * @return The asDouble.
       */
      public double getAsDouble() {
        if (valueCase_ == 5) {
          return (java.lang.Double) value_;
        }
        return 0D;
      }
      /**
       * <code>double as_double = 5;</code>
       * @param value The asDouble to set.
       * @return This builder for chaining.
       */
      public Builder setAsDouble(double value) {

        valueCase_ = 5;
        value_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>double as_double = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearAsDouble() {
        if (valueCase_ == 5) {
          valueCase_ = 0;
          value_ = null;
          onChanged();
        }
        return this;
      }

      private opentelemetry.proto.mmap.v1.Mmap.SpanContext spanContext_;
      private com.google.protobuf.SingleFieldBuilder<
          opentelemetry.proto.mmap.v1.Mmap.SpanContext, opentelemetry.proto.mmap.v1.Mmap.SpanContext.Builder, opentelemetry.proto.mmap.v1.Mmap.SpanContextOrBuilder> spanContextBuilder_;
      /**
       * <pre>
       * (optional) Span context information if this measurement was
       * recorded within a span.
       * </pre>
       *
       * <code>.opentelemetry.proto.mmap.v1.SpanContext span_context = 6;</code>
       * @return Whether the spanContext field is set.
       */
      public boolean hasSpanContext() {
        return ((bitField0_ & 0x00000020) != 0);
      }
      /**
       * <pre>
       * (optional) Span context information if this measurement was
       * recorded within a span.
       * </pre>
       *
       * <code>.opentelemetry.proto.mmap.v1.SpanContext span_context = 6;</code>
       * @return The spanContext.
       */
      public opentelemetry.proto.mmap.v1.Mmap.SpanContext getSpanContext() {
        if (spanContextBuilder_ == null) {
          return spanContext_ == null ? opentelemetry.proto.mmap.v1.Mmap.SpanContext.getDefaultInstance() : spanContext_;
        } else {
          return spanContextBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * (optional) Span context information if this measurement was
       * recorded within a span.
       * </pre>
       *
       * <code>.opentelemetry.proto.mmap.v1.SpanContext span_context = 6;</code>
       */
      public Builder setSpanContext(opentelemetry.proto.mmap.v1.Mmap.SpanContext value) {
        if (spanContextBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          spanContext_ = value;
        } else {
          spanContextBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * (optional) Span context information if this measurement was
       * recorded within a span.
       * </pre>
       *
       * <code>.opentelemetry.proto.mmap.v1.SpanContext span_context = 6;</code>
       */
      public Builder setSpanContext(
          opentelemetry.proto.mmap.v1.Mmap.SpanContext.Builder builderForValue) {
        if (spanContextBuilder_ == null) {
          spanContext_ = builderForValue.build();
        } else {
          spanContextBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * (optional) Span context information if this measurement was
       * recorded within a span.
       * </pre>
       *
       * <code>.opentelemetry.proto.mmap.v1.SpanContext span_context = 6;</code>
       */
      public Builder mergeSpanContext(opentelemetry.proto.mmap.v1.Mmap.SpanContext value) {
        if (spanContextBuilder_ == null) {
          if (((bitField0_ & 0x00000020) != 0) &&
            spanContext_ != null &&
            spanContext_ != opentelemetry.proto.mmap.v1.Mmap.SpanContext.getDefaultInstance()) {
            getSpanContextBuilder().mergeFrom(value);
          } else {
            spanContext_ = value;
          }
        } else {
          spanContextBuilder_.mergeFrom(value);
        }
        if (spanContext_ != null) {
          bitField0_ |= 0x00000020;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * (optional) Span context information if this measurement was
       * recorded within a span.
       * </pre>
       *
       * <code>.opentelemetry.proto.mmap.v1.SpanContext span_context = 6;</code>
       */
      public Builder clearSpanContext() {
        bitField0_ = (bitField0_ & ~0x00000020);
        spanContext_ = null;
        if (spanContextBuilder_ != null) {
          spanContextBuilder_.dispose();
          spanContextBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * (optional) Span context information if this measurement was
       * recorded within a span.
       * </pre>
       *
       * <code>.opentelemetry.proto.mmap.v1.SpanContext span_context = 6;</code>
       */
      public opentelemetry.proto.mmap.v1.Mmap.SpanContext.Builder getSpanContextBuilder() {
        bitField0_ |= 0x00000020;
        onChanged();
        return internalGetSpanContextFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * (optional) Span context information if this measurement was
       * recorded within a span.
       * </pre>
       *
       * <code>.opentelemetry.proto.mmap.v1.SpanContext span_context = 6;</code>
       */
      public opentelemetry.proto.mmap.v1.Mmap.SpanContextOrBuilder getSpanContextOrBuilder() {
        if (spanContextBuilder_ != null) {
          return spanContextBuilder_.getMessageOrBuilder();
        } else {
          return spanContext_ == null ?
              opentelemetry.proto.mmap.v1.Mmap.SpanContext.getDefaultInstance() : spanContext_;
        }
      }
      /**
       * <pre>
       * (optional) Span context information if this measurement was
       * recorded within a span.
       * </pre>
       *
       * <code>.opentelemetry.proto.mmap.v1.SpanContext span_context = 6;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          opentelemetry.proto.mmap.v1.Mmap.SpanContext, opentelemetry.proto.mmap.v1.Mmap.SpanContext.Builder, opentelemetry.proto.mmap.v1.Mmap.SpanContextOrBuilder> 
          internalGetSpanContextFieldBuilder() {
        if (spanContextBuilder_ == null) {
          spanContextBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              opentelemetry.proto.mmap.v1.Mmap.SpanContext, opentelemetry.proto.mmap.v1.Mmap.SpanContext.Builder, opentelemetry.proto.mmap.v1.Mmap.SpanContextOrBuilder>(
                  getSpanContext(),
                  getParentForChildren(),
                  isClean());
          spanContext_ = null;
        }
        return spanContextBuilder_;
      }

      // @@protoc_insertion_point(builder_scope:opentelemetry.proto.mmap.v1.Measurement)
    }

    // @@protoc_insertion_point(class_scope:opentelemetry.proto.mmap.v1.Measurement)
    private static final opentelemetry.proto.mmap.v1.Mmap.Measurement DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new opentelemetry.proto.mmap.v1.Mmap.Measurement();
    }

    public static opentelemetry.proto.mmap.v1.Mmap.Measurement getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<Measurement>
        PARSER = new com.google.protobuf.AbstractParser<Measurement>() {
      @java.lang.Override
      public Measurement parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<Measurement> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<Measurement> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public opentelemetry.proto.mmap.v1.Mmap.Measurement getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface MetricRefOrBuilder extends
      // @@protoc_insertion_point(interface_extends:opentelemetry.proto.mmap.v1.MetricRef)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The name of the metric.
     * </pre>
     *
     * <code>string name = 1;</code>
     * @return The name.
     */
    java.lang.String getName();
    /**
     * <pre>
     * The name of the metric.
     * </pre>
     *
     * <code>string name = 1;</code>
     * @return The bytes for name.
     */
    com.google.protobuf.ByteString
        getNameBytes();

    /**
     * <pre>
     * A description of the metric, which can be used in documentation.
     * </pre>
     *
     * <code>string description = 2;</code>
     * @return The description.
     */
    java.lang.String getDescription();
    /**
     * <pre>
     * A description of the metric, which can be used in documentation.
     * </pre>
     *
     * <code>string description = 2;</code>
     * @return The bytes for description.
     */
    com.google.protobuf.ByteString
        getDescriptionBytes();

    /**
     * <pre>
     * The unit in which the metric value is reported. Follows the format
     * described by https://unitsofmeasure.org/ucum.html.
     * </pre>
     *
     * <code>string unit = 3;</code>
     * @return The unit.
     */
    java.lang.String getUnit();
    /**
     * <pre>
     * The unit in which the metric value is reported. Follows the format
     * described by https://unitsofmeasure.org/ucum.html.
     * </pre>
     *
     * <code>string unit = 3;</code>
     * @return The bytes for unit.
     */
    com.google.protobuf.ByteString
        getUnitBytes();

    /**
     * <pre>
     * Reference to the instrumentation scope where this metric is defined.
     * </pre>
     *
     * <code>int64 instrumentation_scope_ref = 4;</code>
     * @return The instrumentationScopeRef.
     */
    long getInstrumentationScopeRef();

    /**
     * <code>.opentelemetry.proto.mmap.v1.MetricRef.Gauge gauge = 5;</code>
     * @return Whether the gauge field is set.
     */
    boolean hasGauge();
    /**
     * <code>.opentelemetry.proto.mmap.v1.MetricRef.Gauge gauge = 5;</code>
     * @return The gauge.
     */
    opentelemetry.proto.mmap.v1.Mmap.MetricRef.Gauge getGauge();
    /**
     * <code>.opentelemetry.proto.mmap.v1.MetricRef.Gauge gauge = 5;</code>
     */
    opentelemetry.proto.mmap.v1.Mmap.MetricRef.GaugeOrBuilder getGaugeOrBuilder();

    /**
     * <code>.opentelemetry.proto.mmap.v1.MetricRef.Sum sum = 6;</code>
     * @return Whether the sum field is set.
     */
    boolean hasSum();
    /**
     * <code>.opentelemetry.proto.mmap.v1.MetricRef.Sum sum = 6;</code>
     * @return The sum.
     */
    opentelemetry.proto.mmap.v1.Mmap.MetricRef.Sum getSum();
    /**
     * <code>.opentelemetry.proto.mmap.v1.MetricRef.Sum sum = 6;</code>
     */
    opentelemetry.proto.mmap.v1.Mmap.MetricRef.SumOrBuilder getSumOrBuilder();

    /**
     * <code>.opentelemetry.proto.mmap.v1.MetricRef.Histogram histogram = 7;</code>
     * @return Whether the histogram field is set.
     */
    boolean hasHistogram();
    /**
     * <code>.opentelemetry.proto.mmap.v1.MetricRef.Histogram histogram = 7;</code>
     * @return The histogram.
     */
    opentelemetry.proto.mmap.v1.Mmap.MetricRef.Histogram getHistogram();
    /**
     * <code>.opentelemetry.proto.mmap.v1.MetricRef.Histogram histogram = 7;</code>
     */
    opentelemetry.proto.mmap.v1.Mmap.MetricRef.HistogramOrBuilder getHistogramOrBuilder();

    /**
     * <code>.opentelemetry.proto.mmap.v1.MetricRef.ExponentialHistogram exp_hist = 8;</code>
     * @return Whether the expHist field is set.
     */
    boolean hasExpHist();
    /**
     * <code>.opentelemetry.proto.mmap.v1.MetricRef.ExponentialHistogram exp_hist = 8;</code>
     * @return The expHist.
     */
    opentelemetry.proto.mmap.v1.Mmap.MetricRef.ExponentialHistogram getExpHist();
    /**
     * <code>.opentelemetry.proto.mmap.v1.MetricRef.ExponentialHistogram exp_hist = 8;</code>
     */
    opentelemetry.proto.mmap.v1.Mmap.MetricRef.ExponentialHistogramOrBuilder getExpHistOrBuilder();

    opentelemetry.proto.mmap.v1.Mmap.MetricRef.AggregationCase getAggregationCase();
  }
  /**
   * Protobuf type {@code opentelemetry.proto.mmap.v1.MetricRef}
   */
  public static final class MetricRef extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:opentelemetry.proto.mmap.v1.MetricRef)
      MetricRefOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 33,
        /* patch= */ 0,
        /* suffix= */ "",
        "MetricRef");
    }
    // Use MetricRef.newBuilder() to construct.
    private MetricRef(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private MetricRef() {
      name_ = "";
      description_ = "";
      unit_ = "";
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_MetricRef_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_MetricRef_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              opentelemetry.proto.mmap.v1.Mmap.MetricRef.class, opentelemetry.proto.mmap.v1.Mmap.MetricRef.Builder.class);
    }

    public interface GaugeOrBuilder extends
        // @@protoc_insertion_point(interface_extends:opentelemetry.proto.mmap.v1.MetricRef.Gauge)
        com.google.protobuf.MessageOrBuilder {
    }
    /**
     * Protobuf type {@code opentelemetry.proto.mmap.v1.MetricRef.Gauge}
     */
    public static final class Gauge extends
        com.google.protobuf.GeneratedMessage implements
        // @@protoc_insertion_point(message_implements:opentelemetry.proto.mmap.v1.MetricRef.Gauge)
        GaugeOrBuilder {
    private static final long serialVersionUID = 0L;
      static {
        com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
          com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
          /* major= */ 4,
          /* minor= */ 33,
          /* patch= */ 0,
          /* suffix= */ "",
          "Gauge");
      }
      // Use Gauge.newBuilder() to construct.
      private Gauge(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
        super(builder);
      }
      private Gauge() {
      }

      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_MetricRef_Gauge_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_MetricRef_Gauge_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                opentelemetry.proto.mmap.v1.Mmap.MetricRef.Gauge.class, opentelemetry.proto.mmap.v1.Mmap.MetricRef.Gauge.Builder.class);
      }

      private byte memoizedIsInitialized = -1;
      @java.lang.Override
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        memoizedIsInitialized = 1;
        return true;
      }

      @java.lang.Override
      public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        getUnknownFields().writeTo(output);
      }

      @java.lang.Override
      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        size += getUnknownFields().getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof opentelemetry.proto.mmap.v1.Mmap.MetricRef.Gauge)) {
          return super.equals(obj);
        }
        opentelemetry.proto.mmap.v1.Mmap.MetricRef.Gauge other = (opentelemetry.proto.mmap.v1.Mmap.MetricRef.Gauge) obj;

        if (!getUnknownFields().equals(other.getUnknownFields())) return false;
        return true;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        hash = (29 * hash) + getUnknownFields().hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static opentelemetry.proto.mmap.v1.Mmap.MetricRef.Gauge parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static opentelemetry.proto.mmap.v1.Mmap.MetricRef.Gauge parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static opentelemetry.proto.mmap.v1.Mmap.MetricRef.Gauge parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static opentelemetry.proto.mmap.v1.Mmap.MetricRef.Gauge parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static opentelemetry.proto.mmap.v1.Mmap.MetricRef.Gauge parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static opentelemetry.proto.mmap.v1.Mmap.MetricRef.Gauge parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static opentelemetry.proto.mmap.v1.Mmap.MetricRef.Gauge parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input);
      }
      public static opentelemetry.proto.mmap.v1.Mmap.MetricRef.Gauge parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      public static opentelemetry.proto.mmap.v1.Mmap.MetricRef.Gauge parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseDelimitedWithIOException(PARSER, input);
      }

      public static opentelemetry.proto.mmap.v1.Mmap.MetricRef.Gauge parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static opentelemetry.proto.mmap.v1.Mmap.MetricRef.Gauge parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input);
      }
      public static opentelemetry.proto.mmap.v1.Mmap.MetricRef.Gauge parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      @java.lang.Override
      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(opentelemetry.proto.mmap.v1.Mmap.MetricRef.Gauge prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      @java.lang.Override
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * Protobuf type {@code opentelemetry.proto.mmap.v1.MetricRef.Gauge}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessage.Builder<Builder> implements
          // @@protoc_insertion_point(builder_implements:opentelemetry.proto.mmap.v1.MetricRef.Gauge)
          opentelemetry.proto.mmap.v1.Mmap.MetricRef.GaugeOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_MetricRef_Gauge_descriptor;
        }

        @java.lang.Override
        protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_MetricRef_Gauge_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  opentelemetry.proto.mmap.v1.Mmap.MetricRef.Gauge.class, opentelemetry.proto.mmap.v1.Mmap.MetricRef.Gauge.Builder.class);
        }

        // Construct using opentelemetry.proto.mmap.v1.Mmap.MetricRef.Gauge.newBuilder()
        private Builder() {

        }

        private Builder(
            com.google.protobuf.GeneratedMessage.BuilderParent parent) {
          super(parent);

        }
        @java.lang.Override
        public Builder clear() {
          super.clear();
          return this;
        }

        @java.lang.Override
        public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_MetricRef_Gauge_descriptor;
        }

        @java.lang.Override
        public opentelemetry.proto.mmap.v1.Mmap.MetricRef.Gauge getDefaultInstanceForType() {
          return opentelemetry.proto.mmap.v1.Mmap.MetricRef.Gauge.getDefaultInstance();
        }

        @java.lang.Override
        public opentelemetry.proto.mmap.v1.Mmap.MetricRef.Gauge build() {
          opentelemetry.proto.mmap.v1.Mmap.MetricRef.Gauge result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        @java.lang.Override
        public opentelemetry.proto.mmap.v1.Mmap.MetricRef.Gauge buildPartial() {
          opentelemetry.proto.mmap.v1.Mmap.MetricRef.Gauge result = new opentelemetry.proto.mmap.v1.Mmap.MetricRef.Gauge(this);
          onBuilt();
          return result;
        }

        @java.lang.Override
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other instanceof opentelemetry.proto.mmap.v1.Mmap.MetricRef.Gauge) {
            return mergeFrom((opentelemetry.proto.mmap.v1.Mmap.MetricRef.Gauge)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(opentelemetry.proto.mmap.v1.Mmap.MetricRef.Gauge other) {
          if (other == opentelemetry.proto.mmap.v1.Mmap.MetricRef.Gauge.getDefaultInstance()) return this;
          this.mergeUnknownFields(other.getUnknownFields());
          onChanged();
          return this;
        }

        @java.lang.Override
        public final boolean isInitialized() {
          return true;
        }

        @java.lang.Override
        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          if (extensionRegistry == null) {
            throw new java.lang.NullPointerException();
          }
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                default: {
                  if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                    done = true; // was an endgroup tag
                  }
                  break;
                } // default:
              } // switch (tag)
            } // while (!done)
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.unwrapIOException();
          } finally {
            onChanged();
          } // finally
          return this;
        }

        // @@protoc_insertion_point(builder_scope:opentelemetry.proto.mmap.v1.MetricRef.Gauge)
      }

      // @@protoc_insertion_point(class_scope:opentelemetry.proto.mmap.v1.MetricRef.Gauge)
      private static final opentelemetry.proto.mmap.v1.Mmap.MetricRef.Gauge DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new opentelemetry.proto.mmap.v1.Mmap.MetricRef.Gauge();
      }

      public static opentelemetry.proto.mmap.v1.Mmap.MetricRef.Gauge getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static final com.google.protobuf.Parser<Gauge>
          PARSER = new com.google.protobuf.AbstractParser<Gauge>() {
        @java.lang.Override
        public Gauge parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          Builder builder = newBuilder();
          try {
            builder.mergeFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.setUnfinishedMessage(builder.buildPartial());
          } catch (com.google.protobuf.UninitializedMessageException e) {
            throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
          } catch (java.io.IOException e) {
            throw new com.google.protobuf.InvalidProtocolBufferException(e)
                .setUnfinishedMessage(builder.buildPartial());
          }
          return builder.buildPartial();
        }
      };

      public static com.google.protobuf.Parser<Gauge> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<Gauge> getParserForType() {
        return PARSER;
      }

      @java.lang.Override
      public opentelemetry.proto.mmap.v1.Mmap.MetricRef.Gauge getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    public interface SumOrBuilder extends
        // @@protoc_insertion_point(interface_extends:opentelemetry.proto.mmap.v1.MetricRef.Sum)
        com.google.protobuf.MessageOrBuilder {

      /**
       * <pre>
       * aggregation_temporality describes if the aggregator reports delta changes
       * since last report time, or cumulative changes since a fixed start time.
       * </pre>
       *
       * <code>.opentelemetry.proto.mmap.v1.AggregationTemporality aggregation_temporality = 2;</code>
       * @return The enum numeric value on the wire for aggregationTemporality.
       */
      int getAggregationTemporalityValue();
      /**
       * <pre>
       * aggregation_temporality describes if the aggregator reports delta changes
       * since last report time, or cumulative changes since a fixed start time.
       * </pre>
       *
       * <code>.opentelemetry.proto.mmap.v1.AggregationTemporality aggregation_temporality = 2;</code>
       * @return The aggregationTemporality.
       */
      opentelemetry.proto.mmap.v1.Mmap.AggregationTemporality getAggregationTemporality();

      /**
       * <pre>
       * Represents whether the sum is monotonic.
       * </pre>
       *
       * <code>bool is_monotonic = 3;</code>
       * @return The isMonotonic.
       */
      boolean getIsMonotonic();
    }
    /**
     * Protobuf type {@code opentelemetry.proto.mmap.v1.MetricRef.Sum}
     */
    public static final class Sum extends
        com.google.protobuf.GeneratedMessage implements
        // @@protoc_insertion_point(message_implements:opentelemetry.proto.mmap.v1.MetricRef.Sum)
        SumOrBuilder {
    private static final long serialVersionUID = 0L;
      static {
        com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
          com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
          /* major= */ 4,
          /* minor= */ 33,
          /* patch= */ 0,
          /* suffix= */ "",
          "Sum");
      }
      // Use Sum.newBuilder() to construct.
      private Sum(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
        super(builder);
      }
      private Sum() {
        aggregationTemporality_ = 0;
      }

      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_MetricRef_Sum_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_MetricRef_Sum_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                opentelemetry.proto.mmap.v1.Mmap.MetricRef.Sum.class, opentelemetry.proto.mmap.v1.Mmap.MetricRef.Sum.Builder.class);
      }

      public static final int AGGREGATION_TEMPORALITY_FIELD_NUMBER = 2;
      private int aggregationTemporality_ = 0;
      /**
       * <pre>
       * aggregation_temporality describes if the aggregator reports delta changes
       * since last report time, or cumulative changes since a fixed start time.
       * </pre>
       *
       * <code>.opentelemetry.proto.mmap.v1.AggregationTemporality aggregation_temporality = 2;</code>
       * @return The enum numeric value on the wire for aggregationTemporality.
       */
      @java.lang.Override public int getAggregationTemporalityValue() {
        return aggregationTemporality_;
      }
      /**
       * <pre>
       * aggregation_temporality describes if the aggregator reports delta changes
       * since last report time, or cumulative changes since a fixed start time.
       * </pre>
       *
       * <code>.opentelemetry.proto.mmap.v1.AggregationTemporality aggregation_temporality = 2;</code>
       * @return The aggregationTemporality.
       */
      @java.lang.Override public opentelemetry.proto.mmap.v1.Mmap.AggregationTemporality getAggregationTemporality() {
        opentelemetry.proto.mmap.v1.Mmap.AggregationTemporality result = opentelemetry.proto.mmap.v1.Mmap.AggregationTemporality.forNumber(aggregationTemporality_);
        return result == null ? opentelemetry.proto.mmap.v1.Mmap.AggregationTemporality.UNRECOGNIZED : result;
      }

      public static final int IS_MONOTONIC_FIELD_NUMBER = 3;
      private boolean isMonotonic_ = false;
      /**
       * <pre>
       * Represents whether the sum is monotonic.
       * </pre>
       *
       * <code>bool is_monotonic = 3;</code>
       * @return The isMonotonic.
       */
      @java.lang.Override
      public boolean getIsMonotonic() {
        return isMonotonic_;
      }

      private byte memoizedIsInitialized = -1;
      @java.lang.Override
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        memoizedIsInitialized = 1;
        return true;
      }

      @java.lang.Override
      public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        if (aggregationTemporality_ != opentelemetry.proto.mmap.v1.Mmap.AggregationTemporality.AGGREGATION_TEMPORALITY_UNSPECIFIED.getNumber()) {
          output.writeEnum(2, aggregationTemporality_);
        }
        if (isMonotonic_ != false) {
          output.writeBool(3, isMonotonic_);
        }
        getUnknownFields().writeTo(output);
      }

      @java.lang.Override
      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        if (aggregationTemporality_ != opentelemetry.proto.mmap.v1.Mmap.AggregationTemporality.AGGREGATION_TEMPORALITY_UNSPECIFIED.getNumber()) {
          size += com.google.protobuf.CodedOutputStream
            .computeEnumSize(2, aggregationTemporality_);
        }
        if (isMonotonic_ != false) {
          size += com.google.protobuf.CodedOutputStream
            .computeBoolSize(3, isMonotonic_);
        }
        size += getUnknownFields().getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof opentelemetry.proto.mmap.v1.Mmap.MetricRef.Sum)) {
          return super.equals(obj);
        }
        opentelemetry.proto.mmap.v1.Mmap.MetricRef.Sum other = (opentelemetry.proto.mmap.v1.Mmap.MetricRef.Sum) obj;

        if (aggregationTemporality_ != other.aggregationTemporality_) return false;
        if (getIsMonotonic()
            != other.getIsMonotonic()) return false;
        if (!getUnknownFields().equals(other.getUnknownFields())) return false;
        return true;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        hash = (37 * hash) + AGGREGATION_TEMPORALITY_FIELD_NUMBER;
        hash = (53 * hash) + aggregationTemporality_;
        hash = (37 * hash) + IS_MONOTONIC_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getIsMonotonic());
        hash = (29 * hash) + getUnknownFields().hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static opentelemetry.proto.mmap.v1.Mmap.MetricRef.Sum parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static opentelemetry.proto.mmap.v1.Mmap.MetricRef.Sum parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static opentelemetry.proto.mmap.v1.Mmap.MetricRef.Sum parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static opentelemetry.proto.mmap.v1.Mmap.MetricRef.Sum parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static opentelemetry.proto.mmap.v1.Mmap.MetricRef.Sum parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static opentelemetry.proto.mmap.v1.Mmap.MetricRef.Sum parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static opentelemetry.proto.mmap.v1.Mmap.MetricRef.Sum parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input);
      }
      public static opentelemetry.proto.mmap.v1.Mmap.MetricRef.Sum parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      public static opentelemetry.proto.mmap.v1.Mmap.MetricRef.Sum parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseDelimitedWithIOException(PARSER, input);
      }

      public static opentelemetry.proto.mmap.v1.Mmap.MetricRef.Sum parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static opentelemetry.proto.mmap.v1.Mmap.MetricRef.Sum parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input);
      }
      public static opentelemetry.proto.mmap.v1.Mmap.MetricRef.Sum parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      @java.lang.Override
      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(opentelemetry.proto.mmap.v1.Mmap.MetricRef.Sum prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      @java.lang.Override
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * Protobuf type {@code opentelemetry.proto.mmap.v1.MetricRef.Sum}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessage.Builder<Builder> implements
          // @@protoc_insertion_point(builder_implements:opentelemetry.proto.mmap.v1.MetricRef.Sum)
          opentelemetry.proto.mmap.v1.Mmap.MetricRef.SumOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_MetricRef_Sum_descriptor;
        }

        @java.lang.Override
        protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_MetricRef_Sum_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  opentelemetry.proto.mmap.v1.Mmap.MetricRef.Sum.class, opentelemetry.proto.mmap.v1.Mmap.MetricRef.Sum.Builder.class);
        }

        // Construct using opentelemetry.proto.mmap.v1.Mmap.MetricRef.Sum.newBuilder()
        private Builder() {

        }

        private Builder(
            com.google.protobuf.GeneratedMessage.BuilderParent parent) {
          super(parent);

        }
        @java.lang.Override
        public Builder clear() {
          super.clear();
          bitField0_ = 0;
          aggregationTemporality_ = 0;
          isMonotonic_ = false;
          return this;
        }

        @java.lang.Override
        public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_MetricRef_Sum_descriptor;
        }

        @java.lang.Override
        public opentelemetry.proto.mmap.v1.Mmap.MetricRef.Sum getDefaultInstanceForType() {
          return opentelemetry.proto.mmap.v1.Mmap.MetricRef.Sum.getDefaultInstance();
        }

        @java.lang.Override
        public opentelemetry.proto.mmap.v1.Mmap.MetricRef.Sum build() {
          opentelemetry.proto.mmap.v1.Mmap.MetricRef.Sum result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        @java.lang.Override
        public opentelemetry.proto.mmap.v1.Mmap.MetricRef.Sum buildPartial() {
          opentelemetry.proto.mmap.v1.Mmap.MetricRef.Sum result = new opentelemetry.proto.mmap.v1.Mmap.MetricRef.Sum(this);
          if (bitField0_ != 0) { buildPartial0(result); }
          onBuilt();
          return result;
        }

        private void buildPartial0(opentelemetry.proto.mmap.v1.Mmap.MetricRef.Sum result) {
          int from_bitField0_ = bitField0_;
          if (((from_bitField0_ & 0x00000001) != 0)) {
            result.aggregationTemporality_ = aggregationTemporality_;
          }
          if (((from_bitField0_ & 0x00000002) != 0)) {
            result.isMonotonic_ = isMonotonic_;
          }
        }

        @java.lang.Override
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other instanceof opentelemetry.proto.mmap.v1.Mmap.MetricRef.Sum) {
            return mergeFrom((opentelemetry.proto.mmap.v1.Mmap.MetricRef.Sum)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(opentelemetry.proto.mmap.v1.Mmap.MetricRef.Sum other) {
          if (other == opentelemetry.proto.mmap.v1.Mmap.MetricRef.Sum.getDefaultInstance()) return this;
          if (other.aggregationTemporality_ != 0) {
            setAggregationTemporalityValue(other.getAggregationTemporalityValue());
          }
          if (other.getIsMonotonic() != false) {
            setIsMonotonic(other.getIsMonotonic());
          }
          this.mergeUnknownFields(other.getUnknownFields());
          onChanged();
          return this;
        }

        @java.lang.Override
        public final boolean isInitialized() {
          return true;
        }

        @java.lang.Override
        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          if (extensionRegistry == null) {
            throw new java.lang.NullPointerException();
          }
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                case 16: {
                  aggregationTemporality_ = input.readEnum();
                  bitField0_ |= 0x00000001;
                  break;
                } // case 16
                case 24: {
                  isMonotonic_ = input.readBool();
                  bitField0_ |= 0x00000002;
                  break;
                } // case 24
                default: {
                  if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                    done = true; // was an endgroup tag
                  }
                  break;
                } // default:
              } // switch (tag)
            } // while (!done)
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.unwrapIOException();
          } finally {
            onChanged();
          } // finally
          return this;
        }
        private int bitField0_;

        private int aggregationTemporality_ = 0;
        /**
         * <pre>
         * aggregation_temporality describes if the aggregator reports delta changes
         * since last report time, or cumulative changes since a fixed start time.
         * </pre>
         *
         * <code>.opentelemetry.proto.mmap.v1.AggregationTemporality aggregation_temporality = 2;</code>
         * @return The enum numeric value on the wire for aggregationTemporality.
         */
        @java.lang.Override public int getAggregationTemporalityValue() {
          return aggregationTemporality_;
        }
        /**
         * <pre>
         * aggregation_temporality describes if the aggregator reports delta changes
         * since last report time, or cumulative changes since a fixed start time.
         * </pre>
         *
         * <code>.opentelemetry.proto.mmap.v1.AggregationTemporality aggregation_temporality = 2;</code>
         * @param value The enum numeric value on the wire for aggregationTemporality to set.
         * @return This builder for chaining.
         */
        public Builder setAggregationTemporalityValue(int value) {
          aggregationTemporality_ = value;
          bitField0_ |= 0x00000001;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * aggregation_temporality describes if the aggregator reports delta changes
         * since last report time, or cumulative changes since a fixed start time.
         * </pre>
         *
         * <code>.opentelemetry.proto.mmap.v1.AggregationTemporality aggregation_temporality = 2;</code>
         * @return The aggregationTemporality.
         */
        @java.lang.Override
        public opentelemetry.proto.mmap.v1.Mmap.AggregationTemporality getAggregationTemporality() {
          opentelemetry.proto.mmap.v1.Mmap.AggregationTemporality result = opentelemetry.proto.mmap.v1.Mmap.AggregationTemporality.forNumber(aggregationTemporality_);
          return result == null ? opentelemetry.proto.mmap.v1.Mmap.AggregationTemporality.UNRECOGNIZED : result;
        }
        /**
         * <pre>
         * aggregation_temporality describes if the aggregator reports delta changes
         * since last report time, or cumulative changes since a fixed start time.
         * </pre>
         *
         * <code>.opentelemetry.proto.mmap.v1.AggregationTemporality aggregation_temporality = 2;</code>
         * @param value The aggregationTemporality to set.
         * @return This builder for chaining.
         */
        public Builder setAggregationTemporality(opentelemetry.proto.mmap.v1.Mmap.AggregationTemporality value) {
          if (value == null) { throw new NullPointerException(); }
          bitField0_ |= 0x00000001;
          aggregationTemporality_ = value.getNumber();
          onChanged();
          return this;
        }
        /**
         * <pre>
         * aggregation_temporality describes if the aggregator reports delta changes
         * since last report time, or cumulative changes since a fixed start time.
         * </pre>
         *
         * <code>.opentelemetry.proto.mmap.v1.AggregationTemporality aggregation_temporality = 2;</code>
         * @return This builder for chaining.
         */
        public Builder clearAggregationTemporality() {
          bitField0_ = (bitField0_ & ~0x00000001);
          aggregationTemporality_ = 0;
          onChanged();
          return this;
        }

        private boolean isMonotonic_ ;
        /**
         * <pre>
         * Represents whether the sum is monotonic.
         * </pre>
         *
         * <code>bool is_monotonic = 3;</code>
         * @return The isMonotonic.
         */
        @java.lang.Override
        public boolean getIsMonotonic() {
          return isMonotonic_;
        }
        /**
         * <pre>
         * Represents whether the sum is monotonic.
         * </pre>
         *
         * <code>bool is_monotonic = 3;</code>
         * @param value The isMonotonic to set.
         * @return This builder for chaining.
         */
        public Builder setIsMonotonic(boolean value) {

          isMonotonic_ = value;
          bitField0_ |= 0x00000002;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Represents whether the sum is monotonic.
         * </pre>
         *
         * <code>bool is_monotonic = 3;</code>
         * @return This builder for chaining.
         */
        public Builder clearIsMonotonic() {
          bitField0_ = (bitField0_ & ~0x00000002);
          isMonotonic_ = false;
          onChanged();
          return this;
        }

        // @@protoc_insertion_point(builder_scope:opentelemetry.proto.mmap.v1.MetricRef.Sum)
      }

      // @@protoc_insertion_point(class_scope:opentelemetry.proto.mmap.v1.MetricRef.Sum)
      private static final opentelemetry.proto.mmap.v1.Mmap.MetricRef.Sum DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new opentelemetry.proto.mmap.v1.Mmap.MetricRef.Sum();
      }

      public static opentelemetry.proto.mmap.v1.Mmap.MetricRef.Sum getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static final com.google.protobuf.Parser<Sum>
          PARSER = new com.google.protobuf.AbstractParser<Sum>() {
        @java.lang.Override
        public Sum parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          Builder builder = newBuilder();
          try {
            builder.mergeFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.setUnfinishedMessage(builder.buildPartial());
          } catch (com.google.protobuf.UninitializedMessageException e) {
            throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
          } catch (java.io.IOException e) {
            throw new com.google.protobuf.InvalidProtocolBufferException(e)
                .setUnfinishedMessage(builder.buildPartial());
          }
          return builder.buildPartial();
        }
      };

      public static com.google.protobuf.Parser<Sum> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<Sum> getParserForType() {
        return PARSER;
      }

      @java.lang.Override
      public opentelemetry.proto.mmap.v1.Mmap.MetricRef.Sum getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    public interface HistogramOrBuilder extends
        // @@protoc_insertion_point(interface_extends:opentelemetry.proto.mmap.v1.MetricRef.Histogram)
        com.google.protobuf.MessageOrBuilder {

      /**
       * <pre>
       * aggregation_temporality describes if the aggregator reports delta changes
       * since last report time, or cumulative changes since a fixed start time.
       * </pre>
       *
       * <code>.opentelemetry.proto.mmap.v1.AggregationTemporality aggregation_temporality = 1;</code>
       * @return The enum numeric value on the wire for aggregationTemporality.
       */
      int getAggregationTemporalityValue();
      /**
       * <pre>
       * aggregation_temporality describes if the aggregator reports delta changes
       * since last report time, or cumulative changes since a fixed start time.
       * </pre>
       *
       * <code>.opentelemetry.proto.mmap.v1.AggregationTemporality aggregation_temporality = 1;</code>
       * @return The aggregationTemporality.
       */
      opentelemetry.proto.mmap.v1.Mmap.AggregationTemporality getAggregationTemporality();

      /**
       * <pre>
       * Bucket boundaries to use for this histogram.
       * </pre>
       *
       * <code>repeated double bucket_boundares = 2;</code>
       * @return A list containing the bucketBoundares.
       */
      java.util.List<java.lang.Double> getBucketBoundaresList();
      /**
       * <pre>
       * Bucket boundaries to use for this histogram.
       * </pre>
       *
       * <code>repeated double bucket_boundares = 2;</code>
       * @return The count of bucketBoundares.
       */
      int getBucketBoundaresCount();
      /**
       * <pre>
       * Bucket boundaries to use for this histogram.
       * </pre>
       *
       * <code>repeated double bucket_boundares = 2;</code>
       * @param index The index of the element to return.
       * @return The bucketBoundares at the given index.
       */
      double getBucketBoundares(int index);
    }
    /**
     * Protobuf type {@code opentelemetry.proto.mmap.v1.MetricRef.Histogram}
     */
    public static final class Histogram extends
        com.google.protobuf.GeneratedMessage implements
        // @@protoc_insertion_point(message_implements:opentelemetry.proto.mmap.v1.MetricRef.Histogram)
        HistogramOrBuilder {
    private static final long serialVersionUID = 0L;
      static {
        com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
          com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
          /* major= */ 4,
          /* minor= */ 33,
          /* patch= */ 0,
          /* suffix= */ "",
          "Histogram");
      }
      // Use Histogram.newBuilder() to construct.
      private Histogram(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
        super(builder);
      }
      private Histogram() {
        aggregationTemporality_ = 0;
        bucketBoundares_ = emptyDoubleList();
      }

      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_MetricRef_Histogram_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_MetricRef_Histogram_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                opentelemetry.proto.mmap.v1.Mmap.MetricRef.Histogram.class, opentelemetry.proto.mmap.v1.Mmap.MetricRef.Histogram.Builder.class);
      }

      public static final int AGGREGATION_TEMPORALITY_FIELD_NUMBER = 1;
      private int aggregationTemporality_ = 0;
      /**
       * <pre>
       * aggregation_temporality describes if the aggregator reports delta changes
       * since last report time, or cumulative changes since a fixed start time.
       * </pre>
       *
       * <code>.opentelemetry.proto.mmap.v1.AggregationTemporality aggregation_temporality = 1;</code>
       * @return The enum numeric value on the wire for aggregationTemporality.
       */
      @java.lang.Override public int getAggregationTemporalityValue() {
        return aggregationTemporality_;
      }
      /**
       * <pre>
       * aggregation_temporality describes if the aggregator reports delta changes
       * since last report time, or cumulative changes since a fixed start time.
       * </pre>
       *
       * <code>.opentelemetry.proto.mmap.v1.AggregationTemporality aggregation_temporality = 1;</code>
       * @return The aggregationTemporality.
       */
      @java.lang.Override public opentelemetry.proto.mmap.v1.Mmap.AggregationTemporality getAggregationTemporality() {
        opentelemetry.proto.mmap.v1.Mmap.AggregationTemporality result = opentelemetry.proto.mmap.v1.Mmap.AggregationTemporality.forNumber(aggregationTemporality_);
        return result == null ? opentelemetry.proto.mmap.v1.Mmap.AggregationTemporality.UNRECOGNIZED : result;
      }

      public static final int BUCKET_BOUNDARES_FIELD_NUMBER = 2;
      @SuppressWarnings("serial")
      private com.google.protobuf.Internal.DoubleList bucketBoundares_ =
          emptyDoubleList();
      /**
       * <pre>
       * Bucket boundaries to use for this histogram.
       * </pre>
       *
       * <code>repeated double bucket_boundares = 2;</code>
       * @return A list containing the bucketBoundares.
       */
      @java.lang.Override
      public java.util.List<java.lang.Double>
          getBucketBoundaresList() {
        return bucketBoundares_;
      }
      /**
       * <pre>
       * Bucket boundaries to use for this histogram.
       * </pre>
       *
       * <code>repeated double bucket_boundares = 2;</code>
       * @return The count of bucketBoundares.
       */
      public int getBucketBoundaresCount() {
        return bucketBoundares_.size();
      }
      /**
       * <pre>
       * Bucket boundaries to use for this histogram.
       * </pre>
       *
       * <code>repeated double bucket_boundares = 2;</code>
       * @param index The index of the element to return.
       * @return The bucketBoundares at the given index.
       */
      public double getBucketBoundares(int index) {
        return bucketBoundares_.getDouble(index);
      }
      private int bucketBoundaresMemoizedSerializedSize = -1;

      private byte memoizedIsInitialized = -1;
      @java.lang.Override
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        memoizedIsInitialized = 1;
        return true;
      }

      @java.lang.Override
      public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        getSerializedSize();
        if (aggregationTemporality_ != opentelemetry.proto.mmap.v1.Mmap.AggregationTemporality.AGGREGATION_TEMPORALITY_UNSPECIFIED.getNumber()) {
          output.writeEnum(1, aggregationTemporality_);
        }
        if (getBucketBoundaresList().size() > 0) {
          output.writeUInt32NoTag(18);
          output.writeUInt32NoTag(bucketBoundaresMemoizedSerializedSize);
        }
        for (int i = 0; i < bucketBoundares_.size(); i++) {
          output.writeDoubleNoTag(bucketBoundares_.getDouble(i));
        }
        getUnknownFields().writeTo(output);
      }

      @java.lang.Override
      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        if (aggregationTemporality_ != opentelemetry.proto.mmap.v1.Mmap.AggregationTemporality.AGGREGATION_TEMPORALITY_UNSPECIFIED.getNumber()) {
          size += com.google.protobuf.CodedOutputStream
            .computeEnumSize(1, aggregationTemporality_);
        }
        {
          int dataSize = 0;
          dataSize = 8 * getBucketBoundaresList().size();
          size += dataSize;
          if (!getBucketBoundaresList().isEmpty()) {
            size += 1;
            size += com.google.protobuf.CodedOutputStream
                .computeInt32SizeNoTag(dataSize);
          }
          bucketBoundaresMemoizedSerializedSize = dataSize;
        }
        size += getUnknownFields().getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof opentelemetry.proto.mmap.v1.Mmap.MetricRef.Histogram)) {
          return super.equals(obj);
        }
        opentelemetry.proto.mmap.v1.Mmap.MetricRef.Histogram other = (opentelemetry.proto.mmap.v1.Mmap.MetricRef.Histogram) obj;

        if (aggregationTemporality_ != other.aggregationTemporality_) return false;
        if (!getBucketBoundaresList()
            .equals(other.getBucketBoundaresList())) return false;
        if (!getUnknownFields().equals(other.getUnknownFields())) return false;
        return true;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        hash = (37 * hash) + AGGREGATION_TEMPORALITY_FIELD_NUMBER;
        hash = (53 * hash) + aggregationTemporality_;
        if (getBucketBoundaresCount() > 0) {
          hash = (37 * hash) + BUCKET_BOUNDARES_FIELD_NUMBER;
          hash = (53 * hash) + getBucketBoundaresList().hashCode();
        }
        hash = (29 * hash) + getUnknownFields().hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static opentelemetry.proto.mmap.v1.Mmap.MetricRef.Histogram parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static opentelemetry.proto.mmap.v1.Mmap.MetricRef.Histogram parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static opentelemetry.proto.mmap.v1.Mmap.MetricRef.Histogram parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static opentelemetry.proto.mmap.v1.Mmap.MetricRef.Histogram parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static opentelemetry.proto.mmap.v1.Mmap.MetricRef.Histogram parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static opentelemetry.proto.mmap.v1.Mmap.MetricRef.Histogram parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static opentelemetry.proto.mmap.v1.Mmap.MetricRef.Histogram parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input);
      }
      public static opentelemetry.proto.mmap.v1.Mmap.MetricRef.Histogram parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      public static opentelemetry.proto.mmap.v1.Mmap.MetricRef.Histogram parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseDelimitedWithIOException(PARSER, input);
      }

      public static opentelemetry.proto.mmap.v1.Mmap.MetricRef.Histogram parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static opentelemetry.proto.mmap.v1.Mmap.MetricRef.Histogram parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input);
      }
      public static opentelemetry.proto.mmap.v1.Mmap.MetricRef.Histogram parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      @java.lang.Override
      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(opentelemetry.proto.mmap.v1.Mmap.MetricRef.Histogram prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      @java.lang.Override
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * Protobuf type {@code opentelemetry.proto.mmap.v1.MetricRef.Histogram}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessage.Builder<Builder> implements
          // @@protoc_insertion_point(builder_implements:opentelemetry.proto.mmap.v1.MetricRef.Histogram)
          opentelemetry.proto.mmap.v1.Mmap.MetricRef.HistogramOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_MetricRef_Histogram_descriptor;
        }

        @java.lang.Override
        protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_MetricRef_Histogram_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  opentelemetry.proto.mmap.v1.Mmap.MetricRef.Histogram.class, opentelemetry.proto.mmap.v1.Mmap.MetricRef.Histogram.Builder.class);
        }

        // Construct using opentelemetry.proto.mmap.v1.Mmap.MetricRef.Histogram.newBuilder()
        private Builder() {

        }

        private Builder(
            com.google.protobuf.GeneratedMessage.BuilderParent parent) {
          super(parent);

        }
        @java.lang.Override
        public Builder clear() {
          super.clear();
          bitField0_ = 0;
          aggregationTemporality_ = 0;
          bucketBoundares_ = emptyDoubleList();
          return this;
        }

        @java.lang.Override
        public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_MetricRef_Histogram_descriptor;
        }

        @java.lang.Override
        public opentelemetry.proto.mmap.v1.Mmap.MetricRef.Histogram getDefaultInstanceForType() {
          return opentelemetry.proto.mmap.v1.Mmap.MetricRef.Histogram.getDefaultInstance();
        }

        @java.lang.Override
        public opentelemetry.proto.mmap.v1.Mmap.MetricRef.Histogram build() {
          opentelemetry.proto.mmap.v1.Mmap.MetricRef.Histogram result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        @java.lang.Override
        public opentelemetry.proto.mmap.v1.Mmap.MetricRef.Histogram buildPartial() {
          opentelemetry.proto.mmap.v1.Mmap.MetricRef.Histogram result = new opentelemetry.proto.mmap.v1.Mmap.MetricRef.Histogram(this);
          if (bitField0_ != 0) { buildPartial0(result); }
          onBuilt();
          return result;
        }

        private void buildPartial0(opentelemetry.proto.mmap.v1.Mmap.MetricRef.Histogram result) {
          int from_bitField0_ = bitField0_;
          if (((from_bitField0_ & 0x00000001) != 0)) {
            result.aggregationTemporality_ = aggregationTemporality_;
          }
          if (((from_bitField0_ & 0x00000002) != 0)) {
            bucketBoundares_.makeImmutable();
            result.bucketBoundares_ = bucketBoundares_;
          }
        }

        @java.lang.Override
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other instanceof opentelemetry.proto.mmap.v1.Mmap.MetricRef.Histogram) {
            return mergeFrom((opentelemetry.proto.mmap.v1.Mmap.MetricRef.Histogram)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(opentelemetry.proto.mmap.v1.Mmap.MetricRef.Histogram other) {
          if (other == opentelemetry.proto.mmap.v1.Mmap.MetricRef.Histogram.getDefaultInstance()) return this;
          if (other.aggregationTemporality_ != 0) {
            setAggregationTemporalityValue(other.getAggregationTemporalityValue());
          }
          if (!other.bucketBoundares_.isEmpty()) {
            if (bucketBoundares_.isEmpty()) {
              bucketBoundares_ = other.bucketBoundares_;
              bucketBoundares_.makeImmutable();
              bitField0_ |= 0x00000002;
            } else {
              ensureBucketBoundaresIsMutable();
              bucketBoundares_.addAll(other.bucketBoundares_);
            }
            onChanged();
          }
          this.mergeUnknownFields(other.getUnknownFields());
          onChanged();
          return this;
        }

        @java.lang.Override
        public final boolean isInitialized() {
          return true;
        }

        @java.lang.Override
        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          if (extensionRegistry == null) {
            throw new java.lang.NullPointerException();
          }
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                case 8: {
                  aggregationTemporality_ = input.readEnum();
                  bitField0_ |= 0x00000001;
                  break;
                } // case 8
                case 17: {
                  double v = input.readDouble();
                  ensureBucketBoundaresIsMutable();
                  bucketBoundares_.addDouble(v);
                  break;
                } // case 17
                case 18: {
                  int length = input.readRawVarint32();
                  int limit = input.pushLimit(length);
                  int alloc = length > 4096 ? 4096 : length;
                  ensureBucketBoundaresIsMutable(alloc / 8);
                  while (input.getBytesUntilLimit() > 0) {
                    bucketBoundares_.addDouble(input.readDouble());
                  }
                  input.popLimit(limit);
                  break;
                } // case 18
                default: {
                  if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                    done = true; // was an endgroup tag
                  }
                  break;
                } // default:
              } // switch (tag)
            } // while (!done)
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.unwrapIOException();
          } finally {
            onChanged();
          } // finally
          return this;
        }
        private int bitField0_;

        private int aggregationTemporality_ = 0;
        /**
         * <pre>
         * aggregation_temporality describes if the aggregator reports delta changes
         * since last report time, or cumulative changes since a fixed start time.
         * </pre>
         *
         * <code>.opentelemetry.proto.mmap.v1.AggregationTemporality aggregation_temporality = 1;</code>
         * @return The enum numeric value on the wire for aggregationTemporality.
         */
        @java.lang.Override public int getAggregationTemporalityValue() {
          return aggregationTemporality_;
        }
        /**
         * <pre>
         * aggregation_temporality describes if the aggregator reports delta changes
         * since last report time, or cumulative changes since a fixed start time.
         * </pre>
         *
         * <code>.opentelemetry.proto.mmap.v1.AggregationTemporality aggregation_temporality = 1;</code>
         * @param value The enum numeric value on the wire for aggregationTemporality to set.
         * @return This builder for chaining.
         */
        public Builder setAggregationTemporalityValue(int value) {
          aggregationTemporality_ = value;
          bitField0_ |= 0x00000001;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * aggregation_temporality describes if the aggregator reports delta changes
         * since last report time, or cumulative changes since a fixed start time.
         * </pre>
         *
         * <code>.opentelemetry.proto.mmap.v1.AggregationTemporality aggregation_temporality = 1;</code>
         * @return The aggregationTemporality.
         */
        @java.lang.Override
        public opentelemetry.proto.mmap.v1.Mmap.AggregationTemporality getAggregationTemporality() {
          opentelemetry.proto.mmap.v1.Mmap.AggregationTemporality result = opentelemetry.proto.mmap.v1.Mmap.AggregationTemporality.forNumber(aggregationTemporality_);
          return result == null ? opentelemetry.proto.mmap.v1.Mmap.AggregationTemporality.UNRECOGNIZED : result;
        }
        /**
         * <pre>
         * aggregation_temporality describes if the aggregator reports delta changes
         * since last report time, or cumulative changes since a fixed start time.
         * </pre>
         *
         * <code>.opentelemetry.proto.mmap.v1.AggregationTemporality aggregation_temporality = 1;</code>
         * @param value The aggregationTemporality to set.
         * @return This builder for chaining.
         */
        public Builder setAggregationTemporality(opentelemetry.proto.mmap.v1.Mmap.AggregationTemporality value) {
          if (value == null) { throw new NullPointerException(); }
          bitField0_ |= 0x00000001;
          aggregationTemporality_ = value.getNumber();
          onChanged();
          return this;
        }
        /**
         * <pre>
         * aggregation_temporality describes if the aggregator reports delta changes
         * since last report time, or cumulative changes since a fixed start time.
         * </pre>
         *
         * <code>.opentelemetry.proto.mmap.v1.AggregationTemporality aggregation_temporality = 1;</code>
         * @return This builder for chaining.
         */
        public Builder clearAggregationTemporality() {
          bitField0_ = (bitField0_ & ~0x00000001);
          aggregationTemporality_ = 0;
          onChanged();
          return this;
        }

        private com.google.protobuf.Internal.DoubleList bucketBoundares_ = emptyDoubleList();
        private void ensureBucketBoundaresIsMutable() {
          if (!bucketBoundares_.isModifiable()) {
            bucketBoundares_ = makeMutableCopy(bucketBoundares_);
          }
          bitField0_ |= 0x00000002;
        }
        private void ensureBucketBoundaresIsMutable(int capacity) {
          if (!bucketBoundares_.isModifiable()) {
            bucketBoundares_ = makeMutableCopy(bucketBoundares_, capacity);
          }
          bitField0_ |= 0x00000002;
        }
        /**
         * <pre>
         * Bucket boundaries to use for this histogram.
         * </pre>
         *
         * <code>repeated double bucket_boundares = 2;</code>
         * @return A list containing the bucketBoundares.
         */
        public java.util.List<java.lang.Double>
            getBucketBoundaresList() {
          bucketBoundares_.makeImmutable();
          return bucketBoundares_;
        }
        /**
         * <pre>
         * Bucket boundaries to use for this histogram.
         * </pre>
         *
         * <code>repeated double bucket_boundares = 2;</code>
         * @return The count of bucketBoundares.
         */
        public int getBucketBoundaresCount() {
          return bucketBoundares_.size();
        }
        /**
         * <pre>
         * Bucket boundaries to use for this histogram.
         * </pre>
         *
         * <code>repeated double bucket_boundares = 2;</code>
         * @param index The index of the element to return.
         * @return The bucketBoundares at the given index.
         */
        public double getBucketBoundares(int index) {
          return bucketBoundares_.getDouble(index);
        }
        /**
         * <pre>
         * Bucket boundaries to use for this histogram.
         * </pre>
         *
         * <code>repeated double bucket_boundares = 2;</code>
         * @param index The index to set the value at.
         * @param value The bucketBoundares to set.
         * @return This builder for chaining.
         */
        public Builder setBucketBoundares(
            int index, double value) {

          ensureBucketBoundaresIsMutable();
          bucketBoundares_.setDouble(index, value);
          bitField0_ |= 0x00000002;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Bucket boundaries to use for this histogram.
         * </pre>
         *
         * <code>repeated double bucket_boundares = 2;</code>
         * @param value The bucketBoundares to add.
         * @return This builder for chaining.
         */
        public Builder addBucketBoundares(double value) {

          ensureBucketBoundaresIsMutable();
          bucketBoundares_.addDouble(value);
          bitField0_ |= 0x00000002;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Bucket boundaries to use for this histogram.
         * </pre>
         *
         * <code>repeated double bucket_boundares = 2;</code>
         * @param values The bucketBoundares to add.
         * @return This builder for chaining.
         */
        public Builder addAllBucketBoundares(
            java.lang.Iterable<? extends java.lang.Double> values) {
          ensureBucketBoundaresIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, bucketBoundares_);
          bitField0_ |= 0x00000002;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Bucket boundaries to use for this histogram.
         * </pre>
         *
         * <code>repeated double bucket_boundares = 2;</code>
         * @return This builder for chaining.
         */
        public Builder clearBucketBoundares() {
          bucketBoundares_ = emptyDoubleList();
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
          return this;
        }

        // @@protoc_insertion_point(builder_scope:opentelemetry.proto.mmap.v1.MetricRef.Histogram)
      }

      // @@protoc_insertion_point(class_scope:opentelemetry.proto.mmap.v1.MetricRef.Histogram)
      private static final opentelemetry.proto.mmap.v1.Mmap.MetricRef.Histogram DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new opentelemetry.proto.mmap.v1.Mmap.MetricRef.Histogram();
      }

      public static opentelemetry.proto.mmap.v1.Mmap.MetricRef.Histogram getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static final com.google.protobuf.Parser<Histogram>
          PARSER = new com.google.protobuf.AbstractParser<Histogram>() {
        @java.lang.Override
        public Histogram parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          Builder builder = newBuilder();
          try {
            builder.mergeFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.setUnfinishedMessage(builder.buildPartial());
          } catch (com.google.protobuf.UninitializedMessageException e) {
            throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
          } catch (java.io.IOException e) {
            throw new com.google.protobuf.InvalidProtocolBufferException(e)
                .setUnfinishedMessage(builder.buildPartial());
          }
          return builder.buildPartial();
        }
      };

      public static com.google.protobuf.Parser<Histogram> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<Histogram> getParserForType() {
        return PARSER;
      }

      @java.lang.Override
      public opentelemetry.proto.mmap.v1.Mmap.MetricRef.Histogram getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    public interface ExponentialHistogramOrBuilder extends
        // @@protoc_insertion_point(interface_extends:opentelemetry.proto.mmap.v1.MetricRef.ExponentialHistogram)
        com.google.protobuf.MessageOrBuilder {

      /**
       * <pre>
       * aggregation_temporality describes if the aggregator reports delta changes
       * since last report time, or cumulative changes since a fixed start time.
       * </pre>
       *
       * <code>.opentelemetry.proto.mmap.v1.AggregationTemporality aggregation_temporality = 1;</code>
       * @return The enum numeric value on the wire for aggregationTemporality.
       */
      int getAggregationTemporalityValue();
      /**
       * <pre>
       * aggregation_temporality describes if the aggregator reports delta changes
       * since last report time, or cumulative changes since a fixed start time.
       * </pre>
       *
       * <code>.opentelemetry.proto.mmap.v1.AggregationTemporality aggregation_temporality = 1;</code>
       * @return The aggregationTemporality.
       */
      opentelemetry.proto.mmap.v1.Mmap.AggregationTemporality getAggregationTemporality();

      /**
       * <pre>
       * The number of buckets to configure for the exponential histogram.
       * </pre>
       *
       * <code>int64 max_buckets = 2;</code>
       * @return The maxBuckets.
       */
      long getMaxBuckets();

      /**
       * <pre>
       * The maximum scale to allow for this histogram.
       * </pre>
       *
       * <code>int64 max_scale = 3;</code>
       * @return The maxScale.
       */
      long getMaxScale();
    }
    /**
     * Protobuf type {@code opentelemetry.proto.mmap.v1.MetricRef.ExponentialHistogram}
     */
    public static final class ExponentialHistogram extends
        com.google.protobuf.GeneratedMessage implements
        // @@protoc_insertion_point(message_implements:opentelemetry.proto.mmap.v1.MetricRef.ExponentialHistogram)
        ExponentialHistogramOrBuilder {
    private static final long serialVersionUID = 0L;
      static {
        com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
          com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
          /* major= */ 4,
          /* minor= */ 33,
          /* patch= */ 0,
          /* suffix= */ "",
          "ExponentialHistogram");
      }
      // Use ExponentialHistogram.newBuilder() to construct.
      private ExponentialHistogram(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
        super(builder);
      }
      private ExponentialHistogram() {
        aggregationTemporality_ = 0;
      }

      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_MetricRef_ExponentialHistogram_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_MetricRef_ExponentialHistogram_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                opentelemetry.proto.mmap.v1.Mmap.MetricRef.ExponentialHistogram.class, opentelemetry.proto.mmap.v1.Mmap.MetricRef.ExponentialHistogram.Builder.class);
      }

      public static final int AGGREGATION_TEMPORALITY_FIELD_NUMBER = 1;
      private int aggregationTemporality_ = 0;
      /**
       * <pre>
       * aggregation_temporality describes if the aggregator reports delta changes
       * since last report time, or cumulative changes since a fixed start time.
       * </pre>
       *
       * <code>.opentelemetry.proto.mmap.v1.AggregationTemporality aggregation_temporality = 1;</code>
       * @return The enum numeric value on the wire for aggregationTemporality.
       */
      @java.lang.Override public int getAggregationTemporalityValue() {
        return aggregationTemporality_;
      }
      /**
       * <pre>
       * aggregation_temporality describes if the aggregator reports delta changes
       * since last report time, or cumulative changes since a fixed start time.
       * </pre>
       *
       * <code>.opentelemetry.proto.mmap.v1.AggregationTemporality aggregation_temporality = 1;</code>
       * @return The aggregationTemporality.
       */
      @java.lang.Override public opentelemetry.proto.mmap.v1.Mmap.AggregationTemporality getAggregationTemporality() {
        opentelemetry.proto.mmap.v1.Mmap.AggregationTemporality result = opentelemetry.proto.mmap.v1.Mmap.AggregationTemporality.forNumber(aggregationTemporality_);
        return result == null ? opentelemetry.proto.mmap.v1.Mmap.AggregationTemporality.UNRECOGNIZED : result;
      }

      public static final int MAX_BUCKETS_FIELD_NUMBER = 2;
      private long maxBuckets_ = 0L;
      /**
       * <pre>
       * The number of buckets to configure for the exponential histogram.
       * </pre>
       *
       * <code>int64 max_buckets = 2;</code>
       * @return The maxBuckets.
       */
      @java.lang.Override
      public long getMaxBuckets() {
        return maxBuckets_;
      }

      public static final int MAX_SCALE_FIELD_NUMBER = 3;
      private long maxScale_ = 0L;
      /**
       * <pre>
       * The maximum scale to allow for this histogram.
       * </pre>
       *
       * <code>int64 max_scale = 3;</code>
       * @return The maxScale.
       */
      @java.lang.Override
      public long getMaxScale() {
        return maxScale_;
      }

      private byte memoizedIsInitialized = -1;
      @java.lang.Override
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        memoizedIsInitialized = 1;
        return true;
      }

      @java.lang.Override
      public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        if (aggregationTemporality_ != opentelemetry.proto.mmap.v1.Mmap.AggregationTemporality.AGGREGATION_TEMPORALITY_UNSPECIFIED.getNumber()) {
          output.writeEnum(1, aggregationTemporality_);
        }
        if (maxBuckets_ != 0L) {
          output.writeInt64(2, maxBuckets_);
        }
        if (maxScale_ != 0L) {
          output.writeInt64(3, maxScale_);
        }
        getUnknownFields().writeTo(output);
      }

      @java.lang.Override
      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        if (aggregationTemporality_ != opentelemetry.proto.mmap.v1.Mmap.AggregationTemporality.AGGREGATION_TEMPORALITY_UNSPECIFIED.getNumber()) {
          size += com.google.protobuf.CodedOutputStream
            .computeEnumSize(1, aggregationTemporality_);
        }
        if (maxBuckets_ != 0L) {
          size += com.google.protobuf.CodedOutputStream
            .computeInt64Size(2, maxBuckets_);
        }
        if (maxScale_ != 0L) {
          size += com.google.protobuf.CodedOutputStream
            .computeInt64Size(3, maxScale_);
        }
        size += getUnknownFields().getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof opentelemetry.proto.mmap.v1.Mmap.MetricRef.ExponentialHistogram)) {
          return super.equals(obj);
        }
        opentelemetry.proto.mmap.v1.Mmap.MetricRef.ExponentialHistogram other = (opentelemetry.proto.mmap.v1.Mmap.MetricRef.ExponentialHistogram) obj;

        if (aggregationTemporality_ != other.aggregationTemporality_) return false;
        if (getMaxBuckets()
            != other.getMaxBuckets()) return false;
        if (getMaxScale()
            != other.getMaxScale()) return false;
        if (!getUnknownFields().equals(other.getUnknownFields())) return false;
        return true;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        hash = (37 * hash) + AGGREGATION_TEMPORALITY_FIELD_NUMBER;
        hash = (53 * hash) + aggregationTemporality_;
        hash = (37 * hash) + MAX_BUCKETS_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getMaxBuckets());
        hash = (37 * hash) + MAX_SCALE_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getMaxScale());
        hash = (29 * hash) + getUnknownFields().hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static opentelemetry.proto.mmap.v1.Mmap.MetricRef.ExponentialHistogram parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static opentelemetry.proto.mmap.v1.Mmap.MetricRef.ExponentialHistogram parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static opentelemetry.proto.mmap.v1.Mmap.MetricRef.ExponentialHistogram parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static opentelemetry.proto.mmap.v1.Mmap.MetricRef.ExponentialHistogram parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static opentelemetry.proto.mmap.v1.Mmap.MetricRef.ExponentialHistogram parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static opentelemetry.proto.mmap.v1.Mmap.MetricRef.ExponentialHistogram parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static opentelemetry.proto.mmap.v1.Mmap.MetricRef.ExponentialHistogram parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input);
      }
      public static opentelemetry.proto.mmap.v1.Mmap.MetricRef.ExponentialHistogram parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      public static opentelemetry.proto.mmap.v1.Mmap.MetricRef.ExponentialHistogram parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseDelimitedWithIOException(PARSER, input);
      }

      public static opentelemetry.proto.mmap.v1.Mmap.MetricRef.ExponentialHistogram parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static opentelemetry.proto.mmap.v1.Mmap.MetricRef.ExponentialHistogram parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input);
      }
      public static opentelemetry.proto.mmap.v1.Mmap.MetricRef.ExponentialHistogram parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      @java.lang.Override
      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(opentelemetry.proto.mmap.v1.Mmap.MetricRef.ExponentialHistogram prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      @java.lang.Override
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * Protobuf type {@code opentelemetry.proto.mmap.v1.MetricRef.ExponentialHistogram}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessage.Builder<Builder> implements
          // @@protoc_insertion_point(builder_implements:opentelemetry.proto.mmap.v1.MetricRef.ExponentialHistogram)
          opentelemetry.proto.mmap.v1.Mmap.MetricRef.ExponentialHistogramOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_MetricRef_ExponentialHistogram_descriptor;
        }

        @java.lang.Override
        protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_MetricRef_ExponentialHistogram_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  opentelemetry.proto.mmap.v1.Mmap.MetricRef.ExponentialHistogram.class, opentelemetry.proto.mmap.v1.Mmap.MetricRef.ExponentialHistogram.Builder.class);
        }

        // Construct using opentelemetry.proto.mmap.v1.Mmap.MetricRef.ExponentialHistogram.newBuilder()
        private Builder() {

        }

        private Builder(
            com.google.protobuf.GeneratedMessage.BuilderParent parent) {
          super(parent);

        }
        @java.lang.Override
        public Builder clear() {
          super.clear();
          bitField0_ = 0;
          aggregationTemporality_ = 0;
          maxBuckets_ = 0L;
          maxScale_ = 0L;
          return this;
        }

        @java.lang.Override
        public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_MetricRef_ExponentialHistogram_descriptor;
        }

        @java.lang.Override
        public opentelemetry.proto.mmap.v1.Mmap.MetricRef.ExponentialHistogram getDefaultInstanceForType() {
          return opentelemetry.proto.mmap.v1.Mmap.MetricRef.ExponentialHistogram.getDefaultInstance();
        }

        @java.lang.Override
        public opentelemetry.proto.mmap.v1.Mmap.MetricRef.ExponentialHistogram build() {
          opentelemetry.proto.mmap.v1.Mmap.MetricRef.ExponentialHistogram result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        @java.lang.Override
        public opentelemetry.proto.mmap.v1.Mmap.MetricRef.ExponentialHistogram buildPartial() {
          opentelemetry.proto.mmap.v1.Mmap.MetricRef.ExponentialHistogram result = new opentelemetry.proto.mmap.v1.Mmap.MetricRef.ExponentialHistogram(this);
          if (bitField0_ != 0) { buildPartial0(result); }
          onBuilt();
          return result;
        }

        private void buildPartial0(opentelemetry.proto.mmap.v1.Mmap.MetricRef.ExponentialHistogram result) {
          int from_bitField0_ = bitField0_;
          if (((from_bitField0_ & 0x00000001) != 0)) {
            result.aggregationTemporality_ = aggregationTemporality_;
          }
          if (((from_bitField0_ & 0x00000002) != 0)) {
            result.maxBuckets_ = maxBuckets_;
          }
          if (((from_bitField0_ & 0x00000004) != 0)) {
            result.maxScale_ = maxScale_;
          }
        }

        @java.lang.Override
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other instanceof opentelemetry.proto.mmap.v1.Mmap.MetricRef.ExponentialHistogram) {
            return mergeFrom((opentelemetry.proto.mmap.v1.Mmap.MetricRef.ExponentialHistogram)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(opentelemetry.proto.mmap.v1.Mmap.MetricRef.ExponentialHistogram other) {
          if (other == opentelemetry.proto.mmap.v1.Mmap.MetricRef.ExponentialHistogram.getDefaultInstance()) return this;
          if (other.aggregationTemporality_ != 0) {
            setAggregationTemporalityValue(other.getAggregationTemporalityValue());
          }
          if (other.getMaxBuckets() != 0L) {
            setMaxBuckets(other.getMaxBuckets());
          }
          if (other.getMaxScale() != 0L) {
            setMaxScale(other.getMaxScale());
          }
          this.mergeUnknownFields(other.getUnknownFields());
          onChanged();
          return this;
        }

        @java.lang.Override
        public final boolean isInitialized() {
          return true;
        }

        @java.lang.Override
        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          if (extensionRegistry == null) {
            throw new java.lang.NullPointerException();
          }
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                case 8: {
                  aggregationTemporality_ = input.readEnum();
                  bitField0_ |= 0x00000001;
                  break;
                } // case 8
                case 16: {
                  maxBuckets_ = input.readInt64();
                  bitField0_ |= 0x00000002;
                  break;
                } // case 16
                case 24: {
                  maxScale_ = input.readInt64();
                  bitField0_ |= 0x00000004;
                  break;
                } // case 24
                default: {
                  if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                    done = true; // was an endgroup tag
                  }
                  break;
                } // default:
              } // switch (tag)
            } // while (!done)
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.unwrapIOException();
          } finally {
            onChanged();
          } // finally
          return this;
        }
        private int bitField0_;

        private int aggregationTemporality_ = 0;
        /**
         * <pre>
         * aggregation_temporality describes if the aggregator reports delta changes
         * since last report time, or cumulative changes since a fixed start time.
         * </pre>
         *
         * <code>.opentelemetry.proto.mmap.v1.AggregationTemporality aggregation_temporality = 1;</code>
         * @return The enum numeric value on the wire for aggregationTemporality.
         */
        @java.lang.Override public int getAggregationTemporalityValue() {
          return aggregationTemporality_;
        }
        /**
         * <pre>
         * aggregation_temporality describes if the aggregator reports delta changes
         * since last report time, or cumulative changes since a fixed start time.
         * </pre>
         *
         * <code>.opentelemetry.proto.mmap.v1.AggregationTemporality aggregation_temporality = 1;</code>
         * @param value The enum numeric value on the wire for aggregationTemporality to set.
         * @return This builder for chaining.
         */
        public Builder setAggregationTemporalityValue(int value) {
          aggregationTemporality_ = value;
          bitField0_ |= 0x00000001;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * aggregation_temporality describes if the aggregator reports delta changes
         * since last report time, or cumulative changes since a fixed start time.
         * </pre>
         *
         * <code>.opentelemetry.proto.mmap.v1.AggregationTemporality aggregation_temporality = 1;</code>
         * @return The aggregationTemporality.
         */
        @java.lang.Override
        public opentelemetry.proto.mmap.v1.Mmap.AggregationTemporality getAggregationTemporality() {
          opentelemetry.proto.mmap.v1.Mmap.AggregationTemporality result = opentelemetry.proto.mmap.v1.Mmap.AggregationTemporality.forNumber(aggregationTemporality_);
          return result == null ? opentelemetry.proto.mmap.v1.Mmap.AggregationTemporality.UNRECOGNIZED : result;
        }
        /**
         * <pre>
         * aggregation_temporality describes if the aggregator reports delta changes
         * since last report time, or cumulative changes since a fixed start time.
         * </pre>
         *
         * <code>.opentelemetry.proto.mmap.v1.AggregationTemporality aggregation_temporality = 1;</code>
         * @param value The aggregationTemporality to set.
         * @return This builder for chaining.
         */
        public Builder setAggregationTemporality(opentelemetry.proto.mmap.v1.Mmap.AggregationTemporality value) {
          if (value == null) { throw new NullPointerException(); }
          bitField0_ |= 0x00000001;
          aggregationTemporality_ = value.getNumber();
          onChanged();
          return this;
        }
        /**
         * <pre>
         * aggregation_temporality describes if the aggregator reports delta changes
         * since last report time, or cumulative changes since a fixed start time.
         * </pre>
         *
         * <code>.opentelemetry.proto.mmap.v1.AggregationTemporality aggregation_temporality = 1;</code>
         * @return This builder for chaining.
         */
        public Builder clearAggregationTemporality() {
          bitField0_ = (bitField0_ & ~0x00000001);
          aggregationTemporality_ = 0;
          onChanged();
          return this;
        }

        private long maxBuckets_ ;
        /**
         * <pre>
         * The number of buckets to configure for the exponential histogram.
         * </pre>
         *
         * <code>int64 max_buckets = 2;</code>
         * @return The maxBuckets.
         */
        @java.lang.Override
        public long getMaxBuckets() {
          return maxBuckets_;
        }
        /**
         * <pre>
         * The number of buckets to configure for the exponential histogram.
         * </pre>
         *
         * <code>int64 max_buckets = 2;</code>
         * @param value The maxBuckets to set.
         * @return This builder for chaining.
         */
        public Builder setMaxBuckets(long value) {

          maxBuckets_ = value;
          bitField0_ |= 0x00000002;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * The number of buckets to configure for the exponential histogram.
         * </pre>
         *
         * <code>int64 max_buckets = 2;</code>
         * @return This builder for chaining.
         */
        public Builder clearMaxBuckets() {
          bitField0_ = (bitField0_ & ~0x00000002);
          maxBuckets_ = 0L;
          onChanged();
          return this;
        }

        private long maxScale_ ;
        /**
         * <pre>
         * The maximum scale to allow for this histogram.
         * </pre>
         *
         * <code>int64 max_scale = 3;</code>
         * @return The maxScale.
         */
        @java.lang.Override
        public long getMaxScale() {
          return maxScale_;
        }
        /**
         * <pre>
         * The maximum scale to allow for this histogram.
         * </pre>
         *
         * <code>int64 max_scale = 3;</code>
         * @param value The maxScale to set.
         * @return This builder for chaining.
         */
        public Builder setMaxScale(long value) {

          maxScale_ = value;
          bitField0_ |= 0x00000004;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * The maximum scale to allow for this histogram.
         * </pre>
         *
         * <code>int64 max_scale = 3;</code>
         * @return This builder for chaining.
         */
        public Builder clearMaxScale() {
          bitField0_ = (bitField0_ & ~0x00000004);
          maxScale_ = 0L;
          onChanged();
          return this;
        }

        // @@protoc_insertion_point(builder_scope:opentelemetry.proto.mmap.v1.MetricRef.ExponentialHistogram)
      }

      // @@protoc_insertion_point(class_scope:opentelemetry.proto.mmap.v1.MetricRef.ExponentialHistogram)
      private static final opentelemetry.proto.mmap.v1.Mmap.MetricRef.ExponentialHistogram DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new opentelemetry.proto.mmap.v1.Mmap.MetricRef.ExponentialHistogram();
      }

      public static opentelemetry.proto.mmap.v1.Mmap.MetricRef.ExponentialHistogram getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static final com.google.protobuf.Parser<ExponentialHistogram>
          PARSER = new com.google.protobuf.AbstractParser<ExponentialHistogram>() {
        @java.lang.Override
        public ExponentialHistogram parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          Builder builder = newBuilder();
          try {
            builder.mergeFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.setUnfinishedMessage(builder.buildPartial());
          } catch (com.google.protobuf.UninitializedMessageException e) {
            throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
          } catch (java.io.IOException e) {
            throw new com.google.protobuf.InvalidProtocolBufferException(e)
                .setUnfinishedMessage(builder.buildPartial());
          }
          return builder.buildPartial();
        }
      };

      public static com.google.protobuf.Parser<ExponentialHistogram> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<ExponentialHistogram> getParserForType() {
        return PARSER;
      }

      @java.lang.Override
      public opentelemetry.proto.mmap.v1.Mmap.MetricRef.ExponentialHistogram getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    private int aggregationCase_ = 0;
    @SuppressWarnings("serial")
    private java.lang.Object aggregation_;
    public enum AggregationCase
        implements com.google.protobuf.Internal.EnumLite,
            com.google.protobuf.AbstractMessage.InternalOneOfEnum {
      GAUGE(5),
      SUM(6),
      HISTOGRAM(7),
      EXP_HIST(8),
      AGGREGATION_NOT_SET(0);
      private final int value;
      private AggregationCase(int value) {
        this.value = value;
      }
      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static AggregationCase valueOf(int value) {
        return forNumber(value);
      }

      public static AggregationCase forNumber(int value) {
        switch (value) {
          case 5: return GAUGE;
          case 6: return SUM;
          case 7: return HISTOGRAM;
          case 8: return EXP_HIST;
          case 0: return AGGREGATION_NOT_SET;
          default: return null;
        }
      }
      public int getNumber() {
        return this.value;
      }
    };

    public AggregationCase
    getAggregationCase() {
      return AggregationCase.forNumber(
          aggregationCase_);
    }

    public static final int NAME_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private volatile java.lang.Object name_ = "";
    /**
     * <pre>
     * The name of the metric.
     * </pre>
     *
     * <code>string name = 1;</code>
     * @return The name.
     */
    @java.lang.Override
    public java.lang.String getName() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        name_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * The name of the metric.
     * </pre>
     *
     * <code>string name = 1;</code>
     * @return The bytes for name.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getNameBytes() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        name_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int DESCRIPTION_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private volatile java.lang.Object description_ = "";
    /**
     * <pre>
     * A description of the metric, which can be used in documentation.
     * </pre>
     *
     * <code>string description = 2;</code>
     * @return The description.
     */
    @java.lang.Override
    public java.lang.String getDescription() {
      java.lang.Object ref = description_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        description_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * A description of the metric, which can be used in documentation.
     * </pre>
     *
     * <code>string description = 2;</code>
     * @return The bytes for description.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getDescriptionBytes() {
      java.lang.Object ref = description_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        description_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int UNIT_FIELD_NUMBER = 3;
    @SuppressWarnings("serial")
    private volatile java.lang.Object unit_ = "";
    /**
     * <pre>
     * The unit in which the metric value is reported. Follows the format
     * described by https://unitsofmeasure.org/ucum.html.
     * </pre>
     *
     * <code>string unit = 3;</code>
     * @return The unit.
     */
    @java.lang.Override
    public java.lang.String getUnit() {
      java.lang.Object ref = unit_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        unit_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * The unit in which the metric value is reported. Follows the format
     * described by https://unitsofmeasure.org/ucum.html.
     * </pre>
     *
     * <code>string unit = 3;</code>
     * @return The bytes for unit.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getUnitBytes() {
      java.lang.Object ref = unit_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        unit_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int INSTRUMENTATION_SCOPE_REF_FIELD_NUMBER = 4;
    private long instrumentationScopeRef_ = 0L;
    /**
     * <pre>
     * Reference to the instrumentation scope where this metric is defined.
     * </pre>
     *
     * <code>int64 instrumentation_scope_ref = 4;</code>
     * @return The instrumentationScopeRef.
     */
    @java.lang.Override
    public long getInstrumentationScopeRef() {
      return instrumentationScopeRef_;
    }

    public static final int GAUGE_FIELD_NUMBER = 5;
    /**
     * <code>.opentelemetry.proto.mmap.v1.MetricRef.Gauge gauge = 5;</code>
     * @return Whether the gauge field is set.
     */
    @java.lang.Override
    public boolean hasGauge() {
      return aggregationCase_ == 5;
    }
    /**
     * <code>.opentelemetry.proto.mmap.v1.MetricRef.Gauge gauge = 5;</code>
     * @return The gauge.
     */
    @java.lang.Override
    public opentelemetry.proto.mmap.v1.Mmap.MetricRef.Gauge getGauge() {
      if (aggregationCase_ == 5) {
         return (opentelemetry.proto.mmap.v1.Mmap.MetricRef.Gauge) aggregation_;
      }
      return opentelemetry.proto.mmap.v1.Mmap.MetricRef.Gauge.getDefaultInstance();
    }
    /**
     * <code>.opentelemetry.proto.mmap.v1.MetricRef.Gauge gauge = 5;</code>
     */
    @java.lang.Override
    public opentelemetry.proto.mmap.v1.Mmap.MetricRef.GaugeOrBuilder getGaugeOrBuilder() {
      if (aggregationCase_ == 5) {
         return (opentelemetry.proto.mmap.v1.Mmap.MetricRef.Gauge) aggregation_;
      }
      return opentelemetry.proto.mmap.v1.Mmap.MetricRef.Gauge.getDefaultInstance();
    }

    public static final int SUM_FIELD_NUMBER = 6;
    /**
     * <code>.opentelemetry.proto.mmap.v1.MetricRef.Sum sum = 6;</code>
     * @return Whether the sum field is set.
     */
    @java.lang.Override
    public boolean hasSum() {
      return aggregationCase_ == 6;
    }
    /**
     * <code>.opentelemetry.proto.mmap.v1.MetricRef.Sum sum = 6;</code>
     * @return The sum.
     */
    @java.lang.Override
    public opentelemetry.proto.mmap.v1.Mmap.MetricRef.Sum getSum() {
      if (aggregationCase_ == 6) {
         return (opentelemetry.proto.mmap.v1.Mmap.MetricRef.Sum) aggregation_;
      }
      return opentelemetry.proto.mmap.v1.Mmap.MetricRef.Sum.getDefaultInstance();
    }
    /**
     * <code>.opentelemetry.proto.mmap.v1.MetricRef.Sum sum = 6;</code>
     */
    @java.lang.Override
    public opentelemetry.proto.mmap.v1.Mmap.MetricRef.SumOrBuilder getSumOrBuilder() {
      if (aggregationCase_ == 6) {
         return (opentelemetry.proto.mmap.v1.Mmap.MetricRef.Sum) aggregation_;
      }
      return opentelemetry.proto.mmap.v1.Mmap.MetricRef.Sum.getDefaultInstance();
    }

    public static final int HISTOGRAM_FIELD_NUMBER = 7;
    /**
     * <code>.opentelemetry.proto.mmap.v1.MetricRef.Histogram histogram = 7;</code>
     * @return Whether the histogram field is set.
     */
    @java.lang.Override
    public boolean hasHistogram() {
      return aggregationCase_ == 7;
    }
    /**
     * <code>.opentelemetry.proto.mmap.v1.MetricRef.Histogram histogram = 7;</code>
     * @return The histogram.
     */
    @java.lang.Override
    public opentelemetry.proto.mmap.v1.Mmap.MetricRef.Histogram getHistogram() {
      if (aggregationCase_ == 7) {
         return (opentelemetry.proto.mmap.v1.Mmap.MetricRef.Histogram) aggregation_;
      }
      return opentelemetry.proto.mmap.v1.Mmap.MetricRef.Histogram.getDefaultInstance();
    }
    /**
     * <code>.opentelemetry.proto.mmap.v1.MetricRef.Histogram histogram = 7;</code>
     */
    @java.lang.Override
    public opentelemetry.proto.mmap.v1.Mmap.MetricRef.HistogramOrBuilder getHistogramOrBuilder() {
      if (aggregationCase_ == 7) {
         return (opentelemetry.proto.mmap.v1.Mmap.MetricRef.Histogram) aggregation_;
      }
      return opentelemetry.proto.mmap.v1.Mmap.MetricRef.Histogram.getDefaultInstance();
    }

    public static final int EXP_HIST_FIELD_NUMBER = 8;
    /**
     * <code>.opentelemetry.proto.mmap.v1.MetricRef.ExponentialHistogram exp_hist = 8;</code>
     * @return Whether the expHist field is set.
     */
    @java.lang.Override
    public boolean hasExpHist() {
      return aggregationCase_ == 8;
    }
    /**
     * <code>.opentelemetry.proto.mmap.v1.MetricRef.ExponentialHistogram exp_hist = 8;</code>
     * @return The expHist.
     */
    @java.lang.Override
    public opentelemetry.proto.mmap.v1.Mmap.MetricRef.ExponentialHistogram getExpHist() {
      if (aggregationCase_ == 8) {
         return (opentelemetry.proto.mmap.v1.Mmap.MetricRef.ExponentialHistogram) aggregation_;
      }
      return opentelemetry.proto.mmap.v1.Mmap.MetricRef.ExponentialHistogram.getDefaultInstance();
    }
    /**
     * <code>.opentelemetry.proto.mmap.v1.MetricRef.ExponentialHistogram exp_hist = 8;</code>
     */
    @java.lang.Override
    public opentelemetry.proto.mmap.v1.Mmap.MetricRef.ExponentialHistogramOrBuilder getExpHistOrBuilder() {
      if (aggregationCase_ == 8) {
         return (opentelemetry.proto.mmap.v1.Mmap.MetricRef.ExponentialHistogram) aggregation_;
      }
      return opentelemetry.proto.mmap.v1.Mmap.MetricRef.ExponentialHistogram.getDefaultInstance();
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!com.google.protobuf.GeneratedMessage.isStringEmpty(name_)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 1, name_);
      }
      if (!com.google.protobuf.GeneratedMessage.isStringEmpty(description_)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 2, description_);
      }
      if (!com.google.protobuf.GeneratedMessage.isStringEmpty(unit_)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 3, unit_);
      }
      if (instrumentationScopeRef_ != 0L) {
        output.writeInt64(4, instrumentationScopeRef_);
      }
      if (aggregationCase_ == 5) {
        output.writeMessage(5, (opentelemetry.proto.mmap.v1.Mmap.MetricRef.Gauge) aggregation_);
      }
      if (aggregationCase_ == 6) {
        output.writeMessage(6, (opentelemetry.proto.mmap.v1.Mmap.MetricRef.Sum) aggregation_);
      }
      if (aggregationCase_ == 7) {
        output.writeMessage(7, (opentelemetry.proto.mmap.v1.Mmap.MetricRef.Histogram) aggregation_);
      }
      if (aggregationCase_ == 8) {
        output.writeMessage(8, (opentelemetry.proto.mmap.v1.Mmap.MetricRef.ExponentialHistogram) aggregation_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!com.google.protobuf.GeneratedMessage.isStringEmpty(name_)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(1, name_);
      }
      if (!com.google.protobuf.GeneratedMessage.isStringEmpty(description_)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(2, description_);
      }
      if (!com.google.protobuf.GeneratedMessage.isStringEmpty(unit_)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(3, unit_);
      }
      if (instrumentationScopeRef_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(4, instrumentationScopeRef_);
      }
      if (aggregationCase_ == 5) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(5, (opentelemetry.proto.mmap.v1.Mmap.MetricRef.Gauge) aggregation_);
      }
      if (aggregationCase_ == 6) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(6, (opentelemetry.proto.mmap.v1.Mmap.MetricRef.Sum) aggregation_);
      }
      if (aggregationCase_ == 7) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(7, (opentelemetry.proto.mmap.v1.Mmap.MetricRef.Histogram) aggregation_);
      }
      if (aggregationCase_ == 8) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(8, (opentelemetry.proto.mmap.v1.Mmap.MetricRef.ExponentialHistogram) aggregation_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof opentelemetry.proto.mmap.v1.Mmap.MetricRef)) {
        return super.equals(obj);
      }
      opentelemetry.proto.mmap.v1.Mmap.MetricRef other = (opentelemetry.proto.mmap.v1.Mmap.MetricRef) obj;

      if (!getName()
          .equals(other.getName())) return false;
      if (!getDescription()
          .equals(other.getDescription())) return false;
      if (!getUnit()
          .equals(other.getUnit())) return false;
      if (getInstrumentationScopeRef()
          != other.getInstrumentationScopeRef()) return false;
      if (!getAggregationCase().equals(other.getAggregationCase())) return false;
      switch (aggregationCase_) {
        case 5:
          if (!getGauge()
              .equals(other.getGauge())) return false;
          break;
        case 6:
          if (!getSum()
              .equals(other.getSum())) return false;
          break;
        case 7:
          if (!getHistogram()
              .equals(other.getHistogram())) return false;
          break;
        case 8:
          if (!getExpHist()
              .equals(other.getExpHist())) return false;
          break;
        case 0:
        default:
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + NAME_FIELD_NUMBER;
      hash = (53 * hash) + getName().hashCode();
      hash = (37 * hash) + DESCRIPTION_FIELD_NUMBER;
      hash = (53 * hash) + getDescription().hashCode();
      hash = (37 * hash) + UNIT_FIELD_NUMBER;
      hash = (53 * hash) + getUnit().hashCode();
      hash = (37 * hash) + INSTRUMENTATION_SCOPE_REF_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getInstrumentationScopeRef());
      switch (aggregationCase_) {
        case 5:
          hash = (37 * hash) + GAUGE_FIELD_NUMBER;
          hash = (53 * hash) + getGauge().hashCode();
          break;
        case 6:
          hash = (37 * hash) + SUM_FIELD_NUMBER;
          hash = (53 * hash) + getSum().hashCode();
          break;
        case 7:
          hash = (37 * hash) + HISTOGRAM_FIELD_NUMBER;
          hash = (53 * hash) + getHistogram().hashCode();
          break;
        case 8:
          hash = (37 * hash) + EXP_HIST_FIELD_NUMBER;
          hash = (53 * hash) + getExpHist().hashCode();
          break;
        case 0:
        default:
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static opentelemetry.proto.mmap.v1.Mmap.MetricRef parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.MetricRef parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.MetricRef parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.MetricRef parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.MetricRef parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.MetricRef parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.MetricRef parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.MetricRef parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static opentelemetry.proto.mmap.v1.Mmap.MetricRef parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static opentelemetry.proto.mmap.v1.Mmap.MetricRef parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.MetricRef parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.MetricRef parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(opentelemetry.proto.mmap.v1.Mmap.MetricRef prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code opentelemetry.proto.mmap.v1.MetricRef}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:opentelemetry.proto.mmap.v1.MetricRef)
        opentelemetry.proto.mmap.v1.Mmap.MetricRefOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_MetricRef_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_MetricRef_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                opentelemetry.proto.mmap.v1.Mmap.MetricRef.class, opentelemetry.proto.mmap.v1.Mmap.MetricRef.Builder.class);
      }

      // Construct using opentelemetry.proto.mmap.v1.Mmap.MetricRef.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        name_ = "";
        description_ = "";
        unit_ = "";
        instrumentationScopeRef_ = 0L;
        if (gaugeBuilder_ != null) {
          gaugeBuilder_.clear();
        }
        if (sumBuilder_ != null) {
          sumBuilder_.clear();
        }
        if (histogramBuilder_ != null) {
          histogramBuilder_.clear();
        }
        if (expHistBuilder_ != null) {
          expHistBuilder_.clear();
        }
        aggregationCase_ = 0;
        aggregation_ = null;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_MetricRef_descriptor;
      }

      @java.lang.Override
      public opentelemetry.proto.mmap.v1.Mmap.MetricRef getDefaultInstanceForType() {
        return opentelemetry.proto.mmap.v1.Mmap.MetricRef.getDefaultInstance();
      }

      @java.lang.Override
      public opentelemetry.proto.mmap.v1.Mmap.MetricRef build() {
        opentelemetry.proto.mmap.v1.Mmap.MetricRef result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public opentelemetry.proto.mmap.v1.Mmap.MetricRef buildPartial() {
        opentelemetry.proto.mmap.v1.Mmap.MetricRef result = new opentelemetry.proto.mmap.v1.Mmap.MetricRef(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        buildPartialOneofs(result);
        onBuilt();
        return result;
      }

      private void buildPartial0(opentelemetry.proto.mmap.v1.Mmap.MetricRef result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.name_ = name_;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.description_ = description_;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.unit_ = unit_;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.instrumentationScopeRef_ = instrumentationScopeRef_;
        }
      }

      private void buildPartialOneofs(opentelemetry.proto.mmap.v1.Mmap.MetricRef result) {
        result.aggregationCase_ = aggregationCase_;
        result.aggregation_ = this.aggregation_;
        if (aggregationCase_ == 5 &&
            gaugeBuilder_ != null) {
          result.aggregation_ = gaugeBuilder_.build();
        }
        if (aggregationCase_ == 6 &&
            sumBuilder_ != null) {
          result.aggregation_ = sumBuilder_.build();
        }
        if (aggregationCase_ == 7 &&
            histogramBuilder_ != null) {
          result.aggregation_ = histogramBuilder_.build();
        }
        if (aggregationCase_ == 8 &&
            expHistBuilder_ != null) {
          result.aggregation_ = expHistBuilder_.build();
        }
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof opentelemetry.proto.mmap.v1.Mmap.MetricRef) {
          return mergeFrom((opentelemetry.proto.mmap.v1.Mmap.MetricRef)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(opentelemetry.proto.mmap.v1.Mmap.MetricRef other) {
        if (other == opentelemetry.proto.mmap.v1.Mmap.MetricRef.getDefaultInstance()) return this;
        if (!other.getName().isEmpty()) {
          name_ = other.name_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        if (!other.getDescription().isEmpty()) {
          description_ = other.description_;
          bitField0_ |= 0x00000002;
          onChanged();
        }
        if (!other.getUnit().isEmpty()) {
          unit_ = other.unit_;
          bitField0_ |= 0x00000004;
          onChanged();
        }
        if (other.getInstrumentationScopeRef() != 0L) {
          setInstrumentationScopeRef(other.getInstrumentationScopeRef());
        }
        switch (other.getAggregationCase()) {
          case GAUGE: {
            mergeGauge(other.getGauge());
            break;
          }
          case SUM: {
            mergeSum(other.getSum());
            break;
          }
          case HISTOGRAM: {
            mergeHistogram(other.getHistogram());
            break;
          }
          case EXP_HIST: {
            mergeExpHist(other.getExpHist());
            break;
          }
          case AGGREGATION_NOT_SET: {
            break;
          }
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                name_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                description_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              case 26: {
                unit_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000004;
                break;
              } // case 26
              case 32: {
                instrumentationScopeRef_ = input.readInt64();
                bitField0_ |= 0x00000008;
                break;
              } // case 32
              case 42: {
                input.readMessage(
                    internalGetGaugeFieldBuilder().getBuilder(),
                    extensionRegistry);
                aggregationCase_ = 5;
                break;
              } // case 42
              case 50: {
                input.readMessage(
                    internalGetSumFieldBuilder().getBuilder(),
                    extensionRegistry);
                aggregationCase_ = 6;
                break;
              } // case 50
              case 58: {
                input.readMessage(
                    internalGetHistogramFieldBuilder().getBuilder(),
                    extensionRegistry);
                aggregationCase_ = 7;
                break;
              } // case 58
              case 66: {
                input.readMessage(
                    internalGetExpHistFieldBuilder().getBuilder(),
                    extensionRegistry);
                aggregationCase_ = 8;
                break;
              } // case 66
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int aggregationCase_ = 0;
      private java.lang.Object aggregation_;
      public AggregationCase
          getAggregationCase() {
        return AggregationCase.forNumber(
            aggregationCase_);
      }

      public Builder clearAggregation() {
        aggregationCase_ = 0;
        aggregation_ = null;
        onChanged();
        return this;
      }

      private int bitField0_;

      private java.lang.Object name_ = "";
      /**
       * <pre>
       * The name of the metric.
       * </pre>
       *
       * <code>string name = 1;</code>
       * @return The name.
       */
      public java.lang.String getName() {
        java.lang.Object ref = name_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          name_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The name of the metric.
       * </pre>
       *
       * <code>string name = 1;</code>
       * @return The bytes for name.
       */
      public com.google.protobuf.ByteString
          getNameBytes() {
        java.lang.Object ref = name_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          name_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The name of the metric.
       * </pre>
       *
       * <code>string name = 1;</code>
       * @param value The name to set.
       * @return This builder for chaining.
       */
      public Builder setName(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        name_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The name of the metric.
       * </pre>
       *
       * <code>string name = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearName() {
        name_ = getDefaultInstance().getName();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The name of the metric.
       * </pre>
       *
       * <code>string name = 1;</code>
       * @param value The bytes for name to set.
       * @return This builder for chaining.
       */
      public Builder setNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        name_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private java.lang.Object description_ = "";
      /**
       * <pre>
       * A description of the metric, which can be used in documentation.
       * </pre>
       *
       * <code>string description = 2;</code>
       * @return The description.
       */
      public java.lang.String getDescription() {
        java.lang.Object ref = description_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          description_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * A description of the metric, which can be used in documentation.
       * </pre>
       *
       * <code>string description = 2;</code>
       * @return The bytes for description.
       */
      public com.google.protobuf.ByteString
          getDescriptionBytes() {
        java.lang.Object ref = description_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          description_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * A description of the metric, which can be used in documentation.
       * </pre>
       *
       * <code>string description = 2;</code>
       * @param value The description to set.
       * @return This builder for chaining.
       */
      public Builder setDescription(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        description_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A description of the metric, which can be used in documentation.
       * </pre>
       *
       * <code>string description = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearDescription() {
        description_ = getDefaultInstance().getDescription();
        bitField0_ = (bitField0_ & ~0x00000002);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A description of the metric, which can be used in documentation.
       * </pre>
       *
       * <code>string description = 2;</code>
       * @param value The bytes for description to set.
       * @return This builder for chaining.
       */
      public Builder setDescriptionBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        description_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      private java.lang.Object unit_ = "";
      /**
       * <pre>
       * The unit in which the metric value is reported. Follows the format
       * described by https://unitsofmeasure.org/ucum.html.
       * </pre>
       *
       * <code>string unit = 3;</code>
       * @return The unit.
       */
      public java.lang.String getUnit() {
        java.lang.Object ref = unit_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          unit_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The unit in which the metric value is reported. Follows the format
       * described by https://unitsofmeasure.org/ucum.html.
       * </pre>
       *
       * <code>string unit = 3;</code>
       * @return The bytes for unit.
       */
      public com.google.protobuf.ByteString
          getUnitBytes() {
        java.lang.Object ref = unit_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          unit_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The unit in which the metric value is reported. Follows the format
       * described by https://unitsofmeasure.org/ucum.html.
       * </pre>
       *
       * <code>string unit = 3;</code>
       * @param value The unit to set.
       * @return This builder for chaining.
       */
      public Builder setUnit(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        unit_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The unit in which the metric value is reported. Follows the format
       * described by https://unitsofmeasure.org/ucum.html.
       * </pre>
       *
       * <code>string unit = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearUnit() {
        unit_ = getDefaultInstance().getUnit();
        bitField0_ = (bitField0_ & ~0x00000004);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The unit in which the metric value is reported. Follows the format
       * described by https://unitsofmeasure.org/ucum.html.
       * </pre>
       *
       * <code>string unit = 3;</code>
       * @param value The bytes for unit to set.
       * @return This builder for chaining.
       */
      public Builder setUnitBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        unit_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }

      private long instrumentationScopeRef_ ;
      /**
       * <pre>
       * Reference to the instrumentation scope where this metric is defined.
       * </pre>
       *
       * <code>int64 instrumentation_scope_ref = 4;</code>
       * @return The instrumentationScopeRef.
       */
      @java.lang.Override
      public long getInstrumentationScopeRef() {
        return instrumentationScopeRef_;
      }
      /**
       * <pre>
       * Reference to the instrumentation scope where this metric is defined.
       * </pre>
       *
       * <code>int64 instrumentation_scope_ref = 4;</code>
       * @param value The instrumentationScopeRef to set.
       * @return This builder for chaining.
       */
      public Builder setInstrumentationScopeRef(long value) {

        instrumentationScopeRef_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Reference to the instrumentation scope where this metric is defined.
       * </pre>
       *
       * <code>int64 instrumentation_scope_ref = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearInstrumentationScopeRef() {
        bitField0_ = (bitField0_ & ~0x00000008);
        instrumentationScopeRef_ = 0L;
        onChanged();
        return this;
      }

      private com.google.protobuf.SingleFieldBuilder<
          opentelemetry.proto.mmap.v1.Mmap.MetricRef.Gauge, opentelemetry.proto.mmap.v1.Mmap.MetricRef.Gauge.Builder, opentelemetry.proto.mmap.v1.Mmap.MetricRef.GaugeOrBuilder> gaugeBuilder_;
      /**
       * <code>.opentelemetry.proto.mmap.v1.MetricRef.Gauge gauge = 5;</code>
       * @return Whether the gauge field is set.
       */
      @java.lang.Override
      public boolean hasGauge() {
        return aggregationCase_ == 5;
      }
      /**
       * <code>.opentelemetry.proto.mmap.v1.MetricRef.Gauge gauge = 5;</code>
       * @return The gauge.
       */
      @java.lang.Override
      public opentelemetry.proto.mmap.v1.Mmap.MetricRef.Gauge getGauge() {
        if (gaugeBuilder_ == null) {
          if (aggregationCase_ == 5) {
            return (opentelemetry.proto.mmap.v1.Mmap.MetricRef.Gauge) aggregation_;
          }
          return opentelemetry.proto.mmap.v1.Mmap.MetricRef.Gauge.getDefaultInstance();
        } else {
          if (aggregationCase_ == 5) {
            return gaugeBuilder_.getMessage();
          }
          return opentelemetry.proto.mmap.v1.Mmap.MetricRef.Gauge.getDefaultInstance();
        }
      }
      /**
       * <code>.opentelemetry.proto.mmap.v1.MetricRef.Gauge gauge = 5;</code>
       */
      public Builder setGauge(opentelemetry.proto.mmap.v1.Mmap.MetricRef.Gauge value) {
        if (gaugeBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          aggregation_ = value;
          onChanged();
        } else {
          gaugeBuilder_.setMessage(value);
        }
        aggregationCase_ = 5;
        return this;
      }
      /**
       * <code>.opentelemetry.proto.mmap.v1.MetricRef.Gauge gauge = 5;</code>
       */
      public Builder setGauge(
          opentelemetry.proto.mmap.v1.Mmap.MetricRef.Gauge.Builder builderForValue) {
        if (gaugeBuilder_ == null) {
          aggregation_ = builderForValue.build();
          onChanged();
        } else {
          gaugeBuilder_.setMessage(builderForValue.build());
        }
        aggregationCase_ = 5;
        return this;
      }
      /**
       * <code>.opentelemetry.proto.mmap.v1.MetricRef.Gauge gauge = 5;</code>
       */
      public Builder mergeGauge(opentelemetry.proto.mmap.v1.Mmap.MetricRef.Gauge value) {
        if (gaugeBuilder_ == null) {
          if (aggregationCase_ == 5 &&
              aggregation_ != opentelemetry.proto.mmap.v1.Mmap.MetricRef.Gauge.getDefaultInstance()) {
            aggregation_ = opentelemetry.proto.mmap.v1.Mmap.MetricRef.Gauge.newBuilder((opentelemetry.proto.mmap.v1.Mmap.MetricRef.Gauge) aggregation_)
                .mergeFrom(value).buildPartial();
          } else {
            aggregation_ = value;
          }
          onChanged();
        } else {
          if (aggregationCase_ == 5) {
            gaugeBuilder_.mergeFrom(value);
          } else {
            gaugeBuilder_.setMessage(value);
          }
        }
        aggregationCase_ = 5;
        return this;
      }
      /**
       * <code>.opentelemetry.proto.mmap.v1.MetricRef.Gauge gauge = 5;</code>
       */
      public Builder clearGauge() {
        if (gaugeBuilder_ == null) {
          if (aggregationCase_ == 5) {
            aggregationCase_ = 0;
            aggregation_ = null;
            onChanged();
          }
        } else {
          if (aggregationCase_ == 5) {
            aggregationCase_ = 0;
            aggregation_ = null;
          }
          gaugeBuilder_.clear();
        }
        return this;
      }
      /**
       * <code>.opentelemetry.proto.mmap.v1.MetricRef.Gauge gauge = 5;</code>
       */
      public opentelemetry.proto.mmap.v1.Mmap.MetricRef.Gauge.Builder getGaugeBuilder() {
        return internalGetGaugeFieldBuilder().getBuilder();
      }
      /**
       * <code>.opentelemetry.proto.mmap.v1.MetricRef.Gauge gauge = 5;</code>
       */
      @java.lang.Override
      public opentelemetry.proto.mmap.v1.Mmap.MetricRef.GaugeOrBuilder getGaugeOrBuilder() {
        if ((aggregationCase_ == 5) && (gaugeBuilder_ != null)) {
          return gaugeBuilder_.getMessageOrBuilder();
        } else {
          if (aggregationCase_ == 5) {
            return (opentelemetry.proto.mmap.v1.Mmap.MetricRef.Gauge) aggregation_;
          }
          return opentelemetry.proto.mmap.v1.Mmap.MetricRef.Gauge.getDefaultInstance();
        }
      }
      /**
       * <code>.opentelemetry.proto.mmap.v1.MetricRef.Gauge gauge = 5;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          opentelemetry.proto.mmap.v1.Mmap.MetricRef.Gauge, opentelemetry.proto.mmap.v1.Mmap.MetricRef.Gauge.Builder, opentelemetry.proto.mmap.v1.Mmap.MetricRef.GaugeOrBuilder> 
          internalGetGaugeFieldBuilder() {
        if (gaugeBuilder_ == null) {
          if (!(aggregationCase_ == 5)) {
            aggregation_ = opentelemetry.proto.mmap.v1.Mmap.MetricRef.Gauge.getDefaultInstance();
          }
          gaugeBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              opentelemetry.proto.mmap.v1.Mmap.MetricRef.Gauge, opentelemetry.proto.mmap.v1.Mmap.MetricRef.Gauge.Builder, opentelemetry.proto.mmap.v1.Mmap.MetricRef.GaugeOrBuilder>(
                  (opentelemetry.proto.mmap.v1.Mmap.MetricRef.Gauge) aggregation_,
                  getParentForChildren(),
                  isClean());
          aggregation_ = null;
        }
        aggregationCase_ = 5;
        onChanged();
        return gaugeBuilder_;
      }

      private com.google.protobuf.SingleFieldBuilder<
          opentelemetry.proto.mmap.v1.Mmap.MetricRef.Sum, opentelemetry.proto.mmap.v1.Mmap.MetricRef.Sum.Builder, opentelemetry.proto.mmap.v1.Mmap.MetricRef.SumOrBuilder> sumBuilder_;
      /**
       * <code>.opentelemetry.proto.mmap.v1.MetricRef.Sum sum = 6;</code>
       * @return Whether the sum field is set.
       */
      @java.lang.Override
      public boolean hasSum() {
        return aggregationCase_ == 6;
      }
      /**
       * <code>.opentelemetry.proto.mmap.v1.MetricRef.Sum sum = 6;</code>
       * @return The sum.
       */
      @java.lang.Override
      public opentelemetry.proto.mmap.v1.Mmap.MetricRef.Sum getSum() {
        if (sumBuilder_ == null) {
          if (aggregationCase_ == 6) {
            return (opentelemetry.proto.mmap.v1.Mmap.MetricRef.Sum) aggregation_;
          }
          return opentelemetry.proto.mmap.v1.Mmap.MetricRef.Sum.getDefaultInstance();
        } else {
          if (aggregationCase_ == 6) {
            return sumBuilder_.getMessage();
          }
          return opentelemetry.proto.mmap.v1.Mmap.MetricRef.Sum.getDefaultInstance();
        }
      }
      /**
       * <code>.opentelemetry.proto.mmap.v1.MetricRef.Sum sum = 6;</code>
       */
      public Builder setSum(opentelemetry.proto.mmap.v1.Mmap.MetricRef.Sum value) {
        if (sumBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          aggregation_ = value;
          onChanged();
        } else {
          sumBuilder_.setMessage(value);
        }
        aggregationCase_ = 6;
        return this;
      }
      /**
       * <code>.opentelemetry.proto.mmap.v1.MetricRef.Sum sum = 6;</code>
       */
      public Builder setSum(
          opentelemetry.proto.mmap.v1.Mmap.MetricRef.Sum.Builder builderForValue) {
        if (sumBuilder_ == null) {
          aggregation_ = builderForValue.build();
          onChanged();
        } else {
          sumBuilder_.setMessage(builderForValue.build());
        }
        aggregationCase_ = 6;
        return this;
      }
      /**
       * <code>.opentelemetry.proto.mmap.v1.MetricRef.Sum sum = 6;</code>
       */
      public Builder mergeSum(opentelemetry.proto.mmap.v1.Mmap.MetricRef.Sum value) {
        if (sumBuilder_ == null) {
          if (aggregationCase_ == 6 &&
              aggregation_ != opentelemetry.proto.mmap.v1.Mmap.MetricRef.Sum.getDefaultInstance()) {
            aggregation_ = opentelemetry.proto.mmap.v1.Mmap.MetricRef.Sum.newBuilder((opentelemetry.proto.mmap.v1.Mmap.MetricRef.Sum) aggregation_)
                .mergeFrom(value).buildPartial();
          } else {
            aggregation_ = value;
          }
          onChanged();
        } else {
          if (aggregationCase_ == 6) {
            sumBuilder_.mergeFrom(value);
          } else {
            sumBuilder_.setMessage(value);
          }
        }
        aggregationCase_ = 6;
        return this;
      }
      /**
       * <code>.opentelemetry.proto.mmap.v1.MetricRef.Sum sum = 6;</code>
       */
      public Builder clearSum() {
        if (sumBuilder_ == null) {
          if (aggregationCase_ == 6) {
            aggregationCase_ = 0;
            aggregation_ = null;
            onChanged();
          }
        } else {
          if (aggregationCase_ == 6) {
            aggregationCase_ = 0;
            aggregation_ = null;
          }
          sumBuilder_.clear();
        }
        return this;
      }
      /**
       * <code>.opentelemetry.proto.mmap.v1.MetricRef.Sum sum = 6;</code>
       */
      public opentelemetry.proto.mmap.v1.Mmap.MetricRef.Sum.Builder getSumBuilder() {
        return internalGetSumFieldBuilder().getBuilder();
      }
      /**
       * <code>.opentelemetry.proto.mmap.v1.MetricRef.Sum sum = 6;</code>
       */
      @java.lang.Override
      public opentelemetry.proto.mmap.v1.Mmap.MetricRef.SumOrBuilder getSumOrBuilder() {
        if ((aggregationCase_ == 6) && (sumBuilder_ != null)) {
          return sumBuilder_.getMessageOrBuilder();
        } else {
          if (aggregationCase_ == 6) {
            return (opentelemetry.proto.mmap.v1.Mmap.MetricRef.Sum) aggregation_;
          }
          return opentelemetry.proto.mmap.v1.Mmap.MetricRef.Sum.getDefaultInstance();
        }
      }
      /**
       * <code>.opentelemetry.proto.mmap.v1.MetricRef.Sum sum = 6;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          opentelemetry.proto.mmap.v1.Mmap.MetricRef.Sum, opentelemetry.proto.mmap.v1.Mmap.MetricRef.Sum.Builder, opentelemetry.proto.mmap.v1.Mmap.MetricRef.SumOrBuilder> 
          internalGetSumFieldBuilder() {
        if (sumBuilder_ == null) {
          if (!(aggregationCase_ == 6)) {
            aggregation_ = opentelemetry.proto.mmap.v1.Mmap.MetricRef.Sum.getDefaultInstance();
          }
          sumBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              opentelemetry.proto.mmap.v1.Mmap.MetricRef.Sum, opentelemetry.proto.mmap.v1.Mmap.MetricRef.Sum.Builder, opentelemetry.proto.mmap.v1.Mmap.MetricRef.SumOrBuilder>(
                  (opentelemetry.proto.mmap.v1.Mmap.MetricRef.Sum) aggregation_,
                  getParentForChildren(),
                  isClean());
          aggregation_ = null;
        }
        aggregationCase_ = 6;
        onChanged();
        return sumBuilder_;
      }

      private com.google.protobuf.SingleFieldBuilder<
          opentelemetry.proto.mmap.v1.Mmap.MetricRef.Histogram, opentelemetry.proto.mmap.v1.Mmap.MetricRef.Histogram.Builder, opentelemetry.proto.mmap.v1.Mmap.MetricRef.HistogramOrBuilder> histogramBuilder_;
      /**
       * <code>.opentelemetry.proto.mmap.v1.MetricRef.Histogram histogram = 7;</code>
       * @return Whether the histogram field is set.
       */
      @java.lang.Override
      public boolean hasHistogram() {
        return aggregationCase_ == 7;
      }
      /**
       * <code>.opentelemetry.proto.mmap.v1.MetricRef.Histogram histogram = 7;</code>
       * @return The histogram.
       */
      @java.lang.Override
      public opentelemetry.proto.mmap.v1.Mmap.MetricRef.Histogram getHistogram() {
        if (histogramBuilder_ == null) {
          if (aggregationCase_ == 7) {
            return (opentelemetry.proto.mmap.v1.Mmap.MetricRef.Histogram) aggregation_;
          }
          return opentelemetry.proto.mmap.v1.Mmap.MetricRef.Histogram.getDefaultInstance();
        } else {
          if (aggregationCase_ == 7) {
            return histogramBuilder_.getMessage();
          }
          return opentelemetry.proto.mmap.v1.Mmap.MetricRef.Histogram.getDefaultInstance();
        }
      }
      /**
       * <code>.opentelemetry.proto.mmap.v1.MetricRef.Histogram histogram = 7;</code>
       */
      public Builder setHistogram(opentelemetry.proto.mmap.v1.Mmap.MetricRef.Histogram value) {
        if (histogramBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          aggregation_ = value;
          onChanged();
        } else {
          histogramBuilder_.setMessage(value);
        }
        aggregationCase_ = 7;
        return this;
      }
      /**
       * <code>.opentelemetry.proto.mmap.v1.MetricRef.Histogram histogram = 7;</code>
       */
      public Builder setHistogram(
          opentelemetry.proto.mmap.v1.Mmap.MetricRef.Histogram.Builder builderForValue) {
        if (histogramBuilder_ == null) {
          aggregation_ = builderForValue.build();
          onChanged();
        } else {
          histogramBuilder_.setMessage(builderForValue.build());
        }
        aggregationCase_ = 7;
        return this;
      }
      /**
       * <code>.opentelemetry.proto.mmap.v1.MetricRef.Histogram histogram = 7;</code>
       */
      public Builder mergeHistogram(opentelemetry.proto.mmap.v1.Mmap.MetricRef.Histogram value) {
        if (histogramBuilder_ == null) {
          if (aggregationCase_ == 7 &&
              aggregation_ != opentelemetry.proto.mmap.v1.Mmap.MetricRef.Histogram.getDefaultInstance()) {
            aggregation_ = opentelemetry.proto.mmap.v1.Mmap.MetricRef.Histogram.newBuilder((opentelemetry.proto.mmap.v1.Mmap.MetricRef.Histogram) aggregation_)
                .mergeFrom(value).buildPartial();
          } else {
            aggregation_ = value;
          }
          onChanged();
        } else {
          if (aggregationCase_ == 7) {
            histogramBuilder_.mergeFrom(value);
          } else {
            histogramBuilder_.setMessage(value);
          }
        }
        aggregationCase_ = 7;
        return this;
      }
      /**
       * <code>.opentelemetry.proto.mmap.v1.MetricRef.Histogram histogram = 7;</code>
       */
      public Builder clearHistogram() {
        if (histogramBuilder_ == null) {
          if (aggregationCase_ == 7) {
            aggregationCase_ = 0;
            aggregation_ = null;
            onChanged();
          }
        } else {
          if (aggregationCase_ == 7) {
            aggregationCase_ = 0;
            aggregation_ = null;
          }
          histogramBuilder_.clear();
        }
        return this;
      }
      /**
       * <code>.opentelemetry.proto.mmap.v1.MetricRef.Histogram histogram = 7;</code>
       */
      public opentelemetry.proto.mmap.v1.Mmap.MetricRef.Histogram.Builder getHistogramBuilder() {
        return internalGetHistogramFieldBuilder().getBuilder();
      }
      /**
       * <code>.opentelemetry.proto.mmap.v1.MetricRef.Histogram histogram = 7;</code>
       */
      @java.lang.Override
      public opentelemetry.proto.mmap.v1.Mmap.MetricRef.HistogramOrBuilder getHistogramOrBuilder() {
        if ((aggregationCase_ == 7) && (histogramBuilder_ != null)) {
          return histogramBuilder_.getMessageOrBuilder();
        } else {
          if (aggregationCase_ == 7) {
            return (opentelemetry.proto.mmap.v1.Mmap.MetricRef.Histogram) aggregation_;
          }
          return opentelemetry.proto.mmap.v1.Mmap.MetricRef.Histogram.getDefaultInstance();
        }
      }
      /**
       * <code>.opentelemetry.proto.mmap.v1.MetricRef.Histogram histogram = 7;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          opentelemetry.proto.mmap.v1.Mmap.MetricRef.Histogram, opentelemetry.proto.mmap.v1.Mmap.MetricRef.Histogram.Builder, opentelemetry.proto.mmap.v1.Mmap.MetricRef.HistogramOrBuilder> 
          internalGetHistogramFieldBuilder() {
        if (histogramBuilder_ == null) {
          if (!(aggregationCase_ == 7)) {
            aggregation_ = opentelemetry.proto.mmap.v1.Mmap.MetricRef.Histogram.getDefaultInstance();
          }
          histogramBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              opentelemetry.proto.mmap.v1.Mmap.MetricRef.Histogram, opentelemetry.proto.mmap.v1.Mmap.MetricRef.Histogram.Builder, opentelemetry.proto.mmap.v1.Mmap.MetricRef.HistogramOrBuilder>(
                  (opentelemetry.proto.mmap.v1.Mmap.MetricRef.Histogram) aggregation_,
                  getParentForChildren(),
                  isClean());
          aggregation_ = null;
        }
        aggregationCase_ = 7;
        onChanged();
        return histogramBuilder_;
      }

      private com.google.protobuf.SingleFieldBuilder<
          opentelemetry.proto.mmap.v1.Mmap.MetricRef.ExponentialHistogram, opentelemetry.proto.mmap.v1.Mmap.MetricRef.ExponentialHistogram.Builder, opentelemetry.proto.mmap.v1.Mmap.MetricRef.ExponentialHistogramOrBuilder> expHistBuilder_;
      /**
       * <code>.opentelemetry.proto.mmap.v1.MetricRef.ExponentialHistogram exp_hist = 8;</code>
       * @return Whether the expHist field is set.
       */
      @java.lang.Override
      public boolean hasExpHist() {
        return aggregationCase_ == 8;
      }
      /**
       * <code>.opentelemetry.proto.mmap.v1.MetricRef.ExponentialHistogram exp_hist = 8;</code>
       * @return The expHist.
       */
      @java.lang.Override
      public opentelemetry.proto.mmap.v1.Mmap.MetricRef.ExponentialHistogram getExpHist() {
        if (expHistBuilder_ == null) {
          if (aggregationCase_ == 8) {
            return (opentelemetry.proto.mmap.v1.Mmap.MetricRef.ExponentialHistogram) aggregation_;
          }
          return opentelemetry.proto.mmap.v1.Mmap.MetricRef.ExponentialHistogram.getDefaultInstance();
        } else {
          if (aggregationCase_ == 8) {
            return expHistBuilder_.getMessage();
          }
          return opentelemetry.proto.mmap.v1.Mmap.MetricRef.ExponentialHistogram.getDefaultInstance();
        }
      }
      /**
       * <code>.opentelemetry.proto.mmap.v1.MetricRef.ExponentialHistogram exp_hist = 8;</code>
       */
      public Builder setExpHist(opentelemetry.proto.mmap.v1.Mmap.MetricRef.ExponentialHistogram value) {
        if (expHistBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          aggregation_ = value;
          onChanged();
        } else {
          expHistBuilder_.setMessage(value);
        }
        aggregationCase_ = 8;
        return this;
      }
      /**
       * <code>.opentelemetry.proto.mmap.v1.MetricRef.ExponentialHistogram exp_hist = 8;</code>
       */
      public Builder setExpHist(
          opentelemetry.proto.mmap.v1.Mmap.MetricRef.ExponentialHistogram.Builder builderForValue) {
        if (expHistBuilder_ == null) {
          aggregation_ = builderForValue.build();
          onChanged();
        } else {
          expHistBuilder_.setMessage(builderForValue.build());
        }
        aggregationCase_ = 8;
        return this;
      }
      /**
       * <code>.opentelemetry.proto.mmap.v1.MetricRef.ExponentialHistogram exp_hist = 8;</code>
       */
      public Builder mergeExpHist(opentelemetry.proto.mmap.v1.Mmap.MetricRef.ExponentialHistogram value) {
        if (expHistBuilder_ == null) {
          if (aggregationCase_ == 8 &&
              aggregation_ != opentelemetry.proto.mmap.v1.Mmap.MetricRef.ExponentialHistogram.getDefaultInstance()) {
            aggregation_ = opentelemetry.proto.mmap.v1.Mmap.MetricRef.ExponentialHistogram.newBuilder((opentelemetry.proto.mmap.v1.Mmap.MetricRef.ExponentialHistogram) aggregation_)
                .mergeFrom(value).buildPartial();
          } else {
            aggregation_ = value;
          }
          onChanged();
        } else {
          if (aggregationCase_ == 8) {
            expHistBuilder_.mergeFrom(value);
          } else {
            expHistBuilder_.setMessage(value);
          }
        }
        aggregationCase_ = 8;
        return this;
      }
      /**
       * <code>.opentelemetry.proto.mmap.v1.MetricRef.ExponentialHistogram exp_hist = 8;</code>
       */
      public Builder clearExpHist() {
        if (expHistBuilder_ == null) {
          if (aggregationCase_ == 8) {
            aggregationCase_ = 0;
            aggregation_ = null;
            onChanged();
          }
        } else {
          if (aggregationCase_ == 8) {
            aggregationCase_ = 0;
            aggregation_ = null;
          }
          expHistBuilder_.clear();
        }
        return this;
      }
      /**
       * <code>.opentelemetry.proto.mmap.v1.MetricRef.ExponentialHistogram exp_hist = 8;</code>
       */
      public opentelemetry.proto.mmap.v1.Mmap.MetricRef.ExponentialHistogram.Builder getExpHistBuilder() {
        return internalGetExpHistFieldBuilder().getBuilder();
      }
      /**
       * <code>.opentelemetry.proto.mmap.v1.MetricRef.ExponentialHistogram exp_hist = 8;</code>
       */
      @java.lang.Override
      public opentelemetry.proto.mmap.v1.Mmap.MetricRef.ExponentialHistogramOrBuilder getExpHistOrBuilder() {
        if ((aggregationCase_ == 8) && (expHistBuilder_ != null)) {
          return expHistBuilder_.getMessageOrBuilder();
        } else {
          if (aggregationCase_ == 8) {
            return (opentelemetry.proto.mmap.v1.Mmap.MetricRef.ExponentialHistogram) aggregation_;
          }
          return opentelemetry.proto.mmap.v1.Mmap.MetricRef.ExponentialHistogram.getDefaultInstance();
        }
      }
      /**
       * <code>.opentelemetry.proto.mmap.v1.MetricRef.ExponentialHistogram exp_hist = 8;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          opentelemetry.proto.mmap.v1.Mmap.MetricRef.ExponentialHistogram, opentelemetry.proto.mmap.v1.Mmap.MetricRef.ExponentialHistogram.Builder, opentelemetry.proto.mmap.v1.Mmap.MetricRef.ExponentialHistogramOrBuilder> 
          internalGetExpHistFieldBuilder() {
        if (expHistBuilder_ == null) {
          if (!(aggregationCase_ == 8)) {
            aggregation_ = opentelemetry.proto.mmap.v1.Mmap.MetricRef.ExponentialHistogram.getDefaultInstance();
          }
          expHistBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              opentelemetry.proto.mmap.v1.Mmap.MetricRef.ExponentialHistogram, opentelemetry.proto.mmap.v1.Mmap.MetricRef.ExponentialHistogram.Builder, opentelemetry.proto.mmap.v1.Mmap.MetricRef.ExponentialHistogramOrBuilder>(
                  (opentelemetry.proto.mmap.v1.Mmap.MetricRef.ExponentialHistogram) aggregation_,
                  getParentForChildren(),
                  isClean());
          aggregation_ = null;
        }
        aggregationCase_ = 8;
        onChanged();
        return expHistBuilder_;
      }

      // @@protoc_insertion_point(builder_scope:opentelemetry.proto.mmap.v1.MetricRef)
    }

    // @@protoc_insertion_point(class_scope:opentelemetry.proto.mmap.v1.MetricRef)
    private static final opentelemetry.proto.mmap.v1.Mmap.MetricRef DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new opentelemetry.proto.mmap.v1.Mmap.MetricRef();
    }

    public static opentelemetry.proto.mmap.v1.Mmap.MetricRef getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<MetricRef>
        PARSER = new com.google.protobuf.AbstractParser<MetricRef>() {
      @java.lang.Override
      public MetricRef parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<MetricRef> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<MetricRef> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public opentelemetry.proto.mmap.v1.Mmap.MetricRef getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface EventOrBuilder extends
      // @@protoc_insertion_point(interface_extends:opentelemetry.proto.mmap.v1.Event)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * InsturmentationScope from which this was recorded.
     * </pre>
     *
     * <code>int64 scope_ref = 1;</code>
     * @return The scopeRef.
     */
    long getScopeRef();

    /**
     * <pre>
     * time_unix_nano is the time when the event occurred.
     * Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January 1970.
     * Value of 0 indicates unknown or missing timestamp.
     * </pre>
     *
     * <code>fixed64 time_unix_nano = 2;</code>
     * @return The timeUnixNano.
     */
    long getTimeUnixNano();

    /**
     * <pre>
     * Numerical value of the severity, normalized to values described in Log Data Model.
     * [Optional].
     * </pre>
     *
     * <code>.opentelemetry.proto.mmap.v1.SeverityNumber severity_number = 3;</code>
     * @return The enum numeric value on the wire for severityNumber.
     */
    int getSeverityNumberValue();
    /**
     * <pre>
     * Numerical value of the severity, normalized to values described in Log Data Model.
     * [Optional].
     * </pre>
     *
     * <code>.opentelemetry.proto.mmap.v1.SeverityNumber severity_number = 3;</code>
     * @return The severityNumber.
     */
    opentelemetry.proto.mmap.v1.Mmap.SeverityNumber getSeverityNumber();

    /**
     * <pre>
     * The severity text (also known as log level). The original string representation as
     * it is known at the source. [Optional].
     * </pre>
     *
     * <code>string severity_text = 4;</code>
     * @return The severityText.
     */
    java.lang.String getSeverityText();
    /**
     * <pre>
     * The severity text (also known as log level). The original string representation as
     * it is known at the source. [Optional].
     * </pre>
     *
     * <code>string severity_text = 4;</code>
     * @return The bytes for severityText.
     */
    com.google.protobuf.ByteString
        getSeverityTextBytes();

    /**
     * <pre>
     * A value containing the body of the log record. Can be for example a human-readable
     * string message (including multi-line) describing the event in a free form or it can
     * be a structured data composed of arrays and maps of other values. [Optional].
     * </pre>
     *
     * <code>.opentelemetry.proto.mmap.v1.AnyValue body = 5;</code>
     * @return Whether the body field is set.
     */
    boolean hasBody();
    /**
     * <pre>
     * A value containing the body of the log record. Can be for example a human-readable
     * string message (including multi-line) describing the event in a free form or it can
     * be a structured data composed of arrays and maps of other values. [Optional].
     * </pre>
     *
     * <code>.opentelemetry.proto.mmap.v1.AnyValue body = 5;</code>
     * @return The body.
     */
    opentelemetry.proto.mmap.v1.Mmap.AnyValue getBody();
    /**
     * <pre>
     * A value containing the body of the log record. Can be for example a human-readable
     * string message (including multi-line) describing the event in a free form or it can
     * be a structured data composed of arrays and maps of other values. [Optional].
     * </pre>
     *
     * <code>.opentelemetry.proto.mmap.v1.AnyValue body = 5;</code>
     */
    opentelemetry.proto.mmap.v1.Mmap.AnyValueOrBuilder getBodyOrBuilder();

    /**
     * <pre>
     * A unique identifier of event category/type.
     * All events with the same event_name are expected to conform to the same
     * schema for both their attributes and their body.
     *
     * Recommended to be fully qualified and short (no longer than 256 characters).
     *
     * Presence of event_name on the log record identifies this record
     * as an event.
     *
     * [Optional].
     * </pre>
     *
     * <code>int64 event_name_ref = 6;</code>
     * @return The eventNameRef.
     */
    long getEventNameRef();

    /**
     * <pre>
     * Span information in which this event was recorded.
     * [Optional].
     * </pre>
     *
     * <code>.opentelemetry.proto.mmap.v1.SpanContext span_context = 7;</code>
     * @return Whether the spanContext field is set.
     */
    boolean hasSpanContext();
    /**
     * <pre>
     * Span information in which this event was recorded.
     * [Optional].
     * </pre>
     *
     * <code>.opentelemetry.proto.mmap.v1.SpanContext span_context = 7;</code>
     * @return The spanContext.
     */
    opentelemetry.proto.mmap.v1.Mmap.SpanContext getSpanContext();
    /**
     * <pre>
     * Span information in which this event was recorded.
     * [Optional].
     * </pre>
     *
     * <code>.opentelemetry.proto.mmap.v1.SpanContext span_context = 7;</code>
     */
    opentelemetry.proto.mmap.v1.Mmap.SpanContextOrBuilder getSpanContextOrBuilder();

    /**
     * <pre>
     * Attributes about this event.
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 8;</code>
     */
    java.util.List<opentelemetry.proto.mmap.v1.Mmap.KeyValueRef> 
        getAttributesList();
    /**
     * <pre>
     * Attributes about this event.
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 8;</code>
     */
    opentelemetry.proto.mmap.v1.Mmap.KeyValueRef getAttributes(int index);
    /**
     * <pre>
     * Attributes about this event.
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 8;</code>
     */
    int getAttributesCount();
    /**
     * <pre>
     * Attributes about this event.
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 8;</code>
     */
    java.util.List<? extends opentelemetry.proto.mmap.v1.Mmap.KeyValueRefOrBuilder> 
        getAttributesOrBuilderList();
    /**
     * <pre>
     * Attributes about this event.
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 8;</code>
     */
    opentelemetry.proto.mmap.v1.Mmap.KeyValueRefOrBuilder getAttributesOrBuilder(
        int index);
  }
  /**
   * Protobuf type {@code opentelemetry.proto.mmap.v1.Event}
   */
  public static final class Event extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:opentelemetry.proto.mmap.v1.Event)
      EventOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 33,
        /* patch= */ 0,
        /* suffix= */ "",
        "Event");
    }
    // Use Event.newBuilder() to construct.
    private Event(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private Event() {
      severityNumber_ = 0;
      severityText_ = "";
      attributes_ = java.util.Collections.emptyList();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_Event_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_Event_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              opentelemetry.proto.mmap.v1.Mmap.Event.class, opentelemetry.proto.mmap.v1.Mmap.Event.Builder.class);
    }

    private int bitField0_;
    public static final int SCOPE_REF_FIELD_NUMBER = 1;
    private long scopeRef_ = 0L;
    /**
     * <pre>
     * InsturmentationScope from which this was recorded.
     * </pre>
     *
     * <code>int64 scope_ref = 1;</code>
     * @return The scopeRef.
     */
    @java.lang.Override
    public long getScopeRef() {
      return scopeRef_;
    }

    public static final int TIME_UNIX_NANO_FIELD_NUMBER = 2;
    private long timeUnixNano_ = 0L;
    /**
     * <pre>
     * time_unix_nano is the time when the event occurred.
     * Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January 1970.
     * Value of 0 indicates unknown or missing timestamp.
     * </pre>
     *
     * <code>fixed64 time_unix_nano = 2;</code>
     * @return The timeUnixNano.
     */
    @java.lang.Override
    public long getTimeUnixNano() {
      return timeUnixNano_;
    }

    public static final int SEVERITY_NUMBER_FIELD_NUMBER = 3;
    private int severityNumber_ = 0;
    /**
     * <pre>
     * Numerical value of the severity, normalized to values described in Log Data Model.
     * [Optional].
     * </pre>
     *
     * <code>.opentelemetry.proto.mmap.v1.SeverityNumber severity_number = 3;</code>
     * @return The enum numeric value on the wire for severityNumber.
     */
    @java.lang.Override public int getSeverityNumberValue() {
      return severityNumber_;
    }
    /**
     * <pre>
     * Numerical value of the severity, normalized to values described in Log Data Model.
     * [Optional].
     * </pre>
     *
     * <code>.opentelemetry.proto.mmap.v1.SeverityNumber severity_number = 3;</code>
     * @return The severityNumber.
     */
    @java.lang.Override public opentelemetry.proto.mmap.v1.Mmap.SeverityNumber getSeverityNumber() {
      opentelemetry.proto.mmap.v1.Mmap.SeverityNumber result = opentelemetry.proto.mmap.v1.Mmap.SeverityNumber.forNumber(severityNumber_);
      return result == null ? opentelemetry.proto.mmap.v1.Mmap.SeverityNumber.UNRECOGNIZED : result;
    }

    public static final int SEVERITY_TEXT_FIELD_NUMBER = 4;
    @SuppressWarnings("serial")
    private volatile java.lang.Object severityText_ = "";
    /**
     * <pre>
     * The severity text (also known as log level). The original string representation as
     * it is known at the source. [Optional].
     * </pre>
     *
     * <code>string severity_text = 4;</code>
     * @return The severityText.
     */
    @java.lang.Override
    public java.lang.String getSeverityText() {
      java.lang.Object ref = severityText_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        severityText_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * The severity text (also known as log level). The original string representation as
     * it is known at the source. [Optional].
     * </pre>
     *
     * <code>string severity_text = 4;</code>
     * @return The bytes for severityText.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getSeverityTextBytes() {
      java.lang.Object ref = severityText_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        severityText_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int BODY_FIELD_NUMBER = 5;
    private opentelemetry.proto.mmap.v1.Mmap.AnyValue body_;
    /**
     * <pre>
     * A value containing the body of the log record. Can be for example a human-readable
     * string message (including multi-line) describing the event in a free form or it can
     * be a structured data composed of arrays and maps of other values. [Optional].
     * </pre>
     *
     * <code>.opentelemetry.proto.mmap.v1.AnyValue body = 5;</code>
     * @return Whether the body field is set.
     */
    @java.lang.Override
    public boolean hasBody() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * A value containing the body of the log record. Can be for example a human-readable
     * string message (including multi-line) describing the event in a free form or it can
     * be a structured data composed of arrays and maps of other values. [Optional].
     * </pre>
     *
     * <code>.opentelemetry.proto.mmap.v1.AnyValue body = 5;</code>
     * @return The body.
     */
    @java.lang.Override
    public opentelemetry.proto.mmap.v1.Mmap.AnyValue getBody() {
      return body_ == null ? opentelemetry.proto.mmap.v1.Mmap.AnyValue.getDefaultInstance() : body_;
    }
    /**
     * <pre>
     * A value containing the body of the log record. Can be for example a human-readable
     * string message (including multi-line) describing the event in a free form or it can
     * be a structured data composed of arrays and maps of other values. [Optional].
     * </pre>
     *
     * <code>.opentelemetry.proto.mmap.v1.AnyValue body = 5;</code>
     */
    @java.lang.Override
    public opentelemetry.proto.mmap.v1.Mmap.AnyValueOrBuilder getBodyOrBuilder() {
      return body_ == null ? opentelemetry.proto.mmap.v1.Mmap.AnyValue.getDefaultInstance() : body_;
    }

    public static final int EVENT_NAME_REF_FIELD_NUMBER = 6;
    private long eventNameRef_ = 0L;
    /**
     * <pre>
     * A unique identifier of event category/type.
     * All events with the same event_name are expected to conform to the same
     * schema for both their attributes and their body.
     *
     * Recommended to be fully qualified and short (no longer than 256 characters).
     *
     * Presence of event_name on the log record identifies this record
     * as an event.
     *
     * [Optional].
     * </pre>
     *
     * <code>int64 event_name_ref = 6;</code>
     * @return The eventNameRef.
     */
    @java.lang.Override
    public long getEventNameRef() {
      return eventNameRef_;
    }

    public static final int SPAN_CONTEXT_FIELD_NUMBER = 7;
    private opentelemetry.proto.mmap.v1.Mmap.SpanContext spanContext_;
    /**
     * <pre>
     * Span information in which this event was recorded.
     * [Optional].
     * </pre>
     *
     * <code>.opentelemetry.proto.mmap.v1.SpanContext span_context = 7;</code>
     * @return Whether the spanContext field is set.
     */
    @java.lang.Override
    public boolean hasSpanContext() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Span information in which this event was recorded.
     * [Optional].
     * </pre>
     *
     * <code>.opentelemetry.proto.mmap.v1.SpanContext span_context = 7;</code>
     * @return The spanContext.
     */
    @java.lang.Override
    public opentelemetry.proto.mmap.v1.Mmap.SpanContext getSpanContext() {
      return spanContext_ == null ? opentelemetry.proto.mmap.v1.Mmap.SpanContext.getDefaultInstance() : spanContext_;
    }
    /**
     * <pre>
     * Span information in which this event was recorded.
     * [Optional].
     * </pre>
     *
     * <code>.opentelemetry.proto.mmap.v1.SpanContext span_context = 7;</code>
     */
    @java.lang.Override
    public opentelemetry.proto.mmap.v1.Mmap.SpanContextOrBuilder getSpanContextOrBuilder() {
      return spanContext_ == null ? opentelemetry.proto.mmap.v1.Mmap.SpanContext.getDefaultInstance() : spanContext_;
    }

    public static final int ATTRIBUTES_FIELD_NUMBER = 8;
    @SuppressWarnings("serial")
    private java.util.List<opentelemetry.proto.mmap.v1.Mmap.KeyValueRef> attributes_;
    /**
     * <pre>
     * Attributes about this event.
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 8;</code>
     */
    @java.lang.Override
    public java.util.List<opentelemetry.proto.mmap.v1.Mmap.KeyValueRef> getAttributesList() {
      return attributes_;
    }
    /**
     * <pre>
     * Attributes about this event.
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 8;</code>
     */
    @java.lang.Override
    public java.util.List<? extends opentelemetry.proto.mmap.v1.Mmap.KeyValueRefOrBuilder> 
        getAttributesOrBuilderList() {
      return attributes_;
    }
    /**
     * <pre>
     * Attributes about this event.
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 8;</code>
     */
    @java.lang.Override
    public int getAttributesCount() {
      return attributes_.size();
    }
    /**
     * <pre>
     * Attributes about this event.
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 8;</code>
     */
    @java.lang.Override
    public opentelemetry.proto.mmap.v1.Mmap.KeyValueRef getAttributes(int index) {
      return attributes_.get(index);
    }
    /**
     * <pre>
     * Attributes about this event.
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 8;</code>
     */
    @java.lang.Override
    public opentelemetry.proto.mmap.v1.Mmap.KeyValueRefOrBuilder getAttributesOrBuilder(
        int index) {
      return attributes_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (scopeRef_ != 0L) {
        output.writeInt64(1, scopeRef_);
      }
      if (timeUnixNano_ != 0L) {
        output.writeFixed64(2, timeUnixNano_);
      }
      if (severityNumber_ != opentelemetry.proto.mmap.v1.Mmap.SeverityNumber.SEVERITY_NUMBER_UNSPECIFIED.getNumber()) {
        output.writeEnum(3, severityNumber_);
      }
      if (!com.google.protobuf.GeneratedMessage.isStringEmpty(severityText_)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 4, severityText_);
      }
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeMessage(5, getBody());
      }
      if (eventNameRef_ != 0L) {
        output.writeInt64(6, eventNameRef_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeMessage(7, getSpanContext());
      }
      for (int i = 0; i < attributes_.size(); i++) {
        output.writeMessage(8, attributes_.get(i));
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (scopeRef_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(1, scopeRef_);
      }
      if (timeUnixNano_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeFixed64Size(2, timeUnixNano_);
      }
      if (severityNumber_ != opentelemetry.proto.mmap.v1.Mmap.SeverityNumber.SEVERITY_NUMBER_UNSPECIFIED.getNumber()) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(3, severityNumber_);
      }
      if (!com.google.protobuf.GeneratedMessage.isStringEmpty(severityText_)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(4, severityText_);
      }
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(5, getBody());
      }
      if (eventNameRef_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(6, eventNameRef_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(7, getSpanContext());
      }
      for (int i = 0; i < attributes_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(8, attributes_.get(i));
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof opentelemetry.proto.mmap.v1.Mmap.Event)) {
        return super.equals(obj);
      }
      opentelemetry.proto.mmap.v1.Mmap.Event other = (opentelemetry.proto.mmap.v1.Mmap.Event) obj;

      if (getScopeRef()
          != other.getScopeRef()) return false;
      if (getTimeUnixNano()
          != other.getTimeUnixNano()) return false;
      if (severityNumber_ != other.severityNumber_) return false;
      if (!getSeverityText()
          .equals(other.getSeverityText())) return false;
      if (hasBody() != other.hasBody()) return false;
      if (hasBody()) {
        if (!getBody()
            .equals(other.getBody())) return false;
      }
      if (getEventNameRef()
          != other.getEventNameRef()) return false;
      if (hasSpanContext() != other.hasSpanContext()) return false;
      if (hasSpanContext()) {
        if (!getSpanContext()
            .equals(other.getSpanContext())) return false;
      }
      if (!getAttributesList()
          .equals(other.getAttributesList())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + SCOPE_REF_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getScopeRef());
      hash = (37 * hash) + TIME_UNIX_NANO_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getTimeUnixNano());
      hash = (37 * hash) + SEVERITY_NUMBER_FIELD_NUMBER;
      hash = (53 * hash) + severityNumber_;
      hash = (37 * hash) + SEVERITY_TEXT_FIELD_NUMBER;
      hash = (53 * hash) + getSeverityText().hashCode();
      if (hasBody()) {
        hash = (37 * hash) + BODY_FIELD_NUMBER;
        hash = (53 * hash) + getBody().hashCode();
      }
      hash = (37 * hash) + EVENT_NAME_REF_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getEventNameRef());
      if (hasSpanContext()) {
        hash = (37 * hash) + SPAN_CONTEXT_FIELD_NUMBER;
        hash = (53 * hash) + getSpanContext().hashCode();
      }
      if (getAttributesCount() > 0) {
        hash = (37 * hash) + ATTRIBUTES_FIELD_NUMBER;
        hash = (53 * hash) + getAttributesList().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static opentelemetry.proto.mmap.v1.Mmap.Event parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.Event parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.Event parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.Event parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.Event parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.Event parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.Event parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.Event parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static opentelemetry.proto.mmap.v1.Mmap.Event parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static opentelemetry.proto.mmap.v1.Mmap.Event parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.Event parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.Event parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(opentelemetry.proto.mmap.v1.Mmap.Event prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code opentelemetry.proto.mmap.v1.Event}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:opentelemetry.proto.mmap.v1.Event)
        opentelemetry.proto.mmap.v1.Mmap.EventOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_Event_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_Event_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                opentelemetry.proto.mmap.v1.Mmap.Event.class, opentelemetry.proto.mmap.v1.Mmap.Event.Builder.class);
      }

      // Construct using opentelemetry.proto.mmap.v1.Mmap.Event.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage
                .alwaysUseFieldBuilders) {
          internalGetBodyFieldBuilder();
          internalGetSpanContextFieldBuilder();
          internalGetAttributesFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        scopeRef_ = 0L;
        timeUnixNano_ = 0L;
        severityNumber_ = 0;
        severityText_ = "";
        body_ = null;
        if (bodyBuilder_ != null) {
          bodyBuilder_.dispose();
          bodyBuilder_ = null;
        }
        eventNameRef_ = 0L;
        spanContext_ = null;
        if (spanContextBuilder_ != null) {
          spanContextBuilder_.dispose();
          spanContextBuilder_ = null;
        }
        if (attributesBuilder_ == null) {
          attributes_ = java.util.Collections.emptyList();
        } else {
          attributes_ = null;
          attributesBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000080);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_Event_descriptor;
      }

      @java.lang.Override
      public opentelemetry.proto.mmap.v1.Mmap.Event getDefaultInstanceForType() {
        return opentelemetry.proto.mmap.v1.Mmap.Event.getDefaultInstance();
      }

      @java.lang.Override
      public opentelemetry.proto.mmap.v1.Mmap.Event build() {
        opentelemetry.proto.mmap.v1.Mmap.Event result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public opentelemetry.proto.mmap.v1.Mmap.Event buildPartial() {
        opentelemetry.proto.mmap.v1.Mmap.Event result = new opentelemetry.proto.mmap.v1.Mmap.Event(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(opentelemetry.proto.mmap.v1.Mmap.Event result) {
        if (attributesBuilder_ == null) {
          if (((bitField0_ & 0x00000080) != 0)) {
            attributes_ = java.util.Collections.unmodifiableList(attributes_);
            bitField0_ = (bitField0_ & ~0x00000080);
          }
          result.attributes_ = attributes_;
        } else {
          result.attributes_ = attributesBuilder_.build();
        }
      }

      private void buildPartial0(opentelemetry.proto.mmap.v1.Mmap.Event result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.scopeRef_ = scopeRef_;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.timeUnixNano_ = timeUnixNano_;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.severityNumber_ = severityNumber_;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.severityText_ = severityText_;
        }
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.body_ = bodyBuilder_ == null
              ? body_
              : bodyBuilder_.build();
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000020) != 0)) {
          result.eventNameRef_ = eventNameRef_;
        }
        if (((from_bitField0_ & 0x00000040) != 0)) {
          result.spanContext_ = spanContextBuilder_ == null
              ? spanContext_
              : spanContextBuilder_.build();
          to_bitField0_ |= 0x00000002;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof opentelemetry.proto.mmap.v1.Mmap.Event) {
          return mergeFrom((opentelemetry.proto.mmap.v1.Mmap.Event)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(opentelemetry.proto.mmap.v1.Mmap.Event other) {
        if (other == opentelemetry.proto.mmap.v1.Mmap.Event.getDefaultInstance()) return this;
        if (other.getScopeRef() != 0L) {
          setScopeRef(other.getScopeRef());
        }
        if (other.getTimeUnixNano() != 0L) {
          setTimeUnixNano(other.getTimeUnixNano());
        }
        if (other.severityNumber_ != 0) {
          setSeverityNumberValue(other.getSeverityNumberValue());
        }
        if (!other.getSeverityText().isEmpty()) {
          severityText_ = other.severityText_;
          bitField0_ |= 0x00000008;
          onChanged();
        }
        if (other.hasBody()) {
          mergeBody(other.getBody());
        }
        if (other.getEventNameRef() != 0L) {
          setEventNameRef(other.getEventNameRef());
        }
        if (other.hasSpanContext()) {
          mergeSpanContext(other.getSpanContext());
        }
        if (attributesBuilder_ == null) {
          if (!other.attributes_.isEmpty()) {
            if (attributes_.isEmpty()) {
              attributes_ = other.attributes_;
              bitField0_ = (bitField0_ & ~0x00000080);
            } else {
              ensureAttributesIsMutable();
              attributes_.addAll(other.attributes_);
            }
            onChanged();
          }
        } else {
          if (!other.attributes_.isEmpty()) {
            if (attributesBuilder_.isEmpty()) {
              attributesBuilder_.dispose();
              attributesBuilder_ = null;
              attributes_ = other.attributes_;
              bitField0_ = (bitField0_ & ~0x00000080);
              attributesBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   internalGetAttributesFieldBuilder() : null;
            } else {
              attributesBuilder_.addAllMessages(other.attributes_);
            }
          }
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8: {
                scopeRef_ = input.readInt64();
                bitField0_ |= 0x00000001;
                break;
              } // case 8
              case 17: {
                timeUnixNano_ = input.readFixed64();
                bitField0_ |= 0x00000002;
                break;
              } // case 17
              case 24: {
                severityNumber_ = input.readEnum();
                bitField0_ |= 0x00000004;
                break;
              } // case 24
              case 34: {
                severityText_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000008;
                break;
              } // case 34
              case 42: {
                input.readMessage(
                    internalGetBodyFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000010;
                break;
              } // case 42
              case 48: {
                eventNameRef_ = input.readInt64();
                bitField0_ |= 0x00000020;
                break;
              } // case 48
              case 58: {
                input.readMessage(
                    internalGetSpanContextFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000040;
                break;
              } // case 58
              case 66: {
                opentelemetry.proto.mmap.v1.Mmap.KeyValueRef m =
                    input.readMessage(
                        opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.parser(),
                        extensionRegistry);
                if (attributesBuilder_ == null) {
                  ensureAttributesIsMutable();
                  attributes_.add(m);
                } else {
                  attributesBuilder_.addMessage(m);
                }
                break;
              } // case 66
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private long scopeRef_ ;
      /**
       * <pre>
       * InsturmentationScope from which this was recorded.
       * </pre>
       *
       * <code>int64 scope_ref = 1;</code>
       * @return The scopeRef.
       */
      @java.lang.Override
      public long getScopeRef() {
        return scopeRef_;
      }
      /**
       * <pre>
       * InsturmentationScope from which this was recorded.
       * </pre>
       *
       * <code>int64 scope_ref = 1;</code>
       * @param value The scopeRef to set.
       * @return This builder for chaining.
       */
      public Builder setScopeRef(long value) {

        scopeRef_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * InsturmentationScope from which this was recorded.
       * </pre>
       *
       * <code>int64 scope_ref = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearScopeRef() {
        bitField0_ = (bitField0_ & ~0x00000001);
        scopeRef_ = 0L;
        onChanged();
        return this;
      }

      private long timeUnixNano_ ;
      /**
       * <pre>
       * time_unix_nano is the time when the event occurred.
       * Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January 1970.
       * Value of 0 indicates unknown or missing timestamp.
       * </pre>
       *
       * <code>fixed64 time_unix_nano = 2;</code>
       * @return The timeUnixNano.
       */
      @java.lang.Override
      public long getTimeUnixNano() {
        return timeUnixNano_;
      }
      /**
       * <pre>
       * time_unix_nano is the time when the event occurred.
       * Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January 1970.
       * Value of 0 indicates unknown or missing timestamp.
       * </pre>
       *
       * <code>fixed64 time_unix_nano = 2;</code>
       * @param value The timeUnixNano to set.
       * @return This builder for chaining.
       */
      public Builder setTimeUnixNano(long value) {

        timeUnixNano_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * time_unix_nano is the time when the event occurred.
       * Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January 1970.
       * Value of 0 indicates unknown or missing timestamp.
       * </pre>
       *
       * <code>fixed64 time_unix_nano = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearTimeUnixNano() {
        bitField0_ = (bitField0_ & ~0x00000002);
        timeUnixNano_ = 0L;
        onChanged();
        return this;
      }

      private int severityNumber_ = 0;
      /**
       * <pre>
       * Numerical value of the severity, normalized to values described in Log Data Model.
       * [Optional].
       * </pre>
       *
       * <code>.opentelemetry.proto.mmap.v1.SeverityNumber severity_number = 3;</code>
       * @return The enum numeric value on the wire for severityNumber.
       */
      @java.lang.Override public int getSeverityNumberValue() {
        return severityNumber_;
      }
      /**
       * <pre>
       * Numerical value of the severity, normalized to values described in Log Data Model.
       * [Optional].
       * </pre>
       *
       * <code>.opentelemetry.proto.mmap.v1.SeverityNumber severity_number = 3;</code>
       * @param value The enum numeric value on the wire for severityNumber to set.
       * @return This builder for chaining.
       */
      public Builder setSeverityNumberValue(int value) {
        severityNumber_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Numerical value of the severity, normalized to values described in Log Data Model.
       * [Optional].
       * </pre>
       *
       * <code>.opentelemetry.proto.mmap.v1.SeverityNumber severity_number = 3;</code>
       * @return The severityNumber.
       */
      @java.lang.Override
      public opentelemetry.proto.mmap.v1.Mmap.SeverityNumber getSeverityNumber() {
        opentelemetry.proto.mmap.v1.Mmap.SeverityNumber result = opentelemetry.proto.mmap.v1.Mmap.SeverityNumber.forNumber(severityNumber_);
        return result == null ? opentelemetry.proto.mmap.v1.Mmap.SeverityNumber.UNRECOGNIZED : result;
      }
      /**
       * <pre>
       * Numerical value of the severity, normalized to values described in Log Data Model.
       * [Optional].
       * </pre>
       *
       * <code>.opentelemetry.proto.mmap.v1.SeverityNumber severity_number = 3;</code>
       * @param value The severityNumber to set.
       * @return This builder for chaining.
       */
      public Builder setSeverityNumber(opentelemetry.proto.mmap.v1.Mmap.SeverityNumber value) {
        if (value == null) { throw new NullPointerException(); }
        bitField0_ |= 0x00000004;
        severityNumber_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Numerical value of the severity, normalized to values described in Log Data Model.
       * [Optional].
       * </pre>
       *
       * <code>.opentelemetry.proto.mmap.v1.SeverityNumber severity_number = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearSeverityNumber() {
        bitField0_ = (bitField0_ & ~0x00000004);
        severityNumber_ = 0;
        onChanged();
        return this;
      }

      private java.lang.Object severityText_ = "";
      /**
       * <pre>
       * The severity text (also known as log level). The original string representation as
       * it is known at the source. [Optional].
       * </pre>
       *
       * <code>string severity_text = 4;</code>
       * @return The severityText.
       */
      public java.lang.String getSeverityText() {
        java.lang.Object ref = severityText_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          severityText_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The severity text (also known as log level). The original string representation as
       * it is known at the source. [Optional].
       * </pre>
       *
       * <code>string severity_text = 4;</code>
       * @return The bytes for severityText.
       */
      public com.google.protobuf.ByteString
          getSeverityTextBytes() {
        java.lang.Object ref = severityText_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          severityText_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The severity text (also known as log level). The original string representation as
       * it is known at the source. [Optional].
       * </pre>
       *
       * <code>string severity_text = 4;</code>
       * @param value The severityText to set.
       * @return This builder for chaining.
       */
      public Builder setSeverityText(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        severityText_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The severity text (also known as log level). The original string representation as
       * it is known at the source. [Optional].
       * </pre>
       *
       * <code>string severity_text = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearSeverityText() {
        severityText_ = getDefaultInstance().getSeverityText();
        bitField0_ = (bitField0_ & ~0x00000008);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The severity text (also known as log level). The original string representation as
       * it is known at the source. [Optional].
       * </pre>
       *
       * <code>string severity_text = 4;</code>
       * @param value The bytes for severityText to set.
       * @return This builder for chaining.
       */
      public Builder setSeverityTextBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        severityText_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }

      private opentelemetry.proto.mmap.v1.Mmap.AnyValue body_;
      private com.google.protobuf.SingleFieldBuilder<
          opentelemetry.proto.mmap.v1.Mmap.AnyValue, opentelemetry.proto.mmap.v1.Mmap.AnyValue.Builder, opentelemetry.proto.mmap.v1.Mmap.AnyValueOrBuilder> bodyBuilder_;
      /**
       * <pre>
       * A value containing the body of the log record. Can be for example a human-readable
       * string message (including multi-line) describing the event in a free form or it can
       * be a structured data composed of arrays and maps of other values. [Optional].
       * </pre>
       *
       * <code>.opentelemetry.proto.mmap.v1.AnyValue body = 5;</code>
       * @return Whether the body field is set.
       */
      public boolean hasBody() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <pre>
       * A value containing the body of the log record. Can be for example a human-readable
       * string message (including multi-line) describing the event in a free form or it can
       * be a structured data composed of arrays and maps of other values. [Optional].
       * </pre>
       *
       * <code>.opentelemetry.proto.mmap.v1.AnyValue body = 5;</code>
       * @return The body.
       */
      public opentelemetry.proto.mmap.v1.Mmap.AnyValue getBody() {
        if (bodyBuilder_ == null) {
          return body_ == null ? opentelemetry.proto.mmap.v1.Mmap.AnyValue.getDefaultInstance() : body_;
        } else {
          return bodyBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * A value containing the body of the log record. Can be for example a human-readable
       * string message (including multi-line) describing the event in a free form or it can
       * be a structured data composed of arrays and maps of other values. [Optional].
       * </pre>
       *
       * <code>.opentelemetry.proto.mmap.v1.AnyValue body = 5;</code>
       */
      public Builder setBody(opentelemetry.proto.mmap.v1.Mmap.AnyValue value) {
        if (bodyBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          body_ = value;
        } else {
          bodyBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A value containing the body of the log record. Can be for example a human-readable
       * string message (including multi-line) describing the event in a free form or it can
       * be a structured data composed of arrays and maps of other values. [Optional].
       * </pre>
       *
       * <code>.opentelemetry.proto.mmap.v1.AnyValue body = 5;</code>
       */
      public Builder setBody(
          opentelemetry.proto.mmap.v1.Mmap.AnyValue.Builder builderForValue) {
        if (bodyBuilder_ == null) {
          body_ = builderForValue.build();
        } else {
          bodyBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A value containing the body of the log record. Can be for example a human-readable
       * string message (including multi-line) describing the event in a free form or it can
       * be a structured data composed of arrays and maps of other values. [Optional].
       * </pre>
       *
       * <code>.opentelemetry.proto.mmap.v1.AnyValue body = 5;</code>
       */
      public Builder mergeBody(opentelemetry.proto.mmap.v1.Mmap.AnyValue value) {
        if (bodyBuilder_ == null) {
          if (((bitField0_ & 0x00000010) != 0) &&
            body_ != null &&
            body_ != opentelemetry.proto.mmap.v1.Mmap.AnyValue.getDefaultInstance()) {
            getBodyBuilder().mergeFrom(value);
          } else {
            body_ = value;
          }
        } else {
          bodyBuilder_.mergeFrom(value);
        }
        if (body_ != null) {
          bitField0_ |= 0x00000010;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * A value containing the body of the log record. Can be for example a human-readable
       * string message (including multi-line) describing the event in a free form or it can
       * be a structured data composed of arrays and maps of other values. [Optional].
       * </pre>
       *
       * <code>.opentelemetry.proto.mmap.v1.AnyValue body = 5;</code>
       */
      public Builder clearBody() {
        bitField0_ = (bitField0_ & ~0x00000010);
        body_ = null;
        if (bodyBuilder_ != null) {
          bodyBuilder_.dispose();
          bodyBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A value containing the body of the log record. Can be for example a human-readable
       * string message (including multi-line) describing the event in a free form or it can
       * be a structured data composed of arrays and maps of other values. [Optional].
       * </pre>
       *
       * <code>.opentelemetry.proto.mmap.v1.AnyValue body = 5;</code>
       */
      public opentelemetry.proto.mmap.v1.Mmap.AnyValue.Builder getBodyBuilder() {
        bitField0_ |= 0x00000010;
        onChanged();
        return internalGetBodyFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * A value containing the body of the log record. Can be for example a human-readable
       * string message (including multi-line) describing the event in a free form or it can
       * be a structured data composed of arrays and maps of other values. [Optional].
       * </pre>
       *
       * <code>.opentelemetry.proto.mmap.v1.AnyValue body = 5;</code>
       */
      public opentelemetry.proto.mmap.v1.Mmap.AnyValueOrBuilder getBodyOrBuilder() {
        if (bodyBuilder_ != null) {
          return bodyBuilder_.getMessageOrBuilder();
        } else {
          return body_ == null ?
              opentelemetry.proto.mmap.v1.Mmap.AnyValue.getDefaultInstance() : body_;
        }
      }
      /**
       * <pre>
       * A value containing the body of the log record. Can be for example a human-readable
       * string message (including multi-line) describing the event in a free form or it can
       * be a structured data composed of arrays and maps of other values. [Optional].
       * </pre>
       *
       * <code>.opentelemetry.proto.mmap.v1.AnyValue body = 5;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          opentelemetry.proto.mmap.v1.Mmap.AnyValue, opentelemetry.proto.mmap.v1.Mmap.AnyValue.Builder, opentelemetry.proto.mmap.v1.Mmap.AnyValueOrBuilder> 
          internalGetBodyFieldBuilder() {
        if (bodyBuilder_ == null) {
          bodyBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              opentelemetry.proto.mmap.v1.Mmap.AnyValue, opentelemetry.proto.mmap.v1.Mmap.AnyValue.Builder, opentelemetry.proto.mmap.v1.Mmap.AnyValueOrBuilder>(
                  getBody(),
                  getParentForChildren(),
                  isClean());
          body_ = null;
        }
        return bodyBuilder_;
      }

      private long eventNameRef_ ;
      /**
       * <pre>
       * A unique identifier of event category/type.
       * All events with the same event_name are expected to conform to the same
       * schema for both their attributes and their body.
       *
       * Recommended to be fully qualified and short (no longer than 256 characters).
       *
       * Presence of event_name on the log record identifies this record
       * as an event.
       *
       * [Optional].
       * </pre>
       *
       * <code>int64 event_name_ref = 6;</code>
       * @return The eventNameRef.
       */
      @java.lang.Override
      public long getEventNameRef() {
        return eventNameRef_;
      }
      /**
       * <pre>
       * A unique identifier of event category/type.
       * All events with the same event_name are expected to conform to the same
       * schema for both their attributes and their body.
       *
       * Recommended to be fully qualified and short (no longer than 256 characters).
       *
       * Presence of event_name on the log record identifies this record
       * as an event.
       *
       * [Optional].
       * </pre>
       *
       * <code>int64 event_name_ref = 6;</code>
       * @param value The eventNameRef to set.
       * @return This builder for chaining.
       */
      public Builder setEventNameRef(long value) {

        eventNameRef_ = value;
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A unique identifier of event category/type.
       * All events with the same event_name are expected to conform to the same
       * schema for both their attributes and their body.
       *
       * Recommended to be fully qualified and short (no longer than 256 characters).
       *
       * Presence of event_name on the log record identifies this record
       * as an event.
       *
       * [Optional].
       * </pre>
       *
       * <code>int64 event_name_ref = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearEventNameRef() {
        bitField0_ = (bitField0_ & ~0x00000020);
        eventNameRef_ = 0L;
        onChanged();
        return this;
      }

      private opentelemetry.proto.mmap.v1.Mmap.SpanContext spanContext_;
      private com.google.protobuf.SingleFieldBuilder<
          opentelemetry.proto.mmap.v1.Mmap.SpanContext, opentelemetry.proto.mmap.v1.Mmap.SpanContext.Builder, opentelemetry.proto.mmap.v1.Mmap.SpanContextOrBuilder> spanContextBuilder_;
      /**
       * <pre>
       * Span information in which this event was recorded.
       * [Optional].
       * </pre>
       *
       * <code>.opentelemetry.proto.mmap.v1.SpanContext span_context = 7;</code>
       * @return Whether the spanContext field is set.
       */
      public boolean hasSpanContext() {
        return ((bitField0_ & 0x00000040) != 0);
      }
      /**
       * <pre>
       * Span information in which this event was recorded.
       * [Optional].
       * </pre>
       *
       * <code>.opentelemetry.proto.mmap.v1.SpanContext span_context = 7;</code>
       * @return The spanContext.
       */
      public opentelemetry.proto.mmap.v1.Mmap.SpanContext getSpanContext() {
        if (spanContextBuilder_ == null) {
          return spanContext_ == null ? opentelemetry.proto.mmap.v1.Mmap.SpanContext.getDefaultInstance() : spanContext_;
        } else {
          return spanContextBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Span information in which this event was recorded.
       * [Optional].
       * </pre>
       *
       * <code>.opentelemetry.proto.mmap.v1.SpanContext span_context = 7;</code>
       */
      public Builder setSpanContext(opentelemetry.proto.mmap.v1.Mmap.SpanContext value) {
        if (spanContextBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          spanContext_ = value;
        } else {
          spanContextBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000040;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Span information in which this event was recorded.
       * [Optional].
       * </pre>
       *
       * <code>.opentelemetry.proto.mmap.v1.SpanContext span_context = 7;</code>
       */
      public Builder setSpanContext(
          opentelemetry.proto.mmap.v1.Mmap.SpanContext.Builder builderForValue) {
        if (spanContextBuilder_ == null) {
          spanContext_ = builderForValue.build();
        } else {
          spanContextBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000040;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Span information in which this event was recorded.
       * [Optional].
       * </pre>
       *
       * <code>.opentelemetry.proto.mmap.v1.SpanContext span_context = 7;</code>
       */
      public Builder mergeSpanContext(opentelemetry.proto.mmap.v1.Mmap.SpanContext value) {
        if (spanContextBuilder_ == null) {
          if (((bitField0_ & 0x00000040) != 0) &&
            spanContext_ != null &&
            spanContext_ != opentelemetry.proto.mmap.v1.Mmap.SpanContext.getDefaultInstance()) {
            getSpanContextBuilder().mergeFrom(value);
          } else {
            spanContext_ = value;
          }
        } else {
          spanContextBuilder_.mergeFrom(value);
        }
        if (spanContext_ != null) {
          bitField0_ |= 0x00000040;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * Span information in which this event was recorded.
       * [Optional].
       * </pre>
       *
       * <code>.opentelemetry.proto.mmap.v1.SpanContext span_context = 7;</code>
       */
      public Builder clearSpanContext() {
        bitField0_ = (bitField0_ & ~0x00000040);
        spanContext_ = null;
        if (spanContextBuilder_ != null) {
          spanContextBuilder_.dispose();
          spanContextBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Span information in which this event was recorded.
       * [Optional].
       * </pre>
       *
       * <code>.opentelemetry.proto.mmap.v1.SpanContext span_context = 7;</code>
       */
      public opentelemetry.proto.mmap.v1.Mmap.SpanContext.Builder getSpanContextBuilder() {
        bitField0_ |= 0x00000040;
        onChanged();
        return internalGetSpanContextFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Span information in which this event was recorded.
       * [Optional].
       * </pre>
       *
       * <code>.opentelemetry.proto.mmap.v1.SpanContext span_context = 7;</code>
       */
      public opentelemetry.proto.mmap.v1.Mmap.SpanContextOrBuilder getSpanContextOrBuilder() {
        if (spanContextBuilder_ != null) {
          return spanContextBuilder_.getMessageOrBuilder();
        } else {
          return spanContext_ == null ?
              opentelemetry.proto.mmap.v1.Mmap.SpanContext.getDefaultInstance() : spanContext_;
        }
      }
      /**
       * <pre>
       * Span information in which this event was recorded.
       * [Optional].
       * </pre>
       *
       * <code>.opentelemetry.proto.mmap.v1.SpanContext span_context = 7;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          opentelemetry.proto.mmap.v1.Mmap.SpanContext, opentelemetry.proto.mmap.v1.Mmap.SpanContext.Builder, opentelemetry.proto.mmap.v1.Mmap.SpanContextOrBuilder> 
          internalGetSpanContextFieldBuilder() {
        if (spanContextBuilder_ == null) {
          spanContextBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              opentelemetry.proto.mmap.v1.Mmap.SpanContext, opentelemetry.proto.mmap.v1.Mmap.SpanContext.Builder, opentelemetry.proto.mmap.v1.Mmap.SpanContextOrBuilder>(
                  getSpanContext(),
                  getParentForChildren(),
                  isClean());
          spanContext_ = null;
        }
        return spanContextBuilder_;
      }

      private java.util.List<opentelemetry.proto.mmap.v1.Mmap.KeyValueRef> attributes_ =
        java.util.Collections.emptyList();
      private void ensureAttributesIsMutable() {
        if (!((bitField0_ & 0x00000080) != 0)) {
          attributes_ = new java.util.ArrayList<opentelemetry.proto.mmap.v1.Mmap.KeyValueRef>(attributes_);
          bitField0_ |= 0x00000080;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          opentelemetry.proto.mmap.v1.Mmap.KeyValueRef, opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.Builder, opentelemetry.proto.mmap.v1.Mmap.KeyValueRefOrBuilder> attributesBuilder_;

      /**
       * <pre>
       * Attributes about this event.
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 8;</code>
       */
      public java.util.List<opentelemetry.proto.mmap.v1.Mmap.KeyValueRef> getAttributesList() {
        if (attributesBuilder_ == null) {
          return java.util.Collections.unmodifiableList(attributes_);
        } else {
          return attributesBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * Attributes about this event.
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 8;</code>
       */
      public int getAttributesCount() {
        if (attributesBuilder_ == null) {
          return attributes_.size();
        } else {
          return attributesBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * Attributes about this event.
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 8;</code>
       */
      public opentelemetry.proto.mmap.v1.Mmap.KeyValueRef getAttributes(int index) {
        if (attributesBuilder_ == null) {
          return attributes_.get(index);
        } else {
          return attributesBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * Attributes about this event.
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 8;</code>
       */
      public Builder setAttributes(
          int index, opentelemetry.proto.mmap.v1.Mmap.KeyValueRef value) {
        if (attributesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureAttributesIsMutable();
          attributes_.set(index, value);
          onChanged();
        } else {
          attributesBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Attributes about this event.
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 8;</code>
       */
      public Builder setAttributes(
          int index, opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.Builder builderForValue) {
        if (attributesBuilder_ == null) {
          ensureAttributesIsMutable();
          attributes_.set(index, builderForValue.build());
          onChanged();
        } else {
          attributesBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Attributes about this event.
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 8;</code>
       */
      public Builder addAttributes(opentelemetry.proto.mmap.v1.Mmap.KeyValueRef value) {
        if (attributesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureAttributesIsMutable();
          attributes_.add(value);
          onChanged();
        } else {
          attributesBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * Attributes about this event.
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 8;</code>
       */
      public Builder addAttributes(
          int index, opentelemetry.proto.mmap.v1.Mmap.KeyValueRef value) {
        if (attributesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureAttributesIsMutable();
          attributes_.add(index, value);
          onChanged();
        } else {
          attributesBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Attributes about this event.
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 8;</code>
       */
      public Builder addAttributes(
          opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.Builder builderForValue) {
        if (attributesBuilder_ == null) {
          ensureAttributesIsMutable();
          attributes_.add(builderForValue.build());
          onChanged();
        } else {
          attributesBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Attributes about this event.
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 8;</code>
       */
      public Builder addAttributes(
          int index, opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.Builder builderForValue) {
        if (attributesBuilder_ == null) {
          ensureAttributesIsMutable();
          attributes_.add(index, builderForValue.build());
          onChanged();
        } else {
          attributesBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Attributes about this event.
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 8;</code>
       */
      public Builder addAllAttributes(
          java.lang.Iterable<? extends opentelemetry.proto.mmap.v1.Mmap.KeyValueRef> values) {
        if (attributesBuilder_ == null) {
          ensureAttributesIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, attributes_);
          onChanged();
        } else {
          attributesBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * Attributes about this event.
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 8;</code>
       */
      public Builder clearAttributes() {
        if (attributesBuilder_ == null) {
          attributes_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000080);
          onChanged();
        } else {
          attributesBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Attributes about this event.
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 8;</code>
       */
      public Builder removeAttributes(int index) {
        if (attributesBuilder_ == null) {
          ensureAttributesIsMutable();
          attributes_.remove(index);
          onChanged();
        } else {
          attributesBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * Attributes about this event.
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 8;</code>
       */
      public opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.Builder getAttributesBuilder(
          int index) {
        return internalGetAttributesFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * Attributes about this event.
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 8;</code>
       */
      public opentelemetry.proto.mmap.v1.Mmap.KeyValueRefOrBuilder getAttributesOrBuilder(
          int index) {
        if (attributesBuilder_ == null) {
          return attributes_.get(index);  } else {
          return attributesBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * Attributes about this event.
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 8;</code>
       */
      public java.util.List<? extends opentelemetry.proto.mmap.v1.Mmap.KeyValueRefOrBuilder> 
           getAttributesOrBuilderList() {
        if (attributesBuilder_ != null) {
          return attributesBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(attributes_);
        }
      }
      /**
       * <pre>
       * Attributes about this event.
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 8;</code>
       */
      public opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.Builder addAttributesBuilder() {
        return internalGetAttributesFieldBuilder().addBuilder(
            opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.getDefaultInstance());
      }
      /**
       * <pre>
       * Attributes about this event.
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 8;</code>
       */
      public opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.Builder addAttributesBuilder(
          int index) {
        return internalGetAttributesFieldBuilder().addBuilder(
            index, opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.getDefaultInstance());
      }
      /**
       * <pre>
       * Attributes about this event.
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 8;</code>
       */
      public java.util.List<opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.Builder> 
           getAttributesBuilderList() {
        return internalGetAttributesFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          opentelemetry.proto.mmap.v1.Mmap.KeyValueRef, opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.Builder, opentelemetry.proto.mmap.v1.Mmap.KeyValueRefOrBuilder> 
          internalGetAttributesFieldBuilder() {
        if (attributesBuilder_ == null) {
          attributesBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              opentelemetry.proto.mmap.v1.Mmap.KeyValueRef, opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.Builder, opentelemetry.proto.mmap.v1.Mmap.KeyValueRefOrBuilder>(
                  attributes_,
                  ((bitField0_ & 0x00000080) != 0),
                  getParentForChildren(),
                  isClean());
          attributes_ = null;
        }
        return attributesBuilder_;
      }

      // @@protoc_insertion_point(builder_scope:opentelemetry.proto.mmap.v1.Event)
    }

    // @@protoc_insertion_point(class_scope:opentelemetry.proto.mmap.v1.Event)
    private static final opentelemetry.proto.mmap.v1.Mmap.Event DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new opentelemetry.proto.mmap.v1.Mmap.Event();
    }

    public static opentelemetry.proto.mmap.v1.Mmap.Event getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<Event>
        PARSER = new com.google.protobuf.AbstractParser<Event>() {
      @java.lang.Override
      public Event parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<Event> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<Event> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public opentelemetry.proto.mmap.v1.Mmap.Event getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ResourceOrBuilder extends
      // @@protoc_insertion_point(interface_extends:opentelemetry.proto.mmap.v1.Resource)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Set of attributes that describe the resource.
     * Attribute keys MUST be unique (it is not allowed to have more than one
     * attribute with the same key).
     *
     * The attribute values SHOULD NOT contain empty values.
     * The attribute values SHOULD NOT contain bytes values.
     * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
     * double values.
     * The attribute values SHOULD NOT contain kvlist values.
     * The behavior of software that receives attributes containing such values can be unpredictable.
     * These restrictions can change in a minor release.
     * The restrictions take origin from the OpenTelemetry specification:
     * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 1;</code>
     */
    java.util.List<opentelemetry.proto.mmap.v1.Mmap.KeyValueRef> 
        getAttributesList();
    /**
     * <pre>
     * Set of attributes that describe the resource.
     * Attribute keys MUST be unique (it is not allowed to have more than one
     * attribute with the same key).
     *
     * The attribute values SHOULD NOT contain empty values.
     * The attribute values SHOULD NOT contain bytes values.
     * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
     * double values.
     * The attribute values SHOULD NOT contain kvlist values.
     * The behavior of software that receives attributes containing such values can be unpredictable.
     * These restrictions can change in a minor release.
     * The restrictions take origin from the OpenTelemetry specification:
     * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 1;</code>
     */
    opentelemetry.proto.mmap.v1.Mmap.KeyValueRef getAttributes(int index);
    /**
     * <pre>
     * Set of attributes that describe the resource.
     * Attribute keys MUST be unique (it is not allowed to have more than one
     * attribute with the same key).
     *
     * The attribute values SHOULD NOT contain empty values.
     * The attribute values SHOULD NOT contain bytes values.
     * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
     * double values.
     * The attribute values SHOULD NOT contain kvlist values.
     * The behavior of software that receives attributes containing such values can be unpredictable.
     * These restrictions can change in a minor release.
     * The restrictions take origin from the OpenTelemetry specification:
     * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 1;</code>
     */
    int getAttributesCount();
    /**
     * <pre>
     * Set of attributes that describe the resource.
     * Attribute keys MUST be unique (it is not allowed to have more than one
     * attribute with the same key).
     *
     * The attribute values SHOULD NOT contain empty values.
     * The attribute values SHOULD NOT contain bytes values.
     * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
     * double values.
     * The attribute values SHOULD NOT contain kvlist values.
     * The behavior of software that receives attributes containing such values can be unpredictable.
     * These restrictions can change in a minor release.
     * The restrictions take origin from the OpenTelemetry specification:
     * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 1;</code>
     */
    java.util.List<? extends opentelemetry.proto.mmap.v1.Mmap.KeyValueRefOrBuilder> 
        getAttributesOrBuilderList();
    /**
     * <pre>
     * Set of attributes that describe the resource.
     * Attribute keys MUST be unique (it is not allowed to have more than one
     * attribute with the same key).
     *
     * The attribute values SHOULD NOT contain empty values.
     * The attribute values SHOULD NOT contain bytes values.
     * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
     * double values.
     * The attribute values SHOULD NOT contain kvlist values.
     * The behavior of software that receives attributes containing such values can be unpredictable.
     * These restrictions can change in a minor release.
     * The restrictions take origin from the OpenTelemetry specification:
     * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 1;</code>
     */
    opentelemetry.proto.mmap.v1.Mmap.KeyValueRefOrBuilder getAttributesOrBuilder(
        int index);

    /**
     * <pre>
     * The number of dropped attributes. If the value is 0, then
     * no attributes were dropped.
     * </pre>
     *
     * <code>uint32 dropped_attributes_count = 2;</code>
     * @return The droppedAttributesCount.
     */
    int getDroppedAttributesCount();
  }
  /**
   * <pre>
   * Resource information.
   * </pre>
   *
   * Protobuf type {@code opentelemetry.proto.mmap.v1.Resource}
   */
  public static final class Resource extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:opentelemetry.proto.mmap.v1.Resource)
      ResourceOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 33,
        /* patch= */ 0,
        /* suffix= */ "",
        "Resource");
    }
    // Use Resource.newBuilder() to construct.
    private Resource(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private Resource() {
      attributes_ = java.util.Collections.emptyList();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_Resource_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_Resource_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              opentelemetry.proto.mmap.v1.Mmap.Resource.class, opentelemetry.proto.mmap.v1.Mmap.Resource.Builder.class);
    }

    public static final int ATTRIBUTES_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private java.util.List<opentelemetry.proto.mmap.v1.Mmap.KeyValueRef> attributes_;
    /**
     * <pre>
     * Set of attributes that describe the resource.
     * Attribute keys MUST be unique (it is not allowed to have more than one
     * attribute with the same key).
     *
     * The attribute values SHOULD NOT contain empty values.
     * The attribute values SHOULD NOT contain bytes values.
     * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
     * double values.
     * The attribute values SHOULD NOT contain kvlist values.
     * The behavior of software that receives attributes containing such values can be unpredictable.
     * These restrictions can change in a minor release.
     * The restrictions take origin from the OpenTelemetry specification:
     * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 1;</code>
     */
    @java.lang.Override
    public java.util.List<opentelemetry.proto.mmap.v1.Mmap.KeyValueRef> getAttributesList() {
      return attributes_;
    }
    /**
     * <pre>
     * Set of attributes that describe the resource.
     * Attribute keys MUST be unique (it is not allowed to have more than one
     * attribute with the same key).
     *
     * The attribute values SHOULD NOT contain empty values.
     * The attribute values SHOULD NOT contain bytes values.
     * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
     * double values.
     * The attribute values SHOULD NOT contain kvlist values.
     * The behavior of software that receives attributes containing such values can be unpredictable.
     * These restrictions can change in a minor release.
     * The restrictions take origin from the OpenTelemetry specification:
     * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 1;</code>
     */
    @java.lang.Override
    public java.util.List<? extends opentelemetry.proto.mmap.v1.Mmap.KeyValueRefOrBuilder> 
        getAttributesOrBuilderList() {
      return attributes_;
    }
    /**
     * <pre>
     * Set of attributes that describe the resource.
     * Attribute keys MUST be unique (it is not allowed to have more than one
     * attribute with the same key).
     *
     * The attribute values SHOULD NOT contain empty values.
     * The attribute values SHOULD NOT contain bytes values.
     * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
     * double values.
     * The attribute values SHOULD NOT contain kvlist values.
     * The behavior of software that receives attributes containing such values can be unpredictable.
     * These restrictions can change in a minor release.
     * The restrictions take origin from the OpenTelemetry specification:
     * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 1;</code>
     */
    @java.lang.Override
    public int getAttributesCount() {
      return attributes_.size();
    }
    /**
     * <pre>
     * Set of attributes that describe the resource.
     * Attribute keys MUST be unique (it is not allowed to have more than one
     * attribute with the same key).
     *
     * The attribute values SHOULD NOT contain empty values.
     * The attribute values SHOULD NOT contain bytes values.
     * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
     * double values.
     * The attribute values SHOULD NOT contain kvlist values.
     * The behavior of software that receives attributes containing such values can be unpredictable.
     * These restrictions can change in a minor release.
     * The restrictions take origin from the OpenTelemetry specification:
     * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 1;</code>
     */
    @java.lang.Override
    public opentelemetry.proto.mmap.v1.Mmap.KeyValueRef getAttributes(int index) {
      return attributes_.get(index);
    }
    /**
     * <pre>
     * Set of attributes that describe the resource.
     * Attribute keys MUST be unique (it is not allowed to have more than one
     * attribute with the same key).
     *
     * The attribute values SHOULD NOT contain empty values.
     * The attribute values SHOULD NOT contain bytes values.
     * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
     * double values.
     * The attribute values SHOULD NOT contain kvlist values.
     * The behavior of software that receives attributes containing such values can be unpredictable.
     * These restrictions can change in a minor release.
     * The restrictions take origin from the OpenTelemetry specification:
     * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 1;</code>
     */
    @java.lang.Override
    public opentelemetry.proto.mmap.v1.Mmap.KeyValueRefOrBuilder getAttributesOrBuilder(
        int index) {
      return attributes_.get(index);
    }

    public static final int DROPPED_ATTRIBUTES_COUNT_FIELD_NUMBER = 2;
    private int droppedAttributesCount_ = 0;
    /**
     * <pre>
     * The number of dropped attributes. If the value is 0, then
     * no attributes were dropped.
     * </pre>
     *
     * <code>uint32 dropped_attributes_count = 2;</code>
     * @return The droppedAttributesCount.
     */
    @java.lang.Override
    public int getDroppedAttributesCount() {
      return droppedAttributesCount_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      for (int i = 0; i < attributes_.size(); i++) {
        output.writeMessage(1, attributes_.get(i));
      }
      if (droppedAttributesCount_ != 0) {
        output.writeUInt32(2, droppedAttributesCount_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      for (int i = 0; i < attributes_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, attributes_.get(i));
      }
      if (droppedAttributesCount_ != 0) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(2, droppedAttributesCount_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof opentelemetry.proto.mmap.v1.Mmap.Resource)) {
        return super.equals(obj);
      }
      opentelemetry.proto.mmap.v1.Mmap.Resource other = (opentelemetry.proto.mmap.v1.Mmap.Resource) obj;

      if (!getAttributesList()
          .equals(other.getAttributesList())) return false;
      if (getDroppedAttributesCount()
          != other.getDroppedAttributesCount()) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getAttributesCount() > 0) {
        hash = (37 * hash) + ATTRIBUTES_FIELD_NUMBER;
        hash = (53 * hash) + getAttributesList().hashCode();
      }
      hash = (37 * hash) + DROPPED_ATTRIBUTES_COUNT_FIELD_NUMBER;
      hash = (53 * hash) + getDroppedAttributesCount();
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static opentelemetry.proto.mmap.v1.Mmap.Resource parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.Resource parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.Resource parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.Resource parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.Resource parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.Resource parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.Resource parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.Resource parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static opentelemetry.proto.mmap.v1.Mmap.Resource parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static opentelemetry.proto.mmap.v1.Mmap.Resource parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.Resource parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.Resource parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(opentelemetry.proto.mmap.v1.Mmap.Resource prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Resource information.
     * </pre>
     *
     * Protobuf type {@code opentelemetry.proto.mmap.v1.Resource}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:opentelemetry.proto.mmap.v1.Resource)
        opentelemetry.proto.mmap.v1.Mmap.ResourceOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_Resource_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_Resource_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                opentelemetry.proto.mmap.v1.Mmap.Resource.class, opentelemetry.proto.mmap.v1.Mmap.Resource.Builder.class);
      }

      // Construct using opentelemetry.proto.mmap.v1.Mmap.Resource.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        if (attributesBuilder_ == null) {
          attributes_ = java.util.Collections.emptyList();
        } else {
          attributes_ = null;
          attributesBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        droppedAttributesCount_ = 0;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_Resource_descriptor;
      }

      @java.lang.Override
      public opentelemetry.proto.mmap.v1.Mmap.Resource getDefaultInstanceForType() {
        return opentelemetry.proto.mmap.v1.Mmap.Resource.getDefaultInstance();
      }

      @java.lang.Override
      public opentelemetry.proto.mmap.v1.Mmap.Resource build() {
        opentelemetry.proto.mmap.v1.Mmap.Resource result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public opentelemetry.proto.mmap.v1.Mmap.Resource buildPartial() {
        opentelemetry.proto.mmap.v1.Mmap.Resource result = new opentelemetry.proto.mmap.v1.Mmap.Resource(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(opentelemetry.proto.mmap.v1.Mmap.Resource result) {
        if (attributesBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0)) {
            attributes_ = java.util.Collections.unmodifiableList(attributes_);
            bitField0_ = (bitField0_ & ~0x00000001);
          }
          result.attributes_ = attributes_;
        } else {
          result.attributes_ = attributesBuilder_.build();
        }
      }

      private void buildPartial0(opentelemetry.proto.mmap.v1.Mmap.Resource result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.droppedAttributesCount_ = droppedAttributesCount_;
        }
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof opentelemetry.proto.mmap.v1.Mmap.Resource) {
          return mergeFrom((opentelemetry.proto.mmap.v1.Mmap.Resource)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(opentelemetry.proto.mmap.v1.Mmap.Resource other) {
        if (other == opentelemetry.proto.mmap.v1.Mmap.Resource.getDefaultInstance()) return this;
        if (attributesBuilder_ == null) {
          if (!other.attributes_.isEmpty()) {
            if (attributes_.isEmpty()) {
              attributes_ = other.attributes_;
              bitField0_ = (bitField0_ & ~0x00000001);
            } else {
              ensureAttributesIsMutable();
              attributes_.addAll(other.attributes_);
            }
            onChanged();
          }
        } else {
          if (!other.attributes_.isEmpty()) {
            if (attributesBuilder_.isEmpty()) {
              attributesBuilder_.dispose();
              attributesBuilder_ = null;
              attributes_ = other.attributes_;
              bitField0_ = (bitField0_ & ~0x00000001);
              attributesBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   internalGetAttributesFieldBuilder() : null;
            } else {
              attributesBuilder_.addAllMessages(other.attributes_);
            }
          }
        }
        if (other.getDroppedAttributesCount() != 0) {
          setDroppedAttributesCount(other.getDroppedAttributesCount());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                opentelemetry.proto.mmap.v1.Mmap.KeyValueRef m =
                    input.readMessage(
                        opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.parser(),
                        extensionRegistry);
                if (attributesBuilder_ == null) {
                  ensureAttributesIsMutable();
                  attributes_.add(m);
                } else {
                  attributesBuilder_.addMessage(m);
                }
                break;
              } // case 10
              case 16: {
                droppedAttributesCount_ = input.readUInt32();
                bitField0_ |= 0x00000002;
                break;
              } // case 16
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.util.List<opentelemetry.proto.mmap.v1.Mmap.KeyValueRef> attributes_ =
        java.util.Collections.emptyList();
      private void ensureAttributesIsMutable() {
        if (!((bitField0_ & 0x00000001) != 0)) {
          attributes_ = new java.util.ArrayList<opentelemetry.proto.mmap.v1.Mmap.KeyValueRef>(attributes_);
          bitField0_ |= 0x00000001;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          opentelemetry.proto.mmap.v1.Mmap.KeyValueRef, opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.Builder, opentelemetry.proto.mmap.v1.Mmap.KeyValueRefOrBuilder> attributesBuilder_;

      /**
       * <pre>
       * Set of attributes that describe the resource.
       * Attribute keys MUST be unique (it is not allowed to have more than one
       * attribute with the same key).
       *
       * The attribute values SHOULD NOT contain empty values.
       * The attribute values SHOULD NOT contain bytes values.
       * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
       * double values.
       * The attribute values SHOULD NOT contain kvlist values.
       * The behavior of software that receives attributes containing such values can be unpredictable.
       * These restrictions can change in a minor release.
       * The restrictions take origin from the OpenTelemetry specification:
       * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 1;</code>
       */
      public java.util.List<opentelemetry.proto.mmap.v1.Mmap.KeyValueRef> getAttributesList() {
        if (attributesBuilder_ == null) {
          return java.util.Collections.unmodifiableList(attributes_);
        } else {
          return attributesBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * Set of attributes that describe the resource.
       * Attribute keys MUST be unique (it is not allowed to have more than one
       * attribute with the same key).
       *
       * The attribute values SHOULD NOT contain empty values.
       * The attribute values SHOULD NOT contain bytes values.
       * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
       * double values.
       * The attribute values SHOULD NOT contain kvlist values.
       * The behavior of software that receives attributes containing such values can be unpredictable.
       * These restrictions can change in a minor release.
       * The restrictions take origin from the OpenTelemetry specification:
       * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 1;</code>
       */
      public int getAttributesCount() {
        if (attributesBuilder_ == null) {
          return attributes_.size();
        } else {
          return attributesBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * Set of attributes that describe the resource.
       * Attribute keys MUST be unique (it is not allowed to have more than one
       * attribute with the same key).
       *
       * The attribute values SHOULD NOT contain empty values.
       * The attribute values SHOULD NOT contain bytes values.
       * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
       * double values.
       * The attribute values SHOULD NOT contain kvlist values.
       * The behavior of software that receives attributes containing such values can be unpredictable.
       * These restrictions can change in a minor release.
       * The restrictions take origin from the OpenTelemetry specification:
       * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 1;</code>
       */
      public opentelemetry.proto.mmap.v1.Mmap.KeyValueRef getAttributes(int index) {
        if (attributesBuilder_ == null) {
          return attributes_.get(index);
        } else {
          return attributesBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * Set of attributes that describe the resource.
       * Attribute keys MUST be unique (it is not allowed to have more than one
       * attribute with the same key).
       *
       * The attribute values SHOULD NOT contain empty values.
       * The attribute values SHOULD NOT contain bytes values.
       * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
       * double values.
       * The attribute values SHOULD NOT contain kvlist values.
       * The behavior of software that receives attributes containing such values can be unpredictable.
       * These restrictions can change in a minor release.
       * The restrictions take origin from the OpenTelemetry specification:
       * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 1;</code>
       */
      public Builder setAttributes(
          int index, opentelemetry.proto.mmap.v1.Mmap.KeyValueRef value) {
        if (attributesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureAttributesIsMutable();
          attributes_.set(index, value);
          onChanged();
        } else {
          attributesBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Set of attributes that describe the resource.
       * Attribute keys MUST be unique (it is not allowed to have more than one
       * attribute with the same key).
       *
       * The attribute values SHOULD NOT contain empty values.
       * The attribute values SHOULD NOT contain bytes values.
       * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
       * double values.
       * The attribute values SHOULD NOT contain kvlist values.
       * The behavior of software that receives attributes containing such values can be unpredictable.
       * These restrictions can change in a minor release.
       * The restrictions take origin from the OpenTelemetry specification:
       * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 1;</code>
       */
      public Builder setAttributes(
          int index, opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.Builder builderForValue) {
        if (attributesBuilder_ == null) {
          ensureAttributesIsMutable();
          attributes_.set(index, builderForValue.build());
          onChanged();
        } else {
          attributesBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Set of attributes that describe the resource.
       * Attribute keys MUST be unique (it is not allowed to have more than one
       * attribute with the same key).
       *
       * The attribute values SHOULD NOT contain empty values.
       * The attribute values SHOULD NOT contain bytes values.
       * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
       * double values.
       * The attribute values SHOULD NOT contain kvlist values.
       * The behavior of software that receives attributes containing such values can be unpredictable.
       * These restrictions can change in a minor release.
       * The restrictions take origin from the OpenTelemetry specification:
       * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 1;</code>
       */
      public Builder addAttributes(opentelemetry.proto.mmap.v1.Mmap.KeyValueRef value) {
        if (attributesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureAttributesIsMutable();
          attributes_.add(value);
          onChanged();
        } else {
          attributesBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * Set of attributes that describe the resource.
       * Attribute keys MUST be unique (it is not allowed to have more than one
       * attribute with the same key).
       *
       * The attribute values SHOULD NOT contain empty values.
       * The attribute values SHOULD NOT contain bytes values.
       * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
       * double values.
       * The attribute values SHOULD NOT contain kvlist values.
       * The behavior of software that receives attributes containing such values can be unpredictable.
       * These restrictions can change in a minor release.
       * The restrictions take origin from the OpenTelemetry specification:
       * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 1;</code>
       */
      public Builder addAttributes(
          int index, opentelemetry.proto.mmap.v1.Mmap.KeyValueRef value) {
        if (attributesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureAttributesIsMutable();
          attributes_.add(index, value);
          onChanged();
        } else {
          attributesBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Set of attributes that describe the resource.
       * Attribute keys MUST be unique (it is not allowed to have more than one
       * attribute with the same key).
       *
       * The attribute values SHOULD NOT contain empty values.
       * The attribute values SHOULD NOT contain bytes values.
       * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
       * double values.
       * The attribute values SHOULD NOT contain kvlist values.
       * The behavior of software that receives attributes containing such values can be unpredictable.
       * These restrictions can change in a minor release.
       * The restrictions take origin from the OpenTelemetry specification:
       * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 1;</code>
       */
      public Builder addAttributes(
          opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.Builder builderForValue) {
        if (attributesBuilder_ == null) {
          ensureAttributesIsMutable();
          attributes_.add(builderForValue.build());
          onChanged();
        } else {
          attributesBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Set of attributes that describe the resource.
       * Attribute keys MUST be unique (it is not allowed to have more than one
       * attribute with the same key).
       *
       * The attribute values SHOULD NOT contain empty values.
       * The attribute values SHOULD NOT contain bytes values.
       * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
       * double values.
       * The attribute values SHOULD NOT contain kvlist values.
       * The behavior of software that receives attributes containing such values can be unpredictable.
       * These restrictions can change in a minor release.
       * The restrictions take origin from the OpenTelemetry specification:
       * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 1;</code>
       */
      public Builder addAttributes(
          int index, opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.Builder builderForValue) {
        if (attributesBuilder_ == null) {
          ensureAttributesIsMutable();
          attributes_.add(index, builderForValue.build());
          onChanged();
        } else {
          attributesBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Set of attributes that describe the resource.
       * Attribute keys MUST be unique (it is not allowed to have more than one
       * attribute with the same key).
       *
       * The attribute values SHOULD NOT contain empty values.
       * The attribute values SHOULD NOT contain bytes values.
       * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
       * double values.
       * The attribute values SHOULD NOT contain kvlist values.
       * The behavior of software that receives attributes containing such values can be unpredictable.
       * These restrictions can change in a minor release.
       * The restrictions take origin from the OpenTelemetry specification:
       * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 1;</code>
       */
      public Builder addAllAttributes(
          java.lang.Iterable<? extends opentelemetry.proto.mmap.v1.Mmap.KeyValueRef> values) {
        if (attributesBuilder_ == null) {
          ensureAttributesIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, attributes_);
          onChanged();
        } else {
          attributesBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * Set of attributes that describe the resource.
       * Attribute keys MUST be unique (it is not allowed to have more than one
       * attribute with the same key).
       *
       * The attribute values SHOULD NOT contain empty values.
       * The attribute values SHOULD NOT contain bytes values.
       * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
       * double values.
       * The attribute values SHOULD NOT contain kvlist values.
       * The behavior of software that receives attributes containing such values can be unpredictable.
       * These restrictions can change in a minor release.
       * The restrictions take origin from the OpenTelemetry specification:
       * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 1;</code>
       */
      public Builder clearAttributes() {
        if (attributesBuilder_ == null) {
          attributes_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
          onChanged();
        } else {
          attributesBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Set of attributes that describe the resource.
       * Attribute keys MUST be unique (it is not allowed to have more than one
       * attribute with the same key).
       *
       * The attribute values SHOULD NOT contain empty values.
       * The attribute values SHOULD NOT contain bytes values.
       * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
       * double values.
       * The attribute values SHOULD NOT contain kvlist values.
       * The behavior of software that receives attributes containing such values can be unpredictable.
       * These restrictions can change in a minor release.
       * The restrictions take origin from the OpenTelemetry specification:
       * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 1;</code>
       */
      public Builder removeAttributes(int index) {
        if (attributesBuilder_ == null) {
          ensureAttributesIsMutable();
          attributes_.remove(index);
          onChanged();
        } else {
          attributesBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * Set of attributes that describe the resource.
       * Attribute keys MUST be unique (it is not allowed to have more than one
       * attribute with the same key).
       *
       * The attribute values SHOULD NOT contain empty values.
       * The attribute values SHOULD NOT contain bytes values.
       * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
       * double values.
       * The attribute values SHOULD NOT contain kvlist values.
       * The behavior of software that receives attributes containing such values can be unpredictable.
       * These restrictions can change in a minor release.
       * The restrictions take origin from the OpenTelemetry specification:
       * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 1;</code>
       */
      public opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.Builder getAttributesBuilder(
          int index) {
        return internalGetAttributesFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * Set of attributes that describe the resource.
       * Attribute keys MUST be unique (it is not allowed to have more than one
       * attribute with the same key).
       *
       * The attribute values SHOULD NOT contain empty values.
       * The attribute values SHOULD NOT contain bytes values.
       * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
       * double values.
       * The attribute values SHOULD NOT contain kvlist values.
       * The behavior of software that receives attributes containing such values can be unpredictable.
       * These restrictions can change in a minor release.
       * The restrictions take origin from the OpenTelemetry specification:
       * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 1;</code>
       */
      public opentelemetry.proto.mmap.v1.Mmap.KeyValueRefOrBuilder getAttributesOrBuilder(
          int index) {
        if (attributesBuilder_ == null) {
          return attributes_.get(index);  } else {
          return attributesBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * Set of attributes that describe the resource.
       * Attribute keys MUST be unique (it is not allowed to have more than one
       * attribute with the same key).
       *
       * The attribute values SHOULD NOT contain empty values.
       * The attribute values SHOULD NOT contain bytes values.
       * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
       * double values.
       * The attribute values SHOULD NOT contain kvlist values.
       * The behavior of software that receives attributes containing such values can be unpredictable.
       * These restrictions can change in a minor release.
       * The restrictions take origin from the OpenTelemetry specification:
       * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 1;</code>
       */
      public java.util.List<? extends opentelemetry.proto.mmap.v1.Mmap.KeyValueRefOrBuilder> 
           getAttributesOrBuilderList() {
        if (attributesBuilder_ != null) {
          return attributesBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(attributes_);
        }
      }
      /**
       * <pre>
       * Set of attributes that describe the resource.
       * Attribute keys MUST be unique (it is not allowed to have more than one
       * attribute with the same key).
       *
       * The attribute values SHOULD NOT contain empty values.
       * The attribute values SHOULD NOT contain bytes values.
       * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
       * double values.
       * The attribute values SHOULD NOT contain kvlist values.
       * The behavior of software that receives attributes containing such values can be unpredictable.
       * These restrictions can change in a minor release.
       * The restrictions take origin from the OpenTelemetry specification:
       * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 1;</code>
       */
      public opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.Builder addAttributesBuilder() {
        return internalGetAttributesFieldBuilder().addBuilder(
            opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.getDefaultInstance());
      }
      /**
       * <pre>
       * Set of attributes that describe the resource.
       * Attribute keys MUST be unique (it is not allowed to have more than one
       * attribute with the same key).
       *
       * The attribute values SHOULD NOT contain empty values.
       * The attribute values SHOULD NOT contain bytes values.
       * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
       * double values.
       * The attribute values SHOULD NOT contain kvlist values.
       * The behavior of software that receives attributes containing such values can be unpredictable.
       * These restrictions can change in a minor release.
       * The restrictions take origin from the OpenTelemetry specification:
       * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 1;</code>
       */
      public opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.Builder addAttributesBuilder(
          int index) {
        return internalGetAttributesFieldBuilder().addBuilder(
            index, opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.getDefaultInstance());
      }
      /**
       * <pre>
       * Set of attributes that describe the resource.
       * Attribute keys MUST be unique (it is not allowed to have more than one
       * attribute with the same key).
       *
       * The attribute values SHOULD NOT contain empty values.
       * The attribute values SHOULD NOT contain bytes values.
       * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
       * double values.
       * The attribute values SHOULD NOT contain kvlist values.
       * The behavior of software that receives attributes containing such values can be unpredictable.
       * These restrictions can change in a minor release.
       * The restrictions take origin from the OpenTelemetry specification:
       * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 1;</code>
       */
      public java.util.List<opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.Builder> 
           getAttributesBuilderList() {
        return internalGetAttributesFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          opentelemetry.proto.mmap.v1.Mmap.KeyValueRef, opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.Builder, opentelemetry.proto.mmap.v1.Mmap.KeyValueRefOrBuilder> 
          internalGetAttributesFieldBuilder() {
        if (attributesBuilder_ == null) {
          attributesBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              opentelemetry.proto.mmap.v1.Mmap.KeyValueRef, opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.Builder, opentelemetry.proto.mmap.v1.Mmap.KeyValueRefOrBuilder>(
                  attributes_,
                  ((bitField0_ & 0x00000001) != 0),
                  getParentForChildren(),
                  isClean());
          attributes_ = null;
        }
        return attributesBuilder_;
      }

      private int droppedAttributesCount_ ;
      /**
       * <pre>
       * The number of dropped attributes. If the value is 0, then
       * no attributes were dropped.
       * </pre>
       *
       * <code>uint32 dropped_attributes_count = 2;</code>
       * @return The droppedAttributesCount.
       */
      @java.lang.Override
      public int getDroppedAttributesCount() {
        return droppedAttributesCount_;
      }
      /**
       * <pre>
       * The number of dropped attributes. If the value is 0, then
       * no attributes were dropped.
       * </pre>
       *
       * <code>uint32 dropped_attributes_count = 2;</code>
       * @param value The droppedAttributesCount to set.
       * @return This builder for chaining.
       */
      public Builder setDroppedAttributesCount(int value) {

        droppedAttributesCount_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The number of dropped attributes. If the value is 0, then
       * no attributes were dropped.
       * </pre>
       *
       * <code>uint32 dropped_attributes_count = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearDroppedAttributesCount() {
        bitField0_ = (bitField0_ & ~0x00000002);
        droppedAttributesCount_ = 0;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:opentelemetry.proto.mmap.v1.Resource)
    }

    // @@protoc_insertion_point(class_scope:opentelemetry.proto.mmap.v1.Resource)
    private static final opentelemetry.proto.mmap.v1.Mmap.Resource DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new opentelemetry.proto.mmap.v1.Mmap.Resource();
    }

    public static opentelemetry.proto.mmap.v1.Mmap.Resource getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<Resource>
        PARSER = new com.google.protobuf.AbstractParser<Resource>() {
      @java.lang.Override
      public Resource parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<Resource> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<Resource> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public opentelemetry.proto.mmap.v1.Mmap.Resource getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface InstrumentationScopeOrBuilder extends
      // @@protoc_insertion_point(interface_extends:opentelemetry.proto.mmap.v1.InstrumentationScope)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * A name denoting the Instrumentation scope.
     * An empty instrumentation scope name means the name is unknown.
     * </pre>
     *
     * <code>int64 name_ref = 1;</code>
     * @return The nameRef.
     */
    long getNameRef();

    /**
     * <pre>
     * Defines the version of the instrumentation scope.
     * An empty instrumentation scope version means the version is unknown.
     * </pre>
     *
     * <code>int64 version_ref = 2;</code>
     * @return The versionRef.
     */
    long getVersionRef();

    /**
     * <pre>
     * Additional attributes that describe the scope. [Optional].
     * Attribute keys MUST be unique (it is not allowed to have more than one
     * attribute with the same key).
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 3;</code>
     */
    java.util.List<opentelemetry.proto.mmap.v1.Mmap.KeyValueRef> 
        getAttributesList();
    /**
     * <pre>
     * Additional attributes that describe the scope. [Optional].
     * Attribute keys MUST be unique (it is not allowed to have more than one
     * attribute with the same key).
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 3;</code>
     */
    opentelemetry.proto.mmap.v1.Mmap.KeyValueRef getAttributes(int index);
    /**
     * <pre>
     * Additional attributes that describe the scope. [Optional].
     * Attribute keys MUST be unique (it is not allowed to have more than one
     * attribute with the same key).
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 3;</code>
     */
    int getAttributesCount();
    /**
     * <pre>
     * Additional attributes that describe the scope. [Optional].
     * Attribute keys MUST be unique (it is not allowed to have more than one
     * attribute with the same key).
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 3;</code>
     */
    java.util.List<? extends opentelemetry.proto.mmap.v1.Mmap.KeyValueRefOrBuilder> 
        getAttributesOrBuilderList();
    /**
     * <pre>
     * Additional attributes that describe the scope. [Optional].
     * Attribute keys MUST be unique (it is not allowed to have more than one
     * attribute with the same key).
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 3;</code>
     */
    opentelemetry.proto.mmap.v1.Mmap.KeyValueRefOrBuilder getAttributesOrBuilder(
        int index);

    /**
     * <pre>
     * The number of attributes that were discarded. Attributes
     * can be discarded because their keys are too long or because there are too many
     * attributes. If this value is 0, then no attributes were dropped.
     * </pre>
     *
     * <code>uint32 dropped_attributes_count = 4;</code>
     * @return The droppedAttributesCount.
     */
    int getDroppedAttributesCount();

    /**
     * <pre>
     * Resource in which this instrumentation scope was created.
     * </pre>
     *
     * <code>int64 resource_ref = 5;</code>
     * @return The resourceRef.
     */
    long getResourceRef();
  }
  /**
   * <pre>
   * InstrumentationScope is a message representing the instrumentation scope information
   * such as the fully qualified name and version. 
   * </pre>
   *
   * Protobuf type {@code opentelemetry.proto.mmap.v1.InstrumentationScope}
   */
  public static final class InstrumentationScope extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:opentelemetry.proto.mmap.v1.InstrumentationScope)
      InstrumentationScopeOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 33,
        /* patch= */ 0,
        /* suffix= */ "",
        "InstrumentationScope");
    }
    // Use InstrumentationScope.newBuilder() to construct.
    private InstrumentationScope(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private InstrumentationScope() {
      attributes_ = java.util.Collections.emptyList();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_InstrumentationScope_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_InstrumentationScope_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              opentelemetry.proto.mmap.v1.Mmap.InstrumentationScope.class, opentelemetry.proto.mmap.v1.Mmap.InstrumentationScope.Builder.class);
    }

    public static final int NAME_REF_FIELD_NUMBER = 1;
    private long nameRef_ = 0L;
    /**
     * <pre>
     * A name denoting the Instrumentation scope.
     * An empty instrumentation scope name means the name is unknown.
     * </pre>
     *
     * <code>int64 name_ref = 1;</code>
     * @return The nameRef.
     */
    @java.lang.Override
    public long getNameRef() {
      return nameRef_;
    }

    public static final int VERSION_REF_FIELD_NUMBER = 2;
    private long versionRef_ = 0L;
    /**
     * <pre>
     * Defines the version of the instrumentation scope.
     * An empty instrumentation scope version means the version is unknown.
     * </pre>
     *
     * <code>int64 version_ref = 2;</code>
     * @return The versionRef.
     */
    @java.lang.Override
    public long getVersionRef() {
      return versionRef_;
    }

    public static final int ATTRIBUTES_FIELD_NUMBER = 3;
    @SuppressWarnings("serial")
    private java.util.List<opentelemetry.proto.mmap.v1.Mmap.KeyValueRef> attributes_;
    /**
     * <pre>
     * Additional attributes that describe the scope. [Optional].
     * Attribute keys MUST be unique (it is not allowed to have more than one
     * attribute with the same key).
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 3;</code>
     */
    @java.lang.Override
    public java.util.List<opentelemetry.proto.mmap.v1.Mmap.KeyValueRef> getAttributesList() {
      return attributes_;
    }
    /**
     * <pre>
     * Additional attributes that describe the scope. [Optional].
     * Attribute keys MUST be unique (it is not allowed to have more than one
     * attribute with the same key).
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 3;</code>
     */
    @java.lang.Override
    public java.util.List<? extends opentelemetry.proto.mmap.v1.Mmap.KeyValueRefOrBuilder> 
        getAttributesOrBuilderList() {
      return attributes_;
    }
    /**
     * <pre>
     * Additional attributes that describe the scope. [Optional].
     * Attribute keys MUST be unique (it is not allowed to have more than one
     * attribute with the same key).
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 3;</code>
     */
    @java.lang.Override
    public int getAttributesCount() {
      return attributes_.size();
    }
    /**
     * <pre>
     * Additional attributes that describe the scope. [Optional].
     * Attribute keys MUST be unique (it is not allowed to have more than one
     * attribute with the same key).
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 3;</code>
     */
    @java.lang.Override
    public opentelemetry.proto.mmap.v1.Mmap.KeyValueRef getAttributes(int index) {
      return attributes_.get(index);
    }
    /**
     * <pre>
     * Additional attributes that describe the scope. [Optional].
     * Attribute keys MUST be unique (it is not allowed to have more than one
     * attribute with the same key).
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 3;</code>
     */
    @java.lang.Override
    public opentelemetry.proto.mmap.v1.Mmap.KeyValueRefOrBuilder getAttributesOrBuilder(
        int index) {
      return attributes_.get(index);
    }

    public static final int DROPPED_ATTRIBUTES_COUNT_FIELD_NUMBER = 4;
    private int droppedAttributesCount_ = 0;
    /**
     * <pre>
     * The number of attributes that were discarded. Attributes
     * can be discarded because their keys are too long or because there are too many
     * attributes. If this value is 0, then no attributes were dropped.
     * </pre>
     *
     * <code>uint32 dropped_attributes_count = 4;</code>
     * @return The droppedAttributesCount.
     */
    @java.lang.Override
    public int getDroppedAttributesCount() {
      return droppedAttributesCount_;
    }

    public static final int RESOURCE_REF_FIELD_NUMBER = 5;
    private long resourceRef_ = 0L;
    /**
     * <pre>
     * Resource in which this instrumentation scope was created.
     * </pre>
     *
     * <code>int64 resource_ref = 5;</code>
     * @return The resourceRef.
     */
    @java.lang.Override
    public long getResourceRef() {
      return resourceRef_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (nameRef_ != 0L) {
        output.writeInt64(1, nameRef_);
      }
      if (versionRef_ != 0L) {
        output.writeInt64(2, versionRef_);
      }
      for (int i = 0; i < attributes_.size(); i++) {
        output.writeMessage(3, attributes_.get(i));
      }
      if (droppedAttributesCount_ != 0) {
        output.writeUInt32(4, droppedAttributesCount_);
      }
      if (resourceRef_ != 0L) {
        output.writeInt64(5, resourceRef_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (nameRef_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(1, nameRef_);
      }
      if (versionRef_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(2, versionRef_);
      }
      for (int i = 0; i < attributes_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, attributes_.get(i));
      }
      if (droppedAttributesCount_ != 0) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(4, droppedAttributesCount_);
      }
      if (resourceRef_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(5, resourceRef_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof opentelemetry.proto.mmap.v1.Mmap.InstrumentationScope)) {
        return super.equals(obj);
      }
      opentelemetry.proto.mmap.v1.Mmap.InstrumentationScope other = (opentelemetry.proto.mmap.v1.Mmap.InstrumentationScope) obj;

      if (getNameRef()
          != other.getNameRef()) return false;
      if (getVersionRef()
          != other.getVersionRef()) return false;
      if (!getAttributesList()
          .equals(other.getAttributesList())) return false;
      if (getDroppedAttributesCount()
          != other.getDroppedAttributesCount()) return false;
      if (getResourceRef()
          != other.getResourceRef()) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + NAME_REF_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getNameRef());
      hash = (37 * hash) + VERSION_REF_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getVersionRef());
      if (getAttributesCount() > 0) {
        hash = (37 * hash) + ATTRIBUTES_FIELD_NUMBER;
        hash = (53 * hash) + getAttributesList().hashCode();
      }
      hash = (37 * hash) + DROPPED_ATTRIBUTES_COUNT_FIELD_NUMBER;
      hash = (53 * hash) + getDroppedAttributesCount();
      hash = (37 * hash) + RESOURCE_REF_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getResourceRef());
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static opentelemetry.proto.mmap.v1.Mmap.InstrumentationScope parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.InstrumentationScope parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.InstrumentationScope parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.InstrumentationScope parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.InstrumentationScope parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.InstrumentationScope parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.InstrumentationScope parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.InstrumentationScope parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static opentelemetry.proto.mmap.v1.Mmap.InstrumentationScope parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static opentelemetry.proto.mmap.v1.Mmap.InstrumentationScope parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.InstrumentationScope parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.InstrumentationScope parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(opentelemetry.proto.mmap.v1.Mmap.InstrumentationScope prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * InstrumentationScope is a message representing the instrumentation scope information
     * such as the fully qualified name and version. 
     * </pre>
     *
     * Protobuf type {@code opentelemetry.proto.mmap.v1.InstrumentationScope}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:opentelemetry.proto.mmap.v1.InstrumentationScope)
        opentelemetry.proto.mmap.v1.Mmap.InstrumentationScopeOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_InstrumentationScope_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_InstrumentationScope_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                opentelemetry.proto.mmap.v1.Mmap.InstrumentationScope.class, opentelemetry.proto.mmap.v1.Mmap.InstrumentationScope.Builder.class);
      }

      // Construct using opentelemetry.proto.mmap.v1.Mmap.InstrumentationScope.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        nameRef_ = 0L;
        versionRef_ = 0L;
        if (attributesBuilder_ == null) {
          attributes_ = java.util.Collections.emptyList();
        } else {
          attributes_ = null;
          attributesBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000004);
        droppedAttributesCount_ = 0;
        resourceRef_ = 0L;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_InstrumentationScope_descriptor;
      }

      @java.lang.Override
      public opentelemetry.proto.mmap.v1.Mmap.InstrumentationScope getDefaultInstanceForType() {
        return opentelemetry.proto.mmap.v1.Mmap.InstrumentationScope.getDefaultInstance();
      }

      @java.lang.Override
      public opentelemetry.proto.mmap.v1.Mmap.InstrumentationScope build() {
        opentelemetry.proto.mmap.v1.Mmap.InstrumentationScope result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public opentelemetry.proto.mmap.v1.Mmap.InstrumentationScope buildPartial() {
        opentelemetry.proto.mmap.v1.Mmap.InstrumentationScope result = new opentelemetry.proto.mmap.v1.Mmap.InstrumentationScope(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(opentelemetry.proto.mmap.v1.Mmap.InstrumentationScope result) {
        if (attributesBuilder_ == null) {
          if (((bitField0_ & 0x00000004) != 0)) {
            attributes_ = java.util.Collections.unmodifiableList(attributes_);
            bitField0_ = (bitField0_ & ~0x00000004);
          }
          result.attributes_ = attributes_;
        } else {
          result.attributes_ = attributesBuilder_.build();
        }
      }

      private void buildPartial0(opentelemetry.proto.mmap.v1.Mmap.InstrumentationScope result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.nameRef_ = nameRef_;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.versionRef_ = versionRef_;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.droppedAttributesCount_ = droppedAttributesCount_;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.resourceRef_ = resourceRef_;
        }
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof opentelemetry.proto.mmap.v1.Mmap.InstrumentationScope) {
          return mergeFrom((opentelemetry.proto.mmap.v1.Mmap.InstrumentationScope)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(opentelemetry.proto.mmap.v1.Mmap.InstrumentationScope other) {
        if (other == opentelemetry.proto.mmap.v1.Mmap.InstrumentationScope.getDefaultInstance()) return this;
        if (other.getNameRef() != 0L) {
          setNameRef(other.getNameRef());
        }
        if (other.getVersionRef() != 0L) {
          setVersionRef(other.getVersionRef());
        }
        if (attributesBuilder_ == null) {
          if (!other.attributes_.isEmpty()) {
            if (attributes_.isEmpty()) {
              attributes_ = other.attributes_;
              bitField0_ = (bitField0_ & ~0x00000004);
            } else {
              ensureAttributesIsMutable();
              attributes_.addAll(other.attributes_);
            }
            onChanged();
          }
        } else {
          if (!other.attributes_.isEmpty()) {
            if (attributesBuilder_.isEmpty()) {
              attributesBuilder_.dispose();
              attributesBuilder_ = null;
              attributes_ = other.attributes_;
              bitField0_ = (bitField0_ & ~0x00000004);
              attributesBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   internalGetAttributesFieldBuilder() : null;
            } else {
              attributesBuilder_.addAllMessages(other.attributes_);
            }
          }
        }
        if (other.getDroppedAttributesCount() != 0) {
          setDroppedAttributesCount(other.getDroppedAttributesCount());
        }
        if (other.getResourceRef() != 0L) {
          setResourceRef(other.getResourceRef());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8: {
                nameRef_ = input.readInt64();
                bitField0_ |= 0x00000001;
                break;
              } // case 8
              case 16: {
                versionRef_ = input.readInt64();
                bitField0_ |= 0x00000002;
                break;
              } // case 16
              case 26: {
                opentelemetry.proto.mmap.v1.Mmap.KeyValueRef m =
                    input.readMessage(
                        opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.parser(),
                        extensionRegistry);
                if (attributesBuilder_ == null) {
                  ensureAttributesIsMutable();
                  attributes_.add(m);
                } else {
                  attributesBuilder_.addMessage(m);
                }
                break;
              } // case 26
              case 32: {
                droppedAttributesCount_ = input.readUInt32();
                bitField0_ |= 0x00000008;
                break;
              } // case 32
              case 40: {
                resourceRef_ = input.readInt64();
                bitField0_ |= 0x00000010;
                break;
              } // case 40
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private long nameRef_ ;
      /**
       * <pre>
       * A name denoting the Instrumentation scope.
       * An empty instrumentation scope name means the name is unknown.
       * </pre>
       *
       * <code>int64 name_ref = 1;</code>
       * @return The nameRef.
       */
      @java.lang.Override
      public long getNameRef() {
        return nameRef_;
      }
      /**
       * <pre>
       * A name denoting the Instrumentation scope.
       * An empty instrumentation scope name means the name is unknown.
       * </pre>
       *
       * <code>int64 name_ref = 1;</code>
       * @param value The nameRef to set.
       * @return This builder for chaining.
       */
      public Builder setNameRef(long value) {

        nameRef_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A name denoting the Instrumentation scope.
       * An empty instrumentation scope name means the name is unknown.
       * </pre>
       *
       * <code>int64 name_ref = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearNameRef() {
        bitField0_ = (bitField0_ & ~0x00000001);
        nameRef_ = 0L;
        onChanged();
        return this;
      }

      private long versionRef_ ;
      /**
       * <pre>
       * Defines the version of the instrumentation scope.
       * An empty instrumentation scope version means the version is unknown.
       * </pre>
       *
       * <code>int64 version_ref = 2;</code>
       * @return The versionRef.
       */
      @java.lang.Override
      public long getVersionRef() {
        return versionRef_;
      }
      /**
       * <pre>
       * Defines the version of the instrumentation scope.
       * An empty instrumentation scope version means the version is unknown.
       * </pre>
       *
       * <code>int64 version_ref = 2;</code>
       * @param value The versionRef to set.
       * @return This builder for chaining.
       */
      public Builder setVersionRef(long value) {

        versionRef_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Defines the version of the instrumentation scope.
       * An empty instrumentation scope version means the version is unknown.
       * </pre>
       *
       * <code>int64 version_ref = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearVersionRef() {
        bitField0_ = (bitField0_ & ~0x00000002);
        versionRef_ = 0L;
        onChanged();
        return this;
      }

      private java.util.List<opentelemetry.proto.mmap.v1.Mmap.KeyValueRef> attributes_ =
        java.util.Collections.emptyList();
      private void ensureAttributesIsMutable() {
        if (!((bitField0_ & 0x00000004) != 0)) {
          attributes_ = new java.util.ArrayList<opentelemetry.proto.mmap.v1.Mmap.KeyValueRef>(attributes_);
          bitField0_ |= 0x00000004;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          opentelemetry.proto.mmap.v1.Mmap.KeyValueRef, opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.Builder, opentelemetry.proto.mmap.v1.Mmap.KeyValueRefOrBuilder> attributesBuilder_;

      /**
       * <pre>
       * Additional attributes that describe the scope. [Optional].
       * Attribute keys MUST be unique (it is not allowed to have more than one
       * attribute with the same key).
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 3;</code>
       */
      public java.util.List<opentelemetry.proto.mmap.v1.Mmap.KeyValueRef> getAttributesList() {
        if (attributesBuilder_ == null) {
          return java.util.Collections.unmodifiableList(attributes_);
        } else {
          return attributesBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * Additional attributes that describe the scope. [Optional].
       * Attribute keys MUST be unique (it is not allowed to have more than one
       * attribute with the same key).
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 3;</code>
       */
      public int getAttributesCount() {
        if (attributesBuilder_ == null) {
          return attributes_.size();
        } else {
          return attributesBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * Additional attributes that describe the scope. [Optional].
       * Attribute keys MUST be unique (it is not allowed to have more than one
       * attribute with the same key).
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 3;</code>
       */
      public opentelemetry.proto.mmap.v1.Mmap.KeyValueRef getAttributes(int index) {
        if (attributesBuilder_ == null) {
          return attributes_.get(index);
        } else {
          return attributesBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * Additional attributes that describe the scope. [Optional].
       * Attribute keys MUST be unique (it is not allowed to have more than one
       * attribute with the same key).
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 3;</code>
       */
      public Builder setAttributes(
          int index, opentelemetry.proto.mmap.v1.Mmap.KeyValueRef value) {
        if (attributesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureAttributesIsMutable();
          attributes_.set(index, value);
          onChanged();
        } else {
          attributesBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Additional attributes that describe the scope. [Optional].
       * Attribute keys MUST be unique (it is not allowed to have more than one
       * attribute with the same key).
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 3;</code>
       */
      public Builder setAttributes(
          int index, opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.Builder builderForValue) {
        if (attributesBuilder_ == null) {
          ensureAttributesIsMutable();
          attributes_.set(index, builderForValue.build());
          onChanged();
        } else {
          attributesBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Additional attributes that describe the scope. [Optional].
       * Attribute keys MUST be unique (it is not allowed to have more than one
       * attribute with the same key).
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 3;</code>
       */
      public Builder addAttributes(opentelemetry.proto.mmap.v1.Mmap.KeyValueRef value) {
        if (attributesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureAttributesIsMutable();
          attributes_.add(value);
          onChanged();
        } else {
          attributesBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * Additional attributes that describe the scope. [Optional].
       * Attribute keys MUST be unique (it is not allowed to have more than one
       * attribute with the same key).
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 3;</code>
       */
      public Builder addAttributes(
          int index, opentelemetry.proto.mmap.v1.Mmap.KeyValueRef value) {
        if (attributesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureAttributesIsMutable();
          attributes_.add(index, value);
          onChanged();
        } else {
          attributesBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Additional attributes that describe the scope. [Optional].
       * Attribute keys MUST be unique (it is not allowed to have more than one
       * attribute with the same key).
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 3;</code>
       */
      public Builder addAttributes(
          opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.Builder builderForValue) {
        if (attributesBuilder_ == null) {
          ensureAttributesIsMutable();
          attributes_.add(builderForValue.build());
          onChanged();
        } else {
          attributesBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Additional attributes that describe the scope. [Optional].
       * Attribute keys MUST be unique (it is not allowed to have more than one
       * attribute with the same key).
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 3;</code>
       */
      public Builder addAttributes(
          int index, opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.Builder builderForValue) {
        if (attributesBuilder_ == null) {
          ensureAttributesIsMutable();
          attributes_.add(index, builderForValue.build());
          onChanged();
        } else {
          attributesBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Additional attributes that describe the scope. [Optional].
       * Attribute keys MUST be unique (it is not allowed to have more than one
       * attribute with the same key).
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 3;</code>
       */
      public Builder addAllAttributes(
          java.lang.Iterable<? extends opentelemetry.proto.mmap.v1.Mmap.KeyValueRef> values) {
        if (attributesBuilder_ == null) {
          ensureAttributesIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, attributes_);
          onChanged();
        } else {
          attributesBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * Additional attributes that describe the scope. [Optional].
       * Attribute keys MUST be unique (it is not allowed to have more than one
       * attribute with the same key).
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 3;</code>
       */
      public Builder clearAttributes() {
        if (attributesBuilder_ == null) {
          attributes_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000004);
          onChanged();
        } else {
          attributesBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Additional attributes that describe the scope. [Optional].
       * Attribute keys MUST be unique (it is not allowed to have more than one
       * attribute with the same key).
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 3;</code>
       */
      public Builder removeAttributes(int index) {
        if (attributesBuilder_ == null) {
          ensureAttributesIsMutable();
          attributes_.remove(index);
          onChanged();
        } else {
          attributesBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * Additional attributes that describe the scope. [Optional].
       * Attribute keys MUST be unique (it is not allowed to have more than one
       * attribute with the same key).
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 3;</code>
       */
      public opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.Builder getAttributesBuilder(
          int index) {
        return internalGetAttributesFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * Additional attributes that describe the scope. [Optional].
       * Attribute keys MUST be unique (it is not allowed to have more than one
       * attribute with the same key).
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 3;</code>
       */
      public opentelemetry.proto.mmap.v1.Mmap.KeyValueRefOrBuilder getAttributesOrBuilder(
          int index) {
        if (attributesBuilder_ == null) {
          return attributes_.get(index);  } else {
          return attributesBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * Additional attributes that describe the scope. [Optional].
       * Attribute keys MUST be unique (it is not allowed to have more than one
       * attribute with the same key).
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 3;</code>
       */
      public java.util.List<? extends opentelemetry.proto.mmap.v1.Mmap.KeyValueRefOrBuilder> 
           getAttributesOrBuilderList() {
        if (attributesBuilder_ != null) {
          return attributesBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(attributes_);
        }
      }
      /**
       * <pre>
       * Additional attributes that describe the scope. [Optional].
       * Attribute keys MUST be unique (it is not allowed to have more than one
       * attribute with the same key).
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 3;</code>
       */
      public opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.Builder addAttributesBuilder() {
        return internalGetAttributesFieldBuilder().addBuilder(
            opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.getDefaultInstance());
      }
      /**
       * <pre>
       * Additional attributes that describe the scope. [Optional].
       * Attribute keys MUST be unique (it is not allowed to have more than one
       * attribute with the same key).
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 3;</code>
       */
      public opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.Builder addAttributesBuilder(
          int index) {
        return internalGetAttributesFieldBuilder().addBuilder(
            index, opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.getDefaultInstance());
      }
      /**
       * <pre>
       * Additional attributes that describe the scope. [Optional].
       * Attribute keys MUST be unique (it is not allowed to have more than one
       * attribute with the same key).
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef attributes = 3;</code>
       */
      public java.util.List<opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.Builder> 
           getAttributesBuilderList() {
        return internalGetAttributesFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          opentelemetry.proto.mmap.v1.Mmap.KeyValueRef, opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.Builder, opentelemetry.proto.mmap.v1.Mmap.KeyValueRefOrBuilder> 
          internalGetAttributesFieldBuilder() {
        if (attributesBuilder_ == null) {
          attributesBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              opentelemetry.proto.mmap.v1.Mmap.KeyValueRef, opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.Builder, opentelemetry.proto.mmap.v1.Mmap.KeyValueRefOrBuilder>(
                  attributes_,
                  ((bitField0_ & 0x00000004) != 0),
                  getParentForChildren(),
                  isClean());
          attributes_ = null;
        }
        return attributesBuilder_;
      }

      private int droppedAttributesCount_ ;
      /**
       * <pre>
       * The number of attributes that were discarded. Attributes
       * can be discarded because their keys are too long or because there are too many
       * attributes. If this value is 0, then no attributes were dropped.
       * </pre>
       *
       * <code>uint32 dropped_attributes_count = 4;</code>
       * @return The droppedAttributesCount.
       */
      @java.lang.Override
      public int getDroppedAttributesCount() {
        return droppedAttributesCount_;
      }
      /**
       * <pre>
       * The number of attributes that were discarded. Attributes
       * can be discarded because their keys are too long or because there are too many
       * attributes. If this value is 0, then no attributes were dropped.
       * </pre>
       *
       * <code>uint32 dropped_attributes_count = 4;</code>
       * @param value The droppedAttributesCount to set.
       * @return This builder for chaining.
       */
      public Builder setDroppedAttributesCount(int value) {

        droppedAttributesCount_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The number of attributes that were discarded. Attributes
       * can be discarded because their keys are too long or because there are too many
       * attributes. If this value is 0, then no attributes were dropped.
       * </pre>
       *
       * <code>uint32 dropped_attributes_count = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearDroppedAttributesCount() {
        bitField0_ = (bitField0_ & ~0x00000008);
        droppedAttributesCount_ = 0;
        onChanged();
        return this;
      }

      private long resourceRef_ ;
      /**
       * <pre>
       * Resource in which this instrumentation scope was created.
       * </pre>
       *
       * <code>int64 resource_ref = 5;</code>
       * @return The resourceRef.
       */
      @java.lang.Override
      public long getResourceRef() {
        return resourceRef_;
      }
      /**
       * <pre>
       * Resource in which this instrumentation scope was created.
       * </pre>
       *
       * <code>int64 resource_ref = 5;</code>
       * @param value The resourceRef to set.
       * @return This builder for chaining.
       */
      public Builder setResourceRef(long value) {

        resourceRef_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Resource in which this instrumentation scope was created.
       * </pre>
       *
       * <code>int64 resource_ref = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearResourceRef() {
        bitField0_ = (bitField0_ & ~0x00000010);
        resourceRef_ = 0L;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:opentelemetry.proto.mmap.v1.InstrumentationScope)
    }

    // @@protoc_insertion_point(class_scope:opentelemetry.proto.mmap.v1.InstrumentationScope)
    private static final opentelemetry.proto.mmap.v1.Mmap.InstrumentationScope DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new opentelemetry.proto.mmap.v1.Mmap.InstrumentationScope();
    }

    public static opentelemetry.proto.mmap.v1.Mmap.InstrumentationScope getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<InstrumentationScope>
        PARSER = new com.google.protobuf.AbstractParser<InstrumentationScope>() {
      @java.lang.Override
      public InstrumentationScope parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<InstrumentationScope> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<InstrumentationScope> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public opentelemetry.proto.mmap.v1.Mmap.InstrumentationScope getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface KeyValueRefOrBuilder extends
      // @@protoc_insertion_point(interface_extends:opentelemetry.proto.mmap.v1.KeyValueRef)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Reference to a key in the dictionary.
     * </pre>
     *
     * <code>int64 key_ref = 1;</code>
     * @return The keyRef.
     */
    long getKeyRef();

    /**
     * <pre>
     * The value of this key-value.
     * </pre>
     *
     * <code>.opentelemetry.proto.mmap.v1.AnyValue value = 2;</code>
     * @return Whether the value field is set.
     */
    boolean hasValue();
    /**
     * <pre>
     * The value of this key-value.
     * </pre>
     *
     * <code>.opentelemetry.proto.mmap.v1.AnyValue value = 2;</code>
     * @return The value.
     */
    opentelemetry.proto.mmap.v1.Mmap.AnyValue getValue();
    /**
     * <pre>
     * The value of this key-value.
     * </pre>
     *
     * <code>.opentelemetry.proto.mmap.v1.AnyValue value = 2;</code>
     */
    opentelemetry.proto.mmap.v1.Mmap.AnyValueOrBuilder getValueOrBuilder();
  }
  /**
   * <pre>
   * KeyValue Ref represents a Key-Value pair.
   * </pre>
   *
   * Protobuf type {@code opentelemetry.proto.mmap.v1.KeyValueRef}
   */
  public static final class KeyValueRef extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:opentelemetry.proto.mmap.v1.KeyValueRef)
      KeyValueRefOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 33,
        /* patch= */ 0,
        /* suffix= */ "",
        "KeyValueRef");
    }
    // Use KeyValueRef.newBuilder() to construct.
    private KeyValueRef(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private KeyValueRef() {
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_KeyValueRef_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_KeyValueRef_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.class, opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.Builder.class);
    }

    private int bitField0_;
    public static final int KEY_REF_FIELD_NUMBER = 1;
    private long keyRef_ = 0L;
    /**
     * <pre>
     * Reference to a key in the dictionary.
     * </pre>
     *
     * <code>int64 key_ref = 1;</code>
     * @return The keyRef.
     */
    @java.lang.Override
    public long getKeyRef() {
      return keyRef_;
    }

    public static final int VALUE_FIELD_NUMBER = 2;
    private opentelemetry.proto.mmap.v1.Mmap.AnyValue value_;
    /**
     * <pre>
     * The value of this key-value.
     * </pre>
     *
     * <code>.opentelemetry.proto.mmap.v1.AnyValue value = 2;</code>
     * @return Whether the value field is set.
     */
    @java.lang.Override
    public boolean hasValue() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * The value of this key-value.
     * </pre>
     *
     * <code>.opentelemetry.proto.mmap.v1.AnyValue value = 2;</code>
     * @return The value.
     */
    @java.lang.Override
    public opentelemetry.proto.mmap.v1.Mmap.AnyValue getValue() {
      return value_ == null ? opentelemetry.proto.mmap.v1.Mmap.AnyValue.getDefaultInstance() : value_;
    }
    /**
     * <pre>
     * The value of this key-value.
     * </pre>
     *
     * <code>.opentelemetry.proto.mmap.v1.AnyValue value = 2;</code>
     */
    @java.lang.Override
    public opentelemetry.proto.mmap.v1.Mmap.AnyValueOrBuilder getValueOrBuilder() {
      return value_ == null ? opentelemetry.proto.mmap.v1.Mmap.AnyValue.getDefaultInstance() : value_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (keyRef_ != 0L) {
        output.writeInt64(1, keyRef_);
      }
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeMessage(2, getValue());
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (keyRef_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(1, keyRef_);
      }
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getValue());
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof opentelemetry.proto.mmap.v1.Mmap.KeyValueRef)) {
        return super.equals(obj);
      }
      opentelemetry.proto.mmap.v1.Mmap.KeyValueRef other = (opentelemetry.proto.mmap.v1.Mmap.KeyValueRef) obj;

      if (getKeyRef()
          != other.getKeyRef()) return false;
      if (hasValue() != other.hasValue()) return false;
      if (hasValue()) {
        if (!getValue()
            .equals(other.getValue())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + KEY_REF_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getKeyRef());
      if (hasValue()) {
        hash = (37 * hash) + VALUE_FIELD_NUMBER;
        hash = (53 * hash) + getValue().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static opentelemetry.proto.mmap.v1.Mmap.KeyValueRef parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.KeyValueRef parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.KeyValueRef parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.KeyValueRef parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.KeyValueRef parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.KeyValueRef parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.KeyValueRef parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.KeyValueRef parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static opentelemetry.proto.mmap.v1.Mmap.KeyValueRef parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static opentelemetry.proto.mmap.v1.Mmap.KeyValueRef parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.KeyValueRef parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.KeyValueRef parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(opentelemetry.proto.mmap.v1.Mmap.KeyValueRef prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * KeyValue Ref represents a Key-Value pair.
     * </pre>
     *
     * Protobuf type {@code opentelemetry.proto.mmap.v1.KeyValueRef}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:opentelemetry.proto.mmap.v1.KeyValueRef)
        opentelemetry.proto.mmap.v1.Mmap.KeyValueRefOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_KeyValueRef_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_KeyValueRef_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.class, opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.Builder.class);
      }

      // Construct using opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage
                .alwaysUseFieldBuilders) {
          internalGetValueFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        keyRef_ = 0L;
        value_ = null;
        if (valueBuilder_ != null) {
          valueBuilder_.dispose();
          valueBuilder_ = null;
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_KeyValueRef_descriptor;
      }

      @java.lang.Override
      public opentelemetry.proto.mmap.v1.Mmap.KeyValueRef getDefaultInstanceForType() {
        return opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.getDefaultInstance();
      }

      @java.lang.Override
      public opentelemetry.proto.mmap.v1.Mmap.KeyValueRef build() {
        opentelemetry.proto.mmap.v1.Mmap.KeyValueRef result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public opentelemetry.proto.mmap.v1.Mmap.KeyValueRef buildPartial() {
        opentelemetry.proto.mmap.v1.Mmap.KeyValueRef result = new opentelemetry.proto.mmap.v1.Mmap.KeyValueRef(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(opentelemetry.proto.mmap.v1.Mmap.KeyValueRef result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.keyRef_ = keyRef_;
        }
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.value_ = valueBuilder_ == null
              ? value_
              : valueBuilder_.build();
          to_bitField0_ |= 0x00000001;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof opentelemetry.proto.mmap.v1.Mmap.KeyValueRef) {
          return mergeFrom((opentelemetry.proto.mmap.v1.Mmap.KeyValueRef)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(opentelemetry.proto.mmap.v1.Mmap.KeyValueRef other) {
        if (other == opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.getDefaultInstance()) return this;
        if (other.getKeyRef() != 0L) {
          setKeyRef(other.getKeyRef());
        }
        if (other.hasValue()) {
          mergeValue(other.getValue());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8: {
                keyRef_ = input.readInt64();
                bitField0_ |= 0x00000001;
                break;
              } // case 8
              case 18: {
                input.readMessage(
                    internalGetValueFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private long keyRef_ ;
      /**
       * <pre>
       * Reference to a key in the dictionary.
       * </pre>
       *
       * <code>int64 key_ref = 1;</code>
       * @return The keyRef.
       */
      @java.lang.Override
      public long getKeyRef() {
        return keyRef_;
      }
      /**
       * <pre>
       * Reference to a key in the dictionary.
       * </pre>
       *
       * <code>int64 key_ref = 1;</code>
       * @param value The keyRef to set.
       * @return This builder for chaining.
       */
      public Builder setKeyRef(long value) {

        keyRef_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Reference to a key in the dictionary.
       * </pre>
       *
       * <code>int64 key_ref = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearKeyRef() {
        bitField0_ = (bitField0_ & ~0x00000001);
        keyRef_ = 0L;
        onChanged();
        return this;
      }

      private opentelemetry.proto.mmap.v1.Mmap.AnyValue value_;
      private com.google.protobuf.SingleFieldBuilder<
          opentelemetry.proto.mmap.v1.Mmap.AnyValue, opentelemetry.proto.mmap.v1.Mmap.AnyValue.Builder, opentelemetry.proto.mmap.v1.Mmap.AnyValueOrBuilder> valueBuilder_;
      /**
       * <pre>
       * The value of this key-value.
       * </pre>
       *
       * <code>.opentelemetry.proto.mmap.v1.AnyValue value = 2;</code>
       * @return Whether the value field is set.
       */
      public boolean hasValue() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * The value of this key-value.
       * </pre>
       *
       * <code>.opentelemetry.proto.mmap.v1.AnyValue value = 2;</code>
       * @return The value.
       */
      public opentelemetry.proto.mmap.v1.Mmap.AnyValue getValue() {
        if (valueBuilder_ == null) {
          return value_ == null ? opentelemetry.proto.mmap.v1.Mmap.AnyValue.getDefaultInstance() : value_;
        } else {
          return valueBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * The value of this key-value.
       * </pre>
       *
       * <code>.opentelemetry.proto.mmap.v1.AnyValue value = 2;</code>
       */
      public Builder setValue(opentelemetry.proto.mmap.v1.Mmap.AnyValue value) {
        if (valueBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          value_ = value;
        } else {
          valueBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The value of this key-value.
       * </pre>
       *
       * <code>.opentelemetry.proto.mmap.v1.AnyValue value = 2;</code>
       */
      public Builder setValue(
          opentelemetry.proto.mmap.v1.Mmap.AnyValue.Builder builderForValue) {
        if (valueBuilder_ == null) {
          value_ = builderForValue.build();
        } else {
          valueBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The value of this key-value.
       * </pre>
       *
       * <code>.opentelemetry.proto.mmap.v1.AnyValue value = 2;</code>
       */
      public Builder mergeValue(opentelemetry.proto.mmap.v1.Mmap.AnyValue value) {
        if (valueBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0) &&
            value_ != null &&
            value_ != opentelemetry.proto.mmap.v1.Mmap.AnyValue.getDefaultInstance()) {
            getValueBuilder().mergeFrom(value);
          } else {
            value_ = value;
          }
        } else {
          valueBuilder_.mergeFrom(value);
        }
        if (value_ != null) {
          bitField0_ |= 0x00000002;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * The value of this key-value.
       * </pre>
       *
       * <code>.opentelemetry.proto.mmap.v1.AnyValue value = 2;</code>
       */
      public Builder clearValue() {
        bitField0_ = (bitField0_ & ~0x00000002);
        value_ = null;
        if (valueBuilder_ != null) {
          valueBuilder_.dispose();
          valueBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The value of this key-value.
       * </pre>
       *
       * <code>.opentelemetry.proto.mmap.v1.AnyValue value = 2;</code>
       */
      public opentelemetry.proto.mmap.v1.Mmap.AnyValue.Builder getValueBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return internalGetValueFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * The value of this key-value.
       * </pre>
       *
       * <code>.opentelemetry.proto.mmap.v1.AnyValue value = 2;</code>
       */
      public opentelemetry.proto.mmap.v1.Mmap.AnyValueOrBuilder getValueOrBuilder() {
        if (valueBuilder_ != null) {
          return valueBuilder_.getMessageOrBuilder();
        } else {
          return value_ == null ?
              opentelemetry.proto.mmap.v1.Mmap.AnyValue.getDefaultInstance() : value_;
        }
      }
      /**
       * <pre>
       * The value of this key-value.
       * </pre>
       *
       * <code>.opentelemetry.proto.mmap.v1.AnyValue value = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          opentelemetry.proto.mmap.v1.Mmap.AnyValue, opentelemetry.proto.mmap.v1.Mmap.AnyValue.Builder, opentelemetry.proto.mmap.v1.Mmap.AnyValueOrBuilder> 
          internalGetValueFieldBuilder() {
        if (valueBuilder_ == null) {
          valueBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              opentelemetry.proto.mmap.v1.Mmap.AnyValue, opentelemetry.proto.mmap.v1.Mmap.AnyValue.Builder, opentelemetry.proto.mmap.v1.Mmap.AnyValueOrBuilder>(
                  getValue(),
                  getParentForChildren(),
                  isClean());
          value_ = null;
        }
        return valueBuilder_;
      }

      // @@protoc_insertion_point(builder_scope:opentelemetry.proto.mmap.v1.KeyValueRef)
    }

    // @@protoc_insertion_point(class_scope:opentelemetry.proto.mmap.v1.KeyValueRef)
    private static final opentelemetry.proto.mmap.v1.Mmap.KeyValueRef DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new opentelemetry.proto.mmap.v1.Mmap.KeyValueRef();
    }

    public static opentelemetry.proto.mmap.v1.Mmap.KeyValueRef getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<KeyValueRef>
        PARSER = new com.google.protobuf.AbstractParser<KeyValueRef>() {
      @java.lang.Override
      public KeyValueRef parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<KeyValueRef> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<KeyValueRef> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public opentelemetry.proto.mmap.v1.Mmap.KeyValueRef getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface AnyValueOrBuilder extends
      // @@protoc_insertion_point(interface_extends:opentelemetry.proto.mmap.v1.AnyValue)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>string string_value = 1;</code>
     * @return Whether the stringValue field is set.
     */
    boolean hasStringValue();
    /**
     * <code>string string_value = 1;</code>
     * @return The stringValue.
     */
    java.lang.String getStringValue();
    /**
     * <code>string string_value = 1;</code>
     * @return The bytes for stringValue.
     */
    com.google.protobuf.ByteString
        getStringValueBytes();

    /**
     * <code>bool bool_value = 2;</code>
     * @return Whether the boolValue field is set.
     */
    boolean hasBoolValue();
    /**
     * <code>bool bool_value = 2;</code>
     * @return The boolValue.
     */
    boolean getBoolValue();

    /**
     * <code>int64 int_value = 3;</code>
     * @return Whether the intValue field is set.
     */
    boolean hasIntValue();
    /**
     * <code>int64 int_value = 3;</code>
     * @return The intValue.
     */
    long getIntValue();

    /**
     * <code>double double_value = 4;</code>
     * @return Whether the doubleValue field is set.
     */
    boolean hasDoubleValue();
    /**
     * <code>double double_value = 4;</code>
     * @return The doubleValue.
     */
    double getDoubleValue();

    /**
     * <code>.opentelemetry.proto.mmap.v1.ArrayValue array_value = 5;</code>
     * @return Whether the arrayValue field is set.
     */
    boolean hasArrayValue();
    /**
     * <code>.opentelemetry.proto.mmap.v1.ArrayValue array_value = 5;</code>
     * @return The arrayValue.
     */
    opentelemetry.proto.mmap.v1.Mmap.ArrayValue getArrayValue();
    /**
     * <code>.opentelemetry.proto.mmap.v1.ArrayValue array_value = 5;</code>
     */
    opentelemetry.proto.mmap.v1.Mmap.ArrayValueOrBuilder getArrayValueOrBuilder();

    /**
     * <pre>
     * TODO - should we force keys to be in dictionaries here?
     * </pre>
     *
     * <code>.opentelemetry.proto.mmap.v1.KeyValueList kvlist_value = 6;</code>
     * @return Whether the kvlistValue field is set.
     */
    boolean hasKvlistValue();
    /**
     * <pre>
     * TODO - should we force keys to be in dictionaries here?
     * </pre>
     *
     * <code>.opentelemetry.proto.mmap.v1.KeyValueList kvlist_value = 6;</code>
     * @return The kvlistValue.
     */
    opentelemetry.proto.mmap.v1.Mmap.KeyValueList getKvlistValue();
    /**
     * <pre>
     * TODO - should we force keys to be in dictionaries here?
     * </pre>
     *
     * <code>.opentelemetry.proto.mmap.v1.KeyValueList kvlist_value = 6;</code>
     */
    opentelemetry.proto.mmap.v1.Mmap.KeyValueListOrBuilder getKvlistValueOrBuilder();

    /**
     * <code>bytes bytes_value = 7;</code>
     * @return Whether the bytesValue field is set.
     */
    boolean hasBytesValue();
    /**
     * <code>bytes bytes_value = 7;</code>
     * @return The bytesValue.
     */
    com.google.protobuf.ByteString getBytesValue();

    /**
     * <pre>
     * Reference to a value in the dictionary.
     * </pre>
     *
     * <code>int64 value_ref = 8;</code>
     * @return Whether the valueRef field is set.
     */
    boolean hasValueRef();
    /**
     * <pre>
     * Reference to a value in the dictionary.
     * </pre>
     *
     * <code>int64 value_ref = 8;</code>
     * @return The valueRef.
     */
    long getValueRef();

    opentelemetry.proto.mmap.v1.Mmap.AnyValue.ValueCase getValueCase();
  }
  /**
   * <pre>
   * Represents any type of attribute value. AnyValue may contain a
   * primitive value such as a string or integer or it may contain an arbitrary nested
   * object containing arrays, key-value lists and primitives.
   * </pre>
   *
   * Protobuf type {@code opentelemetry.proto.mmap.v1.AnyValue}
   */
  public static final class AnyValue extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:opentelemetry.proto.mmap.v1.AnyValue)
      AnyValueOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 33,
        /* patch= */ 0,
        /* suffix= */ "",
        "AnyValue");
    }
    // Use AnyValue.newBuilder() to construct.
    private AnyValue(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private AnyValue() {
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_AnyValue_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_AnyValue_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              opentelemetry.proto.mmap.v1.Mmap.AnyValue.class, opentelemetry.proto.mmap.v1.Mmap.AnyValue.Builder.class);
    }

    private int valueCase_ = 0;
    @SuppressWarnings("serial")
    private java.lang.Object value_;
    public enum ValueCase
        implements com.google.protobuf.Internal.EnumLite,
            com.google.protobuf.AbstractMessage.InternalOneOfEnum {
      STRING_VALUE(1),
      BOOL_VALUE(2),
      INT_VALUE(3),
      DOUBLE_VALUE(4),
      ARRAY_VALUE(5),
      KVLIST_VALUE(6),
      BYTES_VALUE(7),
      VALUE_REF(8),
      VALUE_NOT_SET(0);
      private final int value;
      private ValueCase(int value) {
        this.value = value;
      }
      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static ValueCase valueOf(int value) {
        return forNumber(value);
      }

      public static ValueCase forNumber(int value) {
        switch (value) {
          case 1: return STRING_VALUE;
          case 2: return BOOL_VALUE;
          case 3: return INT_VALUE;
          case 4: return DOUBLE_VALUE;
          case 5: return ARRAY_VALUE;
          case 6: return KVLIST_VALUE;
          case 7: return BYTES_VALUE;
          case 8: return VALUE_REF;
          case 0: return VALUE_NOT_SET;
          default: return null;
        }
      }
      public int getNumber() {
        return this.value;
      }
    };

    public ValueCase
    getValueCase() {
      return ValueCase.forNumber(
          valueCase_);
    }

    public static final int STRING_VALUE_FIELD_NUMBER = 1;
    /**
     * <code>string string_value = 1;</code>
     * @return Whether the stringValue field is set.
     */
    public boolean hasStringValue() {
      return valueCase_ == 1;
    }
    /**
     * <code>string string_value = 1;</code>
     * @return The stringValue.
     */
    public java.lang.String getStringValue() {
      java.lang.Object ref = "";
      if (valueCase_ == 1) {
        ref = value_;
      }
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (valueCase_ == 1) {
          value_ = s;
        }
        return s;
      }
    }
    /**
     * <code>string string_value = 1;</code>
     * @return The bytes for stringValue.
     */
    public com.google.protobuf.ByteString
        getStringValueBytes() {
      java.lang.Object ref = "";
      if (valueCase_ == 1) {
        ref = value_;
      }
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        if (valueCase_ == 1) {
          value_ = b;
        }
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int BOOL_VALUE_FIELD_NUMBER = 2;
    /**
     * <code>bool bool_value = 2;</code>
     * @return Whether the boolValue field is set.
     */
    @java.lang.Override
    public boolean hasBoolValue() {
      return valueCase_ == 2;
    }
    /**
     * <code>bool bool_value = 2;</code>
     * @return The boolValue.
     */
    @java.lang.Override
    public boolean getBoolValue() {
      if (valueCase_ == 2) {
        return (java.lang.Boolean) value_;
      }
      return false;
    }

    public static final int INT_VALUE_FIELD_NUMBER = 3;
    /**
     * <code>int64 int_value = 3;</code>
     * @return Whether the intValue field is set.
     */
    @java.lang.Override
    public boolean hasIntValue() {
      return valueCase_ == 3;
    }
    /**
     * <code>int64 int_value = 3;</code>
     * @return The intValue.
     */
    @java.lang.Override
    public long getIntValue() {
      if (valueCase_ == 3) {
        return (java.lang.Long) value_;
      }
      return 0L;
    }

    public static final int DOUBLE_VALUE_FIELD_NUMBER = 4;
    /**
     * <code>double double_value = 4;</code>
     * @return Whether the doubleValue field is set.
     */
    @java.lang.Override
    public boolean hasDoubleValue() {
      return valueCase_ == 4;
    }
    /**
     * <code>double double_value = 4;</code>
     * @return The doubleValue.
     */
    @java.lang.Override
    public double getDoubleValue() {
      if (valueCase_ == 4) {
        return (java.lang.Double) value_;
      }
      return 0D;
    }

    public static final int ARRAY_VALUE_FIELD_NUMBER = 5;
    /**
     * <code>.opentelemetry.proto.mmap.v1.ArrayValue array_value = 5;</code>
     * @return Whether the arrayValue field is set.
     */
    @java.lang.Override
    public boolean hasArrayValue() {
      return valueCase_ == 5;
    }
    /**
     * <code>.opentelemetry.proto.mmap.v1.ArrayValue array_value = 5;</code>
     * @return The arrayValue.
     */
    @java.lang.Override
    public opentelemetry.proto.mmap.v1.Mmap.ArrayValue getArrayValue() {
      if (valueCase_ == 5) {
         return (opentelemetry.proto.mmap.v1.Mmap.ArrayValue) value_;
      }
      return opentelemetry.proto.mmap.v1.Mmap.ArrayValue.getDefaultInstance();
    }
    /**
     * <code>.opentelemetry.proto.mmap.v1.ArrayValue array_value = 5;</code>
     */
    @java.lang.Override
    public opentelemetry.proto.mmap.v1.Mmap.ArrayValueOrBuilder getArrayValueOrBuilder() {
      if (valueCase_ == 5) {
         return (opentelemetry.proto.mmap.v1.Mmap.ArrayValue) value_;
      }
      return opentelemetry.proto.mmap.v1.Mmap.ArrayValue.getDefaultInstance();
    }

    public static final int KVLIST_VALUE_FIELD_NUMBER = 6;
    /**
     * <pre>
     * TODO - should we force keys to be in dictionaries here?
     * </pre>
     *
     * <code>.opentelemetry.proto.mmap.v1.KeyValueList kvlist_value = 6;</code>
     * @return Whether the kvlistValue field is set.
     */
    @java.lang.Override
    public boolean hasKvlistValue() {
      return valueCase_ == 6;
    }
    /**
     * <pre>
     * TODO - should we force keys to be in dictionaries here?
     * </pre>
     *
     * <code>.opentelemetry.proto.mmap.v1.KeyValueList kvlist_value = 6;</code>
     * @return The kvlistValue.
     */
    @java.lang.Override
    public opentelemetry.proto.mmap.v1.Mmap.KeyValueList getKvlistValue() {
      if (valueCase_ == 6) {
         return (opentelemetry.proto.mmap.v1.Mmap.KeyValueList) value_;
      }
      return opentelemetry.proto.mmap.v1.Mmap.KeyValueList.getDefaultInstance();
    }
    /**
     * <pre>
     * TODO - should we force keys to be in dictionaries here?
     * </pre>
     *
     * <code>.opentelemetry.proto.mmap.v1.KeyValueList kvlist_value = 6;</code>
     */
    @java.lang.Override
    public opentelemetry.proto.mmap.v1.Mmap.KeyValueListOrBuilder getKvlistValueOrBuilder() {
      if (valueCase_ == 6) {
         return (opentelemetry.proto.mmap.v1.Mmap.KeyValueList) value_;
      }
      return opentelemetry.proto.mmap.v1.Mmap.KeyValueList.getDefaultInstance();
    }

    public static final int BYTES_VALUE_FIELD_NUMBER = 7;
    /**
     * <code>bytes bytes_value = 7;</code>
     * @return Whether the bytesValue field is set.
     */
    @java.lang.Override
    public boolean hasBytesValue() {
      return valueCase_ == 7;
    }
    /**
     * <code>bytes bytes_value = 7;</code>
     * @return The bytesValue.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getBytesValue() {
      if (valueCase_ == 7) {
        return (com.google.protobuf.ByteString) value_;
      }
      return com.google.protobuf.ByteString.EMPTY;
    }

    public static final int VALUE_REF_FIELD_NUMBER = 8;
    /**
     * <pre>
     * Reference to a value in the dictionary.
     * </pre>
     *
     * <code>int64 value_ref = 8;</code>
     * @return Whether the valueRef field is set.
     */
    @java.lang.Override
    public boolean hasValueRef() {
      return valueCase_ == 8;
    }
    /**
     * <pre>
     * Reference to a value in the dictionary.
     * </pre>
     *
     * <code>int64 value_ref = 8;</code>
     * @return The valueRef.
     */
    @java.lang.Override
    public long getValueRef() {
      if (valueCase_ == 8) {
        return (java.lang.Long) value_;
      }
      return 0L;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (valueCase_ == 1) {
        com.google.protobuf.GeneratedMessage.writeString(output, 1, value_);
      }
      if (valueCase_ == 2) {
        output.writeBool(
            2, (boolean)((java.lang.Boolean) value_));
      }
      if (valueCase_ == 3) {
        output.writeInt64(
            3, (long)((java.lang.Long) value_));
      }
      if (valueCase_ == 4) {
        output.writeDouble(
            4, (double)((java.lang.Double) value_));
      }
      if (valueCase_ == 5) {
        output.writeMessage(5, (opentelemetry.proto.mmap.v1.Mmap.ArrayValue) value_);
      }
      if (valueCase_ == 6) {
        output.writeMessage(6, (opentelemetry.proto.mmap.v1.Mmap.KeyValueList) value_);
      }
      if (valueCase_ == 7) {
        output.writeBytes(
            7, (com.google.protobuf.ByteString) value_);
      }
      if (valueCase_ == 8) {
        output.writeInt64(
            8, (long)((java.lang.Long) value_));
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (valueCase_ == 1) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(1, value_);
      }
      if (valueCase_ == 2) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(
              2, (boolean)((java.lang.Boolean) value_));
      }
      if (valueCase_ == 3) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(
              3, (long)((java.lang.Long) value_));
      }
      if (valueCase_ == 4) {
        size += com.google.protobuf.CodedOutputStream
          .computeDoubleSize(
              4, (double)((java.lang.Double) value_));
      }
      if (valueCase_ == 5) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(5, (opentelemetry.proto.mmap.v1.Mmap.ArrayValue) value_);
      }
      if (valueCase_ == 6) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(6, (opentelemetry.proto.mmap.v1.Mmap.KeyValueList) value_);
      }
      if (valueCase_ == 7) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(
              7, (com.google.protobuf.ByteString) value_);
      }
      if (valueCase_ == 8) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(
              8, (long)((java.lang.Long) value_));
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof opentelemetry.proto.mmap.v1.Mmap.AnyValue)) {
        return super.equals(obj);
      }
      opentelemetry.proto.mmap.v1.Mmap.AnyValue other = (opentelemetry.proto.mmap.v1.Mmap.AnyValue) obj;

      if (!getValueCase().equals(other.getValueCase())) return false;
      switch (valueCase_) {
        case 1:
          if (!getStringValue()
              .equals(other.getStringValue())) return false;
          break;
        case 2:
          if (getBoolValue()
              != other.getBoolValue()) return false;
          break;
        case 3:
          if (getIntValue()
              != other.getIntValue()) return false;
          break;
        case 4:
          if (java.lang.Double.doubleToLongBits(getDoubleValue())
              != java.lang.Double.doubleToLongBits(
                  other.getDoubleValue())) return false;
          break;
        case 5:
          if (!getArrayValue()
              .equals(other.getArrayValue())) return false;
          break;
        case 6:
          if (!getKvlistValue()
              .equals(other.getKvlistValue())) return false;
          break;
        case 7:
          if (!getBytesValue()
              .equals(other.getBytesValue())) return false;
          break;
        case 8:
          if (getValueRef()
              != other.getValueRef()) return false;
          break;
        case 0:
        default:
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      switch (valueCase_) {
        case 1:
          hash = (37 * hash) + STRING_VALUE_FIELD_NUMBER;
          hash = (53 * hash) + getStringValue().hashCode();
          break;
        case 2:
          hash = (37 * hash) + BOOL_VALUE_FIELD_NUMBER;
          hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
              getBoolValue());
          break;
        case 3:
          hash = (37 * hash) + INT_VALUE_FIELD_NUMBER;
          hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
              getIntValue());
          break;
        case 4:
          hash = (37 * hash) + DOUBLE_VALUE_FIELD_NUMBER;
          hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
              java.lang.Double.doubleToLongBits(getDoubleValue()));
          break;
        case 5:
          hash = (37 * hash) + ARRAY_VALUE_FIELD_NUMBER;
          hash = (53 * hash) + getArrayValue().hashCode();
          break;
        case 6:
          hash = (37 * hash) + KVLIST_VALUE_FIELD_NUMBER;
          hash = (53 * hash) + getKvlistValue().hashCode();
          break;
        case 7:
          hash = (37 * hash) + BYTES_VALUE_FIELD_NUMBER;
          hash = (53 * hash) + getBytesValue().hashCode();
          break;
        case 8:
          hash = (37 * hash) + VALUE_REF_FIELD_NUMBER;
          hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
              getValueRef());
          break;
        case 0:
        default:
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static opentelemetry.proto.mmap.v1.Mmap.AnyValue parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.AnyValue parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.AnyValue parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.AnyValue parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.AnyValue parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.AnyValue parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.AnyValue parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.AnyValue parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static opentelemetry.proto.mmap.v1.Mmap.AnyValue parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static opentelemetry.proto.mmap.v1.Mmap.AnyValue parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.AnyValue parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.AnyValue parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(opentelemetry.proto.mmap.v1.Mmap.AnyValue prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Represents any type of attribute value. AnyValue may contain a
     * primitive value such as a string or integer or it may contain an arbitrary nested
     * object containing arrays, key-value lists and primitives.
     * </pre>
     *
     * Protobuf type {@code opentelemetry.proto.mmap.v1.AnyValue}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:opentelemetry.proto.mmap.v1.AnyValue)
        opentelemetry.proto.mmap.v1.Mmap.AnyValueOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_AnyValue_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_AnyValue_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                opentelemetry.proto.mmap.v1.Mmap.AnyValue.class, opentelemetry.proto.mmap.v1.Mmap.AnyValue.Builder.class);
      }

      // Construct using opentelemetry.proto.mmap.v1.Mmap.AnyValue.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        if (arrayValueBuilder_ != null) {
          arrayValueBuilder_.clear();
        }
        if (kvlistValueBuilder_ != null) {
          kvlistValueBuilder_.clear();
        }
        valueCase_ = 0;
        value_ = null;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_AnyValue_descriptor;
      }

      @java.lang.Override
      public opentelemetry.proto.mmap.v1.Mmap.AnyValue getDefaultInstanceForType() {
        return opentelemetry.proto.mmap.v1.Mmap.AnyValue.getDefaultInstance();
      }

      @java.lang.Override
      public opentelemetry.proto.mmap.v1.Mmap.AnyValue build() {
        opentelemetry.proto.mmap.v1.Mmap.AnyValue result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public opentelemetry.proto.mmap.v1.Mmap.AnyValue buildPartial() {
        opentelemetry.proto.mmap.v1.Mmap.AnyValue result = new opentelemetry.proto.mmap.v1.Mmap.AnyValue(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        buildPartialOneofs(result);
        onBuilt();
        return result;
      }

      private void buildPartial0(opentelemetry.proto.mmap.v1.Mmap.AnyValue result) {
        int from_bitField0_ = bitField0_;
      }

      private void buildPartialOneofs(opentelemetry.proto.mmap.v1.Mmap.AnyValue result) {
        result.valueCase_ = valueCase_;
        result.value_ = this.value_;
        if (valueCase_ == 5 &&
            arrayValueBuilder_ != null) {
          result.value_ = arrayValueBuilder_.build();
        }
        if (valueCase_ == 6 &&
            kvlistValueBuilder_ != null) {
          result.value_ = kvlistValueBuilder_.build();
        }
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof opentelemetry.proto.mmap.v1.Mmap.AnyValue) {
          return mergeFrom((opentelemetry.proto.mmap.v1.Mmap.AnyValue)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(opentelemetry.proto.mmap.v1.Mmap.AnyValue other) {
        if (other == opentelemetry.proto.mmap.v1.Mmap.AnyValue.getDefaultInstance()) return this;
        switch (other.getValueCase()) {
          case STRING_VALUE: {
            valueCase_ = 1;
            value_ = other.value_;
            onChanged();
            break;
          }
          case BOOL_VALUE: {
            setBoolValue(other.getBoolValue());
            break;
          }
          case INT_VALUE: {
            setIntValue(other.getIntValue());
            break;
          }
          case DOUBLE_VALUE: {
            setDoubleValue(other.getDoubleValue());
            break;
          }
          case ARRAY_VALUE: {
            mergeArrayValue(other.getArrayValue());
            break;
          }
          case KVLIST_VALUE: {
            mergeKvlistValue(other.getKvlistValue());
            break;
          }
          case BYTES_VALUE: {
            setBytesValue(other.getBytesValue());
            break;
          }
          case VALUE_REF: {
            setValueRef(other.getValueRef());
            break;
          }
          case VALUE_NOT_SET: {
            break;
          }
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                java.lang.String s = input.readStringRequireUtf8();
                valueCase_ = 1;
                value_ = s;
                break;
              } // case 10
              case 16: {
                value_ = input.readBool();
                valueCase_ = 2;
                break;
              } // case 16
              case 24: {
                value_ = input.readInt64();
                valueCase_ = 3;
                break;
              } // case 24
              case 33: {
                value_ = input.readDouble();
                valueCase_ = 4;
                break;
              } // case 33
              case 42: {
                input.readMessage(
                    internalGetArrayValueFieldBuilder().getBuilder(),
                    extensionRegistry);
                valueCase_ = 5;
                break;
              } // case 42
              case 50: {
                input.readMessage(
                    internalGetKvlistValueFieldBuilder().getBuilder(),
                    extensionRegistry);
                valueCase_ = 6;
                break;
              } // case 50
              case 58: {
                value_ = input.readBytes();
                valueCase_ = 7;
                break;
              } // case 58
              case 64: {
                value_ = input.readInt64();
                valueCase_ = 8;
                break;
              } // case 64
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int valueCase_ = 0;
      private java.lang.Object value_;
      public ValueCase
          getValueCase() {
        return ValueCase.forNumber(
            valueCase_);
      }

      public Builder clearValue() {
        valueCase_ = 0;
        value_ = null;
        onChanged();
        return this;
      }

      private int bitField0_;

      /**
       * <code>string string_value = 1;</code>
       * @return Whether the stringValue field is set.
       */
      @java.lang.Override
      public boolean hasStringValue() {
        return valueCase_ == 1;
      }
      /**
       * <code>string string_value = 1;</code>
       * @return The stringValue.
       */
      @java.lang.Override
      public java.lang.String getStringValue() {
        java.lang.Object ref = "";
        if (valueCase_ == 1) {
          ref = value_;
        }
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (valueCase_ == 1) {
            value_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <code>string string_value = 1;</code>
       * @return The bytes for stringValue.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getStringValueBytes() {
        java.lang.Object ref = "";
        if (valueCase_ == 1) {
          ref = value_;
        }
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          if (valueCase_ == 1) {
            value_ = b;
          }
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>string string_value = 1;</code>
       * @param value The stringValue to set.
       * @return This builder for chaining.
       */
      public Builder setStringValue(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        valueCase_ = 1;
        value_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>string string_value = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearStringValue() {
        if (valueCase_ == 1) {
          valueCase_ = 0;
          value_ = null;
          onChanged();
        }
        return this;
      }
      /**
       * <code>string string_value = 1;</code>
       * @param value The bytes for stringValue to set.
       * @return This builder for chaining.
       */
      public Builder setStringValueBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        valueCase_ = 1;
        value_ = value;
        onChanged();
        return this;
      }

      /**
       * <code>bool bool_value = 2;</code>
       * @return Whether the boolValue field is set.
       */
      public boolean hasBoolValue() {
        return valueCase_ == 2;
      }
      /**
       * <code>bool bool_value = 2;</code>
       * @return The boolValue.
       */
      public boolean getBoolValue() {
        if (valueCase_ == 2) {
          return (java.lang.Boolean) value_;
        }
        return false;
      }
      /**
       * <code>bool bool_value = 2;</code>
       * @param value The boolValue to set.
       * @return This builder for chaining.
       */
      public Builder setBoolValue(boolean value) {

        valueCase_ = 2;
        value_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>bool bool_value = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearBoolValue() {
        if (valueCase_ == 2) {
          valueCase_ = 0;
          value_ = null;
          onChanged();
        }
        return this;
      }

      /**
       * <code>int64 int_value = 3;</code>
       * @return Whether the intValue field is set.
       */
      public boolean hasIntValue() {
        return valueCase_ == 3;
      }
      /**
       * <code>int64 int_value = 3;</code>
       * @return The intValue.
       */
      public long getIntValue() {
        if (valueCase_ == 3) {
          return (java.lang.Long) value_;
        }
        return 0L;
      }
      /**
       * <code>int64 int_value = 3;</code>
       * @param value The intValue to set.
       * @return This builder for chaining.
       */
      public Builder setIntValue(long value) {

        valueCase_ = 3;
        value_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>int64 int_value = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearIntValue() {
        if (valueCase_ == 3) {
          valueCase_ = 0;
          value_ = null;
          onChanged();
        }
        return this;
      }

      /**
       * <code>double double_value = 4;</code>
       * @return Whether the doubleValue field is set.
       */
      public boolean hasDoubleValue() {
        return valueCase_ == 4;
      }
      /**
       * <code>double double_value = 4;</code>
       * @return The doubleValue.
       */
      public double getDoubleValue() {
        if (valueCase_ == 4) {
          return (java.lang.Double) value_;
        }
        return 0D;
      }
      /**
       * <code>double double_value = 4;</code>
       * @param value The doubleValue to set.
       * @return This builder for chaining.
       */
      public Builder setDoubleValue(double value) {

        valueCase_ = 4;
        value_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>double double_value = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearDoubleValue() {
        if (valueCase_ == 4) {
          valueCase_ = 0;
          value_ = null;
          onChanged();
        }
        return this;
      }

      private com.google.protobuf.SingleFieldBuilder<
          opentelemetry.proto.mmap.v1.Mmap.ArrayValue, opentelemetry.proto.mmap.v1.Mmap.ArrayValue.Builder, opentelemetry.proto.mmap.v1.Mmap.ArrayValueOrBuilder> arrayValueBuilder_;
      /**
       * <code>.opentelemetry.proto.mmap.v1.ArrayValue array_value = 5;</code>
       * @return Whether the arrayValue field is set.
       */
      @java.lang.Override
      public boolean hasArrayValue() {
        return valueCase_ == 5;
      }
      /**
       * <code>.opentelemetry.proto.mmap.v1.ArrayValue array_value = 5;</code>
       * @return The arrayValue.
       */
      @java.lang.Override
      public opentelemetry.proto.mmap.v1.Mmap.ArrayValue getArrayValue() {
        if (arrayValueBuilder_ == null) {
          if (valueCase_ == 5) {
            return (opentelemetry.proto.mmap.v1.Mmap.ArrayValue) value_;
          }
          return opentelemetry.proto.mmap.v1.Mmap.ArrayValue.getDefaultInstance();
        } else {
          if (valueCase_ == 5) {
            return arrayValueBuilder_.getMessage();
          }
          return opentelemetry.proto.mmap.v1.Mmap.ArrayValue.getDefaultInstance();
        }
      }
      /**
       * <code>.opentelemetry.proto.mmap.v1.ArrayValue array_value = 5;</code>
       */
      public Builder setArrayValue(opentelemetry.proto.mmap.v1.Mmap.ArrayValue value) {
        if (arrayValueBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          value_ = value;
          onChanged();
        } else {
          arrayValueBuilder_.setMessage(value);
        }
        valueCase_ = 5;
        return this;
      }
      /**
       * <code>.opentelemetry.proto.mmap.v1.ArrayValue array_value = 5;</code>
       */
      public Builder setArrayValue(
          opentelemetry.proto.mmap.v1.Mmap.ArrayValue.Builder builderForValue) {
        if (arrayValueBuilder_ == null) {
          value_ = builderForValue.build();
          onChanged();
        } else {
          arrayValueBuilder_.setMessage(builderForValue.build());
        }
        valueCase_ = 5;
        return this;
      }
      /**
       * <code>.opentelemetry.proto.mmap.v1.ArrayValue array_value = 5;</code>
       */
      public Builder mergeArrayValue(opentelemetry.proto.mmap.v1.Mmap.ArrayValue value) {
        if (arrayValueBuilder_ == null) {
          if (valueCase_ == 5 &&
              value_ != opentelemetry.proto.mmap.v1.Mmap.ArrayValue.getDefaultInstance()) {
            value_ = opentelemetry.proto.mmap.v1.Mmap.ArrayValue.newBuilder((opentelemetry.proto.mmap.v1.Mmap.ArrayValue) value_)
                .mergeFrom(value).buildPartial();
          } else {
            value_ = value;
          }
          onChanged();
        } else {
          if (valueCase_ == 5) {
            arrayValueBuilder_.mergeFrom(value);
          } else {
            arrayValueBuilder_.setMessage(value);
          }
        }
        valueCase_ = 5;
        return this;
      }
      /**
       * <code>.opentelemetry.proto.mmap.v1.ArrayValue array_value = 5;</code>
       */
      public Builder clearArrayValue() {
        if (arrayValueBuilder_ == null) {
          if (valueCase_ == 5) {
            valueCase_ = 0;
            value_ = null;
            onChanged();
          }
        } else {
          if (valueCase_ == 5) {
            valueCase_ = 0;
            value_ = null;
          }
          arrayValueBuilder_.clear();
        }
        return this;
      }
      /**
       * <code>.opentelemetry.proto.mmap.v1.ArrayValue array_value = 5;</code>
       */
      public opentelemetry.proto.mmap.v1.Mmap.ArrayValue.Builder getArrayValueBuilder() {
        return internalGetArrayValueFieldBuilder().getBuilder();
      }
      /**
       * <code>.opentelemetry.proto.mmap.v1.ArrayValue array_value = 5;</code>
       */
      @java.lang.Override
      public opentelemetry.proto.mmap.v1.Mmap.ArrayValueOrBuilder getArrayValueOrBuilder() {
        if ((valueCase_ == 5) && (arrayValueBuilder_ != null)) {
          return arrayValueBuilder_.getMessageOrBuilder();
        } else {
          if (valueCase_ == 5) {
            return (opentelemetry.proto.mmap.v1.Mmap.ArrayValue) value_;
          }
          return opentelemetry.proto.mmap.v1.Mmap.ArrayValue.getDefaultInstance();
        }
      }
      /**
       * <code>.opentelemetry.proto.mmap.v1.ArrayValue array_value = 5;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          opentelemetry.proto.mmap.v1.Mmap.ArrayValue, opentelemetry.proto.mmap.v1.Mmap.ArrayValue.Builder, opentelemetry.proto.mmap.v1.Mmap.ArrayValueOrBuilder> 
          internalGetArrayValueFieldBuilder() {
        if (arrayValueBuilder_ == null) {
          if (!(valueCase_ == 5)) {
            value_ = opentelemetry.proto.mmap.v1.Mmap.ArrayValue.getDefaultInstance();
          }
          arrayValueBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              opentelemetry.proto.mmap.v1.Mmap.ArrayValue, opentelemetry.proto.mmap.v1.Mmap.ArrayValue.Builder, opentelemetry.proto.mmap.v1.Mmap.ArrayValueOrBuilder>(
                  (opentelemetry.proto.mmap.v1.Mmap.ArrayValue) value_,
                  getParentForChildren(),
                  isClean());
          value_ = null;
        }
        valueCase_ = 5;
        onChanged();
        return arrayValueBuilder_;
      }

      private com.google.protobuf.SingleFieldBuilder<
          opentelemetry.proto.mmap.v1.Mmap.KeyValueList, opentelemetry.proto.mmap.v1.Mmap.KeyValueList.Builder, opentelemetry.proto.mmap.v1.Mmap.KeyValueListOrBuilder> kvlistValueBuilder_;
      /**
       * <pre>
       * TODO - should we force keys to be in dictionaries here?
       * </pre>
       *
       * <code>.opentelemetry.proto.mmap.v1.KeyValueList kvlist_value = 6;</code>
       * @return Whether the kvlistValue field is set.
       */
      @java.lang.Override
      public boolean hasKvlistValue() {
        return valueCase_ == 6;
      }
      /**
       * <pre>
       * TODO - should we force keys to be in dictionaries here?
       * </pre>
       *
       * <code>.opentelemetry.proto.mmap.v1.KeyValueList kvlist_value = 6;</code>
       * @return The kvlistValue.
       */
      @java.lang.Override
      public opentelemetry.proto.mmap.v1.Mmap.KeyValueList getKvlistValue() {
        if (kvlistValueBuilder_ == null) {
          if (valueCase_ == 6) {
            return (opentelemetry.proto.mmap.v1.Mmap.KeyValueList) value_;
          }
          return opentelemetry.proto.mmap.v1.Mmap.KeyValueList.getDefaultInstance();
        } else {
          if (valueCase_ == 6) {
            return kvlistValueBuilder_.getMessage();
          }
          return opentelemetry.proto.mmap.v1.Mmap.KeyValueList.getDefaultInstance();
        }
      }
      /**
       * <pre>
       * TODO - should we force keys to be in dictionaries here?
       * </pre>
       *
       * <code>.opentelemetry.proto.mmap.v1.KeyValueList kvlist_value = 6;</code>
       */
      public Builder setKvlistValue(opentelemetry.proto.mmap.v1.Mmap.KeyValueList value) {
        if (kvlistValueBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          value_ = value;
          onChanged();
        } else {
          kvlistValueBuilder_.setMessage(value);
        }
        valueCase_ = 6;
        return this;
      }
      /**
       * <pre>
       * TODO - should we force keys to be in dictionaries here?
       * </pre>
       *
       * <code>.opentelemetry.proto.mmap.v1.KeyValueList kvlist_value = 6;</code>
       */
      public Builder setKvlistValue(
          opentelemetry.proto.mmap.v1.Mmap.KeyValueList.Builder builderForValue) {
        if (kvlistValueBuilder_ == null) {
          value_ = builderForValue.build();
          onChanged();
        } else {
          kvlistValueBuilder_.setMessage(builderForValue.build());
        }
        valueCase_ = 6;
        return this;
      }
      /**
       * <pre>
       * TODO - should we force keys to be in dictionaries here?
       * </pre>
       *
       * <code>.opentelemetry.proto.mmap.v1.KeyValueList kvlist_value = 6;</code>
       */
      public Builder mergeKvlistValue(opentelemetry.proto.mmap.v1.Mmap.KeyValueList value) {
        if (kvlistValueBuilder_ == null) {
          if (valueCase_ == 6 &&
              value_ != opentelemetry.proto.mmap.v1.Mmap.KeyValueList.getDefaultInstance()) {
            value_ = opentelemetry.proto.mmap.v1.Mmap.KeyValueList.newBuilder((opentelemetry.proto.mmap.v1.Mmap.KeyValueList) value_)
                .mergeFrom(value).buildPartial();
          } else {
            value_ = value;
          }
          onChanged();
        } else {
          if (valueCase_ == 6) {
            kvlistValueBuilder_.mergeFrom(value);
          } else {
            kvlistValueBuilder_.setMessage(value);
          }
        }
        valueCase_ = 6;
        return this;
      }
      /**
       * <pre>
       * TODO - should we force keys to be in dictionaries here?
       * </pre>
       *
       * <code>.opentelemetry.proto.mmap.v1.KeyValueList kvlist_value = 6;</code>
       */
      public Builder clearKvlistValue() {
        if (kvlistValueBuilder_ == null) {
          if (valueCase_ == 6) {
            valueCase_ = 0;
            value_ = null;
            onChanged();
          }
        } else {
          if (valueCase_ == 6) {
            valueCase_ = 0;
            value_ = null;
          }
          kvlistValueBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * TODO - should we force keys to be in dictionaries here?
       * </pre>
       *
       * <code>.opentelemetry.proto.mmap.v1.KeyValueList kvlist_value = 6;</code>
       */
      public opentelemetry.proto.mmap.v1.Mmap.KeyValueList.Builder getKvlistValueBuilder() {
        return internalGetKvlistValueFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * TODO - should we force keys to be in dictionaries here?
       * </pre>
       *
       * <code>.opentelemetry.proto.mmap.v1.KeyValueList kvlist_value = 6;</code>
       */
      @java.lang.Override
      public opentelemetry.proto.mmap.v1.Mmap.KeyValueListOrBuilder getKvlistValueOrBuilder() {
        if ((valueCase_ == 6) && (kvlistValueBuilder_ != null)) {
          return kvlistValueBuilder_.getMessageOrBuilder();
        } else {
          if (valueCase_ == 6) {
            return (opentelemetry.proto.mmap.v1.Mmap.KeyValueList) value_;
          }
          return opentelemetry.proto.mmap.v1.Mmap.KeyValueList.getDefaultInstance();
        }
      }
      /**
       * <pre>
       * TODO - should we force keys to be in dictionaries here?
       * </pre>
       *
       * <code>.opentelemetry.proto.mmap.v1.KeyValueList kvlist_value = 6;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          opentelemetry.proto.mmap.v1.Mmap.KeyValueList, opentelemetry.proto.mmap.v1.Mmap.KeyValueList.Builder, opentelemetry.proto.mmap.v1.Mmap.KeyValueListOrBuilder> 
          internalGetKvlistValueFieldBuilder() {
        if (kvlistValueBuilder_ == null) {
          if (!(valueCase_ == 6)) {
            value_ = opentelemetry.proto.mmap.v1.Mmap.KeyValueList.getDefaultInstance();
          }
          kvlistValueBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              opentelemetry.proto.mmap.v1.Mmap.KeyValueList, opentelemetry.proto.mmap.v1.Mmap.KeyValueList.Builder, opentelemetry.proto.mmap.v1.Mmap.KeyValueListOrBuilder>(
                  (opentelemetry.proto.mmap.v1.Mmap.KeyValueList) value_,
                  getParentForChildren(),
                  isClean());
          value_ = null;
        }
        valueCase_ = 6;
        onChanged();
        return kvlistValueBuilder_;
      }

      /**
       * <code>bytes bytes_value = 7;</code>
       * @return Whether the bytesValue field is set.
       */
      public boolean hasBytesValue() {
        return valueCase_ == 7;
      }
      /**
       * <code>bytes bytes_value = 7;</code>
       * @return The bytesValue.
       */
      public com.google.protobuf.ByteString getBytesValue() {
        if (valueCase_ == 7) {
          return (com.google.protobuf.ByteString) value_;
        }
        return com.google.protobuf.ByteString.EMPTY;
      }
      /**
       * <code>bytes bytes_value = 7;</code>
       * @param value The bytesValue to set.
       * @return This builder for chaining.
       */
      public Builder setBytesValue(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        valueCase_ = 7;
        value_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>bytes bytes_value = 7;</code>
       * @return This builder for chaining.
       */
      public Builder clearBytesValue() {
        if (valueCase_ == 7) {
          valueCase_ = 0;
          value_ = null;
          onChanged();
        }
        return this;
      }

      /**
       * <pre>
       * Reference to a value in the dictionary.
       * </pre>
       *
       * <code>int64 value_ref = 8;</code>
       * @return Whether the valueRef field is set.
       */
      public boolean hasValueRef() {
        return valueCase_ == 8;
      }
      /**
       * <pre>
       * Reference to a value in the dictionary.
       * </pre>
       *
       * <code>int64 value_ref = 8;</code>
       * @return The valueRef.
       */
      public long getValueRef() {
        if (valueCase_ == 8) {
          return (java.lang.Long) value_;
        }
        return 0L;
      }
      /**
       * <pre>
       * Reference to a value in the dictionary.
       * </pre>
       *
       * <code>int64 value_ref = 8;</code>
       * @param value The valueRef to set.
       * @return This builder for chaining.
       */
      public Builder setValueRef(long value) {

        valueCase_ = 8;
        value_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Reference to a value in the dictionary.
       * </pre>
       *
       * <code>int64 value_ref = 8;</code>
       * @return This builder for chaining.
       */
      public Builder clearValueRef() {
        if (valueCase_ == 8) {
          valueCase_ = 0;
          value_ = null;
          onChanged();
        }
        return this;
      }

      // @@protoc_insertion_point(builder_scope:opentelemetry.proto.mmap.v1.AnyValue)
    }

    // @@protoc_insertion_point(class_scope:opentelemetry.proto.mmap.v1.AnyValue)
    private static final opentelemetry.proto.mmap.v1.Mmap.AnyValue DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new opentelemetry.proto.mmap.v1.Mmap.AnyValue();
    }

    public static opentelemetry.proto.mmap.v1.Mmap.AnyValue getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<AnyValue>
        PARSER = new com.google.protobuf.AbstractParser<AnyValue>() {
      @java.lang.Override
      public AnyValue parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<AnyValue> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<AnyValue> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public opentelemetry.proto.mmap.v1.Mmap.AnyValue getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ArrayValueOrBuilder extends
      // @@protoc_insertion_point(interface_extends:opentelemetry.proto.mmap.v1.ArrayValue)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Array of values. The array may be empty (contain 0 elements).
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.mmap.v1.AnyValue values = 1;</code>
     */
    java.util.List<opentelemetry.proto.mmap.v1.Mmap.AnyValue> 
        getValuesList();
    /**
     * <pre>
     * Array of values. The array may be empty (contain 0 elements).
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.mmap.v1.AnyValue values = 1;</code>
     */
    opentelemetry.proto.mmap.v1.Mmap.AnyValue getValues(int index);
    /**
     * <pre>
     * Array of values. The array may be empty (contain 0 elements).
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.mmap.v1.AnyValue values = 1;</code>
     */
    int getValuesCount();
    /**
     * <pre>
     * Array of values. The array may be empty (contain 0 elements).
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.mmap.v1.AnyValue values = 1;</code>
     */
    java.util.List<? extends opentelemetry.proto.mmap.v1.Mmap.AnyValueOrBuilder> 
        getValuesOrBuilderList();
    /**
     * <pre>
     * Array of values. The array may be empty (contain 0 elements).
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.mmap.v1.AnyValue values = 1;</code>
     */
    opentelemetry.proto.mmap.v1.Mmap.AnyValueOrBuilder getValuesOrBuilder(
        int index);
  }
  /**
   * <pre>
   * ArrayValue is a list of AnyValue messages. We need ArrayValue as a message
   * since oneof in AnyValue does not allow repeated fields.
   * </pre>
   *
   * Protobuf type {@code opentelemetry.proto.mmap.v1.ArrayValue}
   */
  public static final class ArrayValue extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:opentelemetry.proto.mmap.v1.ArrayValue)
      ArrayValueOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 33,
        /* patch= */ 0,
        /* suffix= */ "",
        "ArrayValue");
    }
    // Use ArrayValue.newBuilder() to construct.
    private ArrayValue(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private ArrayValue() {
      values_ = java.util.Collections.emptyList();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_ArrayValue_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_ArrayValue_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              opentelemetry.proto.mmap.v1.Mmap.ArrayValue.class, opentelemetry.proto.mmap.v1.Mmap.ArrayValue.Builder.class);
    }

    public static final int VALUES_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private java.util.List<opentelemetry.proto.mmap.v1.Mmap.AnyValue> values_;
    /**
     * <pre>
     * Array of values. The array may be empty (contain 0 elements).
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.mmap.v1.AnyValue values = 1;</code>
     */
    @java.lang.Override
    public java.util.List<opentelemetry.proto.mmap.v1.Mmap.AnyValue> getValuesList() {
      return values_;
    }
    /**
     * <pre>
     * Array of values. The array may be empty (contain 0 elements).
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.mmap.v1.AnyValue values = 1;</code>
     */
    @java.lang.Override
    public java.util.List<? extends opentelemetry.proto.mmap.v1.Mmap.AnyValueOrBuilder> 
        getValuesOrBuilderList() {
      return values_;
    }
    /**
     * <pre>
     * Array of values. The array may be empty (contain 0 elements).
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.mmap.v1.AnyValue values = 1;</code>
     */
    @java.lang.Override
    public int getValuesCount() {
      return values_.size();
    }
    /**
     * <pre>
     * Array of values. The array may be empty (contain 0 elements).
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.mmap.v1.AnyValue values = 1;</code>
     */
    @java.lang.Override
    public opentelemetry.proto.mmap.v1.Mmap.AnyValue getValues(int index) {
      return values_.get(index);
    }
    /**
     * <pre>
     * Array of values. The array may be empty (contain 0 elements).
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.mmap.v1.AnyValue values = 1;</code>
     */
    @java.lang.Override
    public opentelemetry.proto.mmap.v1.Mmap.AnyValueOrBuilder getValuesOrBuilder(
        int index) {
      return values_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      for (int i = 0; i < values_.size(); i++) {
        output.writeMessage(1, values_.get(i));
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      for (int i = 0; i < values_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, values_.get(i));
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof opentelemetry.proto.mmap.v1.Mmap.ArrayValue)) {
        return super.equals(obj);
      }
      opentelemetry.proto.mmap.v1.Mmap.ArrayValue other = (opentelemetry.proto.mmap.v1.Mmap.ArrayValue) obj;

      if (!getValuesList()
          .equals(other.getValuesList())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getValuesCount() > 0) {
        hash = (37 * hash) + VALUES_FIELD_NUMBER;
        hash = (53 * hash) + getValuesList().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static opentelemetry.proto.mmap.v1.Mmap.ArrayValue parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.ArrayValue parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.ArrayValue parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.ArrayValue parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.ArrayValue parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.ArrayValue parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.ArrayValue parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.ArrayValue parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static opentelemetry.proto.mmap.v1.Mmap.ArrayValue parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static opentelemetry.proto.mmap.v1.Mmap.ArrayValue parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.ArrayValue parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.ArrayValue parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(opentelemetry.proto.mmap.v1.Mmap.ArrayValue prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * ArrayValue is a list of AnyValue messages. We need ArrayValue as a message
     * since oneof in AnyValue does not allow repeated fields.
     * </pre>
     *
     * Protobuf type {@code opentelemetry.proto.mmap.v1.ArrayValue}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:opentelemetry.proto.mmap.v1.ArrayValue)
        opentelemetry.proto.mmap.v1.Mmap.ArrayValueOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_ArrayValue_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_ArrayValue_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                opentelemetry.proto.mmap.v1.Mmap.ArrayValue.class, opentelemetry.proto.mmap.v1.Mmap.ArrayValue.Builder.class);
      }

      // Construct using opentelemetry.proto.mmap.v1.Mmap.ArrayValue.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        if (valuesBuilder_ == null) {
          values_ = java.util.Collections.emptyList();
        } else {
          values_ = null;
          valuesBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_ArrayValue_descriptor;
      }

      @java.lang.Override
      public opentelemetry.proto.mmap.v1.Mmap.ArrayValue getDefaultInstanceForType() {
        return opentelemetry.proto.mmap.v1.Mmap.ArrayValue.getDefaultInstance();
      }

      @java.lang.Override
      public opentelemetry.proto.mmap.v1.Mmap.ArrayValue build() {
        opentelemetry.proto.mmap.v1.Mmap.ArrayValue result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public opentelemetry.proto.mmap.v1.Mmap.ArrayValue buildPartial() {
        opentelemetry.proto.mmap.v1.Mmap.ArrayValue result = new opentelemetry.proto.mmap.v1.Mmap.ArrayValue(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(opentelemetry.proto.mmap.v1.Mmap.ArrayValue result) {
        if (valuesBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0)) {
            values_ = java.util.Collections.unmodifiableList(values_);
            bitField0_ = (bitField0_ & ~0x00000001);
          }
          result.values_ = values_;
        } else {
          result.values_ = valuesBuilder_.build();
        }
      }

      private void buildPartial0(opentelemetry.proto.mmap.v1.Mmap.ArrayValue result) {
        int from_bitField0_ = bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof opentelemetry.proto.mmap.v1.Mmap.ArrayValue) {
          return mergeFrom((opentelemetry.proto.mmap.v1.Mmap.ArrayValue)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(opentelemetry.proto.mmap.v1.Mmap.ArrayValue other) {
        if (other == opentelemetry.proto.mmap.v1.Mmap.ArrayValue.getDefaultInstance()) return this;
        if (valuesBuilder_ == null) {
          if (!other.values_.isEmpty()) {
            if (values_.isEmpty()) {
              values_ = other.values_;
              bitField0_ = (bitField0_ & ~0x00000001);
            } else {
              ensureValuesIsMutable();
              values_.addAll(other.values_);
            }
            onChanged();
          }
        } else {
          if (!other.values_.isEmpty()) {
            if (valuesBuilder_.isEmpty()) {
              valuesBuilder_.dispose();
              valuesBuilder_ = null;
              values_ = other.values_;
              bitField0_ = (bitField0_ & ~0x00000001);
              valuesBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   internalGetValuesFieldBuilder() : null;
            } else {
              valuesBuilder_.addAllMessages(other.values_);
            }
          }
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                opentelemetry.proto.mmap.v1.Mmap.AnyValue m =
                    input.readMessage(
                        opentelemetry.proto.mmap.v1.Mmap.AnyValue.parser(),
                        extensionRegistry);
                if (valuesBuilder_ == null) {
                  ensureValuesIsMutable();
                  values_.add(m);
                } else {
                  valuesBuilder_.addMessage(m);
                }
                break;
              } // case 10
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.util.List<opentelemetry.proto.mmap.v1.Mmap.AnyValue> values_ =
        java.util.Collections.emptyList();
      private void ensureValuesIsMutable() {
        if (!((bitField0_ & 0x00000001) != 0)) {
          values_ = new java.util.ArrayList<opentelemetry.proto.mmap.v1.Mmap.AnyValue>(values_);
          bitField0_ |= 0x00000001;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          opentelemetry.proto.mmap.v1.Mmap.AnyValue, opentelemetry.proto.mmap.v1.Mmap.AnyValue.Builder, opentelemetry.proto.mmap.v1.Mmap.AnyValueOrBuilder> valuesBuilder_;

      /**
       * <pre>
       * Array of values. The array may be empty (contain 0 elements).
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.AnyValue values = 1;</code>
       */
      public java.util.List<opentelemetry.proto.mmap.v1.Mmap.AnyValue> getValuesList() {
        if (valuesBuilder_ == null) {
          return java.util.Collections.unmodifiableList(values_);
        } else {
          return valuesBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * Array of values. The array may be empty (contain 0 elements).
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.AnyValue values = 1;</code>
       */
      public int getValuesCount() {
        if (valuesBuilder_ == null) {
          return values_.size();
        } else {
          return valuesBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * Array of values. The array may be empty (contain 0 elements).
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.AnyValue values = 1;</code>
       */
      public opentelemetry.proto.mmap.v1.Mmap.AnyValue getValues(int index) {
        if (valuesBuilder_ == null) {
          return values_.get(index);
        } else {
          return valuesBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * Array of values. The array may be empty (contain 0 elements).
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.AnyValue values = 1;</code>
       */
      public Builder setValues(
          int index, opentelemetry.proto.mmap.v1.Mmap.AnyValue value) {
        if (valuesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureValuesIsMutable();
          values_.set(index, value);
          onChanged();
        } else {
          valuesBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Array of values. The array may be empty (contain 0 elements).
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.AnyValue values = 1;</code>
       */
      public Builder setValues(
          int index, opentelemetry.proto.mmap.v1.Mmap.AnyValue.Builder builderForValue) {
        if (valuesBuilder_ == null) {
          ensureValuesIsMutable();
          values_.set(index, builderForValue.build());
          onChanged();
        } else {
          valuesBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Array of values. The array may be empty (contain 0 elements).
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.AnyValue values = 1;</code>
       */
      public Builder addValues(opentelemetry.proto.mmap.v1.Mmap.AnyValue value) {
        if (valuesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureValuesIsMutable();
          values_.add(value);
          onChanged();
        } else {
          valuesBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * Array of values. The array may be empty (contain 0 elements).
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.AnyValue values = 1;</code>
       */
      public Builder addValues(
          int index, opentelemetry.proto.mmap.v1.Mmap.AnyValue value) {
        if (valuesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureValuesIsMutable();
          values_.add(index, value);
          onChanged();
        } else {
          valuesBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Array of values. The array may be empty (contain 0 elements).
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.AnyValue values = 1;</code>
       */
      public Builder addValues(
          opentelemetry.proto.mmap.v1.Mmap.AnyValue.Builder builderForValue) {
        if (valuesBuilder_ == null) {
          ensureValuesIsMutable();
          values_.add(builderForValue.build());
          onChanged();
        } else {
          valuesBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Array of values. The array may be empty (contain 0 elements).
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.AnyValue values = 1;</code>
       */
      public Builder addValues(
          int index, opentelemetry.proto.mmap.v1.Mmap.AnyValue.Builder builderForValue) {
        if (valuesBuilder_ == null) {
          ensureValuesIsMutable();
          values_.add(index, builderForValue.build());
          onChanged();
        } else {
          valuesBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Array of values. The array may be empty (contain 0 elements).
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.AnyValue values = 1;</code>
       */
      public Builder addAllValues(
          java.lang.Iterable<? extends opentelemetry.proto.mmap.v1.Mmap.AnyValue> values) {
        if (valuesBuilder_ == null) {
          ensureValuesIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, values_);
          onChanged();
        } else {
          valuesBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * Array of values. The array may be empty (contain 0 elements).
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.AnyValue values = 1;</code>
       */
      public Builder clearValues() {
        if (valuesBuilder_ == null) {
          values_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
          onChanged();
        } else {
          valuesBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Array of values. The array may be empty (contain 0 elements).
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.AnyValue values = 1;</code>
       */
      public Builder removeValues(int index) {
        if (valuesBuilder_ == null) {
          ensureValuesIsMutable();
          values_.remove(index);
          onChanged();
        } else {
          valuesBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * Array of values. The array may be empty (contain 0 elements).
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.AnyValue values = 1;</code>
       */
      public opentelemetry.proto.mmap.v1.Mmap.AnyValue.Builder getValuesBuilder(
          int index) {
        return internalGetValuesFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * Array of values. The array may be empty (contain 0 elements).
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.AnyValue values = 1;</code>
       */
      public opentelemetry.proto.mmap.v1.Mmap.AnyValueOrBuilder getValuesOrBuilder(
          int index) {
        if (valuesBuilder_ == null) {
          return values_.get(index);  } else {
          return valuesBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * Array of values. The array may be empty (contain 0 elements).
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.AnyValue values = 1;</code>
       */
      public java.util.List<? extends opentelemetry.proto.mmap.v1.Mmap.AnyValueOrBuilder> 
           getValuesOrBuilderList() {
        if (valuesBuilder_ != null) {
          return valuesBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(values_);
        }
      }
      /**
       * <pre>
       * Array of values. The array may be empty (contain 0 elements).
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.AnyValue values = 1;</code>
       */
      public opentelemetry.proto.mmap.v1.Mmap.AnyValue.Builder addValuesBuilder() {
        return internalGetValuesFieldBuilder().addBuilder(
            opentelemetry.proto.mmap.v1.Mmap.AnyValue.getDefaultInstance());
      }
      /**
       * <pre>
       * Array of values. The array may be empty (contain 0 elements).
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.AnyValue values = 1;</code>
       */
      public opentelemetry.proto.mmap.v1.Mmap.AnyValue.Builder addValuesBuilder(
          int index) {
        return internalGetValuesFieldBuilder().addBuilder(
            index, opentelemetry.proto.mmap.v1.Mmap.AnyValue.getDefaultInstance());
      }
      /**
       * <pre>
       * Array of values. The array may be empty (contain 0 elements).
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.AnyValue values = 1;</code>
       */
      public java.util.List<opentelemetry.proto.mmap.v1.Mmap.AnyValue.Builder> 
           getValuesBuilderList() {
        return internalGetValuesFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          opentelemetry.proto.mmap.v1.Mmap.AnyValue, opentelemetry.proto.mmap.v1.Mmap.AnyValue.Builder, opentelemetry.proto.mmap.v1.Mmap.AnyValueOrBuilder> 
          internalGetValuesFieldBuilder() {
        if (valuesBuilder_ == null) {
          valuesBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              opentelemetry.proto.mmap.v1.Mmap.AnyValue, opentelemetry.proto.mmap.v1.Mmap.AnyValue.Builder, opentelemetry.proto.mmap.v1.Mmap.AnyValueOrBuilder>(
                  values_,
                  ((bitField0_ & 0x00000001) != 0),
                  getParentForChildren(),
                  isClean());
          values_ = null;
        }
        return valuesBuilder_;
      }

      // @@protoc_insertion_point(builder_scope:opentelemetry.proto.mmap.v1.ArrayValue)
    }

    // @@protoc_insertion_point(class_scope:opentelemetry.proto.mmap.v1.ArrayValue)
    private static final opentelemetry.proto.mmap.v1.Mmap.ArrayValue DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new opentelemetry.proto.mmap.v1.Mmap.ArrayValue();
    }

    public static opentelemetry.proto.mmap.v1.Mmap.ArrayValue getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ArrayValue>
        PARSER = new com.google.protobuf.AbstractParser<ArrayValue>() {
      @java.lang.Override
      public ArrayValue parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<ArrayValue> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ArrayValue> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public opentelemetry.proto.mmap.v1.Mmap.ArrayValue getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface KeyValueListOrBuilder extends
      // @@protoc_insertion_point(interface_extends:opentelemetry.proto.mmap.v1.KeyValueList)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * A collection of key/value pairs of key-value pairs. The list may be empty (may
     * contain 0 elements).
     * The keys MUST be unique (it is not allowed to have more than one
     * value with the same key).
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef values = 1;</code>
     */
    java.util.List<opentelemetry.proto.mmap.v1.Mmap.KeyValueRef> 
        getValuesList();
    /**
     * <pre>
     * A collection of key/value pairs of key-value pairs. The list may be empty (may
     * contain 0 elements).
     * The keys MUST be unique (it is not allowed to have more than one
     * value with the same key).
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef values = 1;</code>
     */
    opentelemetry.proto.mmap.v1.Mmap.KeyValueRef getValues(int index);
    /**
     * <pre>
     * A collection of key/value pairs of key-value pairs. The list may be empty (may
     * contain 0 elements).
     * The keys MUST be unique (it is not allowed to have more than one
     * value with the same key).
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef values = 1;</code>
     */
    int getValuesCount();
    /**
     * <pre>
     * A collection of key/value pairs of key-value pairs. The list may be empty (may
     * contain 0 elements).
     * The keys MUST be unique (it is not allowed to have more than one
     * value with the same key).
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef values = 1;</code>
     */
    java.util.List<? extends opentelemetry.proto.mmap.v1.Mmap.KeyValueRefOrBuilder> 
        getValuesOrBuilderList();
    /**
     * <pre>
     * A collection of key/value pairs of key-value pairs. The list may be empty (may
     * contain 0 elements).
     * The keys MUST be unique (it is not allowed to have more than one
     * value with the same key).
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef values = 1;</code>
     */
    opentelemetry.proto.mmap.v1.Mmap.KeyValueRefOrBuilder getValuesOrBuilder(
        int index);
  }
  /**
   * <pre>
   * KeyValueList is a list of KeyValue messages. We need KeyValueList as a message
   * since `oneof` in AnyValue does not allow repeated fields. Everywhere else where we need
   * a list of KeyValue messages (e.g. in Span) we use `repeated KeyValue` directly to
   * avoid unnecessary extra wrapping (which slows down the protocol). The 2 approaches
   * are semantically equivalent.
   * </pre>
   *
   * Protobuf type {@code opentelemetry.proto.mmap.v1.KeyValueList}
   */
  public static final class KeyValueList extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:opentelemetry.proto.mmap.v1.KeyValueList)
      KeyValueListOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 33,
        /* patch= */ 0,
        /* suffix= */ "",
        "KeyValueList");
    }
    // Use KeyValueList.newBuilder() to construct.
    private KeyValueList(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private KeyValueList() {
      values_ = java.util.Collections.emptyList();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_KeyValueList_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_KeyValueList_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              opentelemetry.proto.mmap.v1.Mmap.KeyValueList.class, opentelemetry.proto.mmap.v1.Mmap.KeyValueList.Builder.class);
    }

    public static final int VALUES_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private java.util.List<opentelemetry.proto.mmap.v1.Mmap.KeyValueRef> values_;
    /**
     * <pre>
     * A collection of key/value pairs of key-value pairs. The list may be empty (may
     * contain 0 elements).
     * The keys MUST be unique (it is not allowed to have more than one
     * value with the same key).
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef values = 1;</code>
     */
    @java.lang.Override
    public java.util.List<opentelemetry.proto.mmap.v1.Mmap.KeyValueRef> getValuesList() {
      return values_;
    }
    /**
     * <pre>
     * A collection of key/value pairs of key-value pairs. The list may be empty (may
     * contain 0 elements).
     * The keys MUST be unique (it is not allowed to have more than one
     * value with the same key).
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef values = 1;</code>
     */
    @java.lang.Override
    public java.util.List<? extends opentelemetry.proto.mmap.v1.Mmap.KeyValueRefOrBuilder> 
        getValuesOrBuilderList() {
      return values_;
    }
    /**
     * <pre>
     * A collection of key/value pairs of key-value pairs. The list may be empty (may
     * contain 0 elements).
     * The keys MUST be unique (it is not allowed to have more than one
     * value with the same key).
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef values = 1;</code>
     */
    @java.lang.Override
    public int getValuesCount() {
      return values_.size();
    }
    /**
     * <pre>
     * A collection of key/value pairs of key-value pairs. The list may be empty (may
     * contain 0 elements).
     * The keys MUST be unique (it is not allowed to have more than one
     * value with the same key).
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef values = 1;</code>
     */
    @java.lang.Override
    public opentelemetry.proto.mmap.v1.Mmap.KeyValueRef getValues(int index) {
      return values_.get(index);
    }
    /**
     * <pre>
     * A collection of key/value pairs of key-value pairs. The list may be empty (may
     * contain 0 elements).
     * The keys MUST be unique (it is not allowed to have more than one
     * value with the same key).
     * </pre>
     *
     * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef values = 1;</code>
     */
    @java.lang.Override
    public opentelemetry.proto.mmap.v1.Mmap.KeyValueRefOrBuilder getValuesOrBuilder(
        int index) {
      return values_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      for (int i = 0; i < values_.size(); i++) {
        output.writeMessage(1, values_.get(i));
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      for (int i = 0; i < values_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, values_.get(i));
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof opentelemetry.proto.mmap.v1.Mmap.KeyValueList)) {
        return super.equals(obj);
      }
      opentelemetry.proto.mmap.v1.Mmap.KeyValueList other = (opentelemetry.proto.mmap.v1.Mmap.KeyValueList) obj;

      if (!getValuesList()
          .equals(other.getValuesList())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getValuesCount() > 0) {
        hash = (37 * hash) + VALUES_FIELD_NUMBER;
        hash = (53 * hash) + getValuesList().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static opentelemetry.proto.mmap.v1.Mmap.KeyValueList parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.KeyValueList parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.KeyValueList parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.KeyValueList parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.KeyValueList parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.KeyValueList parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.KeyValueList parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.KeyValueList parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static opentelemetry.proto.mmap.v1.Mmap.KeyValueList parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static opentelemetry.proto.mmap.v1.Mmap.KeyValueList parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.KeyValueList parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.KeyValueList parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(opentelemetry.proto.mmap.v1.Mmap.KeyValueList prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * KeyValueList is a list of KeyValue messages. We need KeyValueList as a message
     * since `oneof` in AnyValue does not allow repeated fields. Everywhere else where we need
     * a list of KeyValue messages (e.g. in Span) we use `repeated KeyValue` directly to
     * avoid unnecessary extra wrapping (which slows down the protocol). The 2 approaches
     * are semantically equivalent.
     * </pre>
     *
     * Protobuf type {@code opentelemetry.proto.mmap.v1.KeyValueList}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:opentelemetry.proto.mmap.v1.KeyValueList)
        opentelemetry.proto.mmap.v1.Mmap.KeyValueListOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_KeyValueList_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_KeyValueList_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                opentelemetry.proto.mmap.v1.Mmap.KeyValueList.class, opentelemetry.proto.mmap.v1.Mmap.KeyValueList.Builder.class);
      }

      // Construct using opentelemetry.proto.mmap.v1.Mmap.KeyValueList.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        if (valuesBuilder_ == null) {
          values_ = java.util.Collections.emptyList();
        } else {
          values_ = null;
          valuesBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_KeyValueList_descriptor;
      }

      @java.lang.Override
      public opentelemetry.proto.mmap.v1.Mmap.KeyValueList getDefaultInstanceForType() {
        return opentelemetry.proto.mmap.v1.Mmap.KeyValueList.getDefaultInstance();
      }

      @java.lang.Override
      public opentelemetry.proto.mmap.v1.Mmap.KeyValueList build() {
        opentelemetry.proto.mmap.v1.Mmap.KeyValueList result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public opentelemetry.proto.mmap.v1.Mmap.KeyValueList buildPartial() {
        opentelemetry.proto.mmap.v1.Mmap.KeyValueList result = new opentelemetry.proto.mmap.v1.Mmap.KeyValueList(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(opentelemetry.proto.mmap.v1.Mmap.KeyValueList result) {
        if (valuesBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0)) {
            values_ = java.util.Collections.unmodifiableList(values_);
            bitField0_ = (bitField0_ & ~0x00000001);
          }
          result.values_ = values_;
        } else {
          result.values_ = valuesBuilder_.build();
        }
      }

      private void buildPartial0(opentelemetry.proto.mmap.v1.Mmap.KeyValueList result) {
        int from_bitField0_ = bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof opentelemetry.proto.mmap.v1.Mmap.KeyValueList) {
          return mergeFrom((opentelemetry.proto.mmap.v1.Mmap.KeyValueList)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(opentelemetry.proto.mmap.v1.Mmap.KeyValueList other) {
        if (other == opentelemetry.proto.mmap.v1.Mmap.KeyValueList.getDefaultInstance()) return this;
        if (valuesBuilder_ == null) {
          if (!other.values_.isEmpty()) {
            if (values_.isEmpty()) {
              values_ = other.values_;
              bitField0_ = (bitField0_ & ~0x00000001);
            } else {
              ensureValuesIsMutable();
              values_.addAll(other.values_);
            }
            onChanged();
          }
        } else {
          if (!other.values_.isEmpty()) {
            if (valuesBuilder_.isEmpty()) {
              valuesBuilder_.dispose();
              valuesBuilder_ = null;
              values_ = other.values_;
              bitField0_ = (bitField0_ & ~0x00000001);
              valuesBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   internalGetValuesFieldBuilder() : null;
            } else {
              valuesBuilder_.addAllMessages(other.values_);
            }
          }
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                opentelemetry.proto.mmap.v1.Mmap.KeyValueRef m =
                    input.readMessage(
                        opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.parser(),
                        extensionRegistry);
                if (valuesBuilder_ == null) {
                  ensureValuesIsMutable();
                  values_.add(m);
                } else {
                  valuesBuilder_.addMessage(m);
                }
                break;
              } // case 10
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.util.List<opentelemetry.proto.mmap.v1.Mmap.KeyValueRef> values_ =
        java.util.Collections.emptyList();
      private void ensureValuesIsMutable() {
        if (!((bitField0_ & 0x00000001) != 0)) {
          values_ = new java.util.ArrayList<opentelemetry.proto.mmap.v1.Mmap.KeyValueRef>(values_);
          bitField0_ |= 0x00000001;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          opentelemetry.proto.mmap.v1.Mmap.KeyValueRef, opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.Builder, opentelemetry.proto.mmap.v1.Mmap.KeyValueRefOrBuilder> valuesBuilder_;

      /**
       * <pre>
       * A collection of key/value pairs of key-value pairs. The list may be empty (may
       * contain 0 elements).
       * The keys MUST be unique (it is not allowed to have more than one
       * value with the same key).
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef values = 1;</code>
       */
      public java.util.List<opentelemetry.proto.mmap.v1.Mmap.KeyValueRef> getValuesList() {
        if (valuesBuilder_ == null) {
          return java.util.Collections.unmodifiableList(values_);
        } else {
          return valuesBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * A collection of key/value pairs of key-value pairs. The list may be empty (may
       * contain 0 elements).
       * The keys MUST be unique (it is not allowed to have more than one
       * value with the same key).
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef values = 1;</code>
       */
      public int getValuesCount() {
        if (valuesBuilder_ == null) {
          return values_.size();
        } else {
          return valuesBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * A collection of key/value pairs of key-value pairs. The list may be empty (may
       * contain 0 elements).
       * The keys MUST be unique (it is not allowed to have more than one
       * value with the same key).
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef values = 1;</code>
       */
      public opentelemetry.proto.mmap.v1.Mmap.KeyValueRef getValues(int index) {
        if (valuesBuilder_ == null) {
          return values_.get(index);
        } else {
          return valuesBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * A collection of key/value pairs of key-value pairs. The list may be empty (may
       * contain 0 elements).
       * The keys MUST be unique (it is not allowed to have more than one
       * value with the same key).
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef values = 1;</code>
       */
      public Builder setValues(
          int index, opentelemetry.proto.mmap.v1.Mmap.KeyValueRef value) {
        if (valuesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureValuesIsMutable();
          values_.set(index, value);
          onChanged();
        } else {
          valuesBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * A collection of key/value pairs of key-value pairs. The list may be empty (may
       * contain 0 elements).
       * The keys MUST be unique (it is not allowed to have more than one
       * value with the same key).
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef values = 1;</code>
       */
      public Builder setValues(
          int index, opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.Builder builderForValue) {
        if (valuesBuilder_ == null) {
          ensureValuesIsMutable();
          values_.set(index, builderForValue.build());
          onChanged();
        } else {
          valuesBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * A collection of key/value pairs of key-value pairs. The list may be empty (may
       * contain 0 elements).
       * The keys MUST be unique (it is not allowed to have more than one
       * value with the same key).
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef values = 1;</code>
       */
      public Builder addValues(opentelemetry.proto.mmap.v1.Mmap.KeyValueRef value) {
        if (valuesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureValuesIsMutable();
          values_.add(value);
          onChanged();
        } else {
          valuesBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * A collection of key/value pairs of key-value pairs. The list may be empty (may
       * contain 0 elements).
       * The keys MUST be unique (it is not allowed to have more than one
       * value with the same key).
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef values = 1;</code>
       */
      public Builder addValues(
          int index, opentelemetry.proto.mmap.v1.Mmap.KeyValueRef value) {
        if (valuesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureValuesIsMutable();
          values_.add(index, value);
          onChanged();
        } else {
          valuesBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * A collection of key/value pairs of key-value pairs. The list may be empty (may
       * contain 0 elements).
       * The keys MUST be unique (it is not allowed to have more than one
       * value with the same key).
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef values = 1;</code>
       */
      public Builder addValues(
          opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.Builder builderForValue) {
        if (valuesBuilder_ == null) {
          ensureValuesIsMutable();
          values_.add(builderForValue.build());
          onChanged();
        } else {
          valuesBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * A collection of key/value pairs of key-value pairs. The list may be empty (may
       * contain 0 elements).
       * The keys MUST be unique (it is not allowed to have more than one
       * value with the same key).
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef values = 1;</code>
       */
      public Builder addValues(
          int index, opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.Builder builderForValue) {
        if (valuesBuilder_ == null) {
          ensureValuesIsMutable();
          values_.add(index, builderForValue.build());
          onChanged();
        } else {
          valuesBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * A collection of key/value pairs of key-value pairs. The list may be empty (may
       * contain 0 elements).
       * The keys MUST be unique (it is not allowed to have more than one
       * value with the same key).
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef values = 1;</code>
       */
      public Builder addAllValues(
          java.lang.Iterable<? extends opentelemetry.proto.mmap.v1.Mmap.KeyValueRef> values) {
        if (valuesBuilder_ == null) {
          ensureValuesIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, values_);
          onChanged();
        } else {
          valuesBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * A collection of key/value pairs of key-value pairs. The list may be empty (may
       * contain 0 elements).
       * The keys MUST be unique (it is not allowed to have more than one
       * value with the same key).
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef values = 1;</code>
       */
      public Builder clearValues() {
        if (valuesBuilder_ == null) {
          values_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
          onChanged();
        } else {
          valuesBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * A collection of key/value pairs of key-value pairs. The list may be empty (may
       * contain 0 elements).
       * The keys MUST be unique (it is not allowed to have more than one
       * value with the same key).
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef values = 1;</code>
       */
      public Builder removeValues(int index) {
        if (valuesBuilder_ == null) {
          ensureValuesIsMutable();
          values_.remove(index);
          onChanged();
        } else {
          valuesBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * A collection of key/value pairs of key-value pairs. The list may be empty (may
       * contain 0 elements).
       * The keys MUST be unique (it is not allowed to have more than one
       * value with the same key).
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef values = 1;</code>
       */
      public opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.Builder getValuesBuilder(
          int index) {
        return internalGetValuesFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * A collection of key/value pairs of key-value pairs. The list may be empty (may
       * contain 0 elements).
       * The keys MUST be unique (it is not allowed to have more than one
       * value with the same key).
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef values = 1;</code>
       */
      public opentelemetry.proto.mmap.v1.Mmap.KeyValueRefOrBuilder getValuesOrBuilder(
          int index) {
        if (valuesBuilder_ == null) {
          return values_.get(index);  } else {
          return valuesBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * A collection of key/value pairs of key-value pairs. The list may be empty (may
       * contain 0 elements).
       * The keys MUST be unique (it is not allowed to have more than one
       * value with the same key).
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef values = 1;</code>
       */
      public java.util.List<? extends opentelemetry.proto.mmap.v1.Mmap.KeyValueRefOrBuilder> 
           getValuesOrBuilderList() {
        if (valuesBuilder_ != null) {
          return valuesBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(values_);
        }
      }
      /**
       * <pre>
       * A collection of key/value pairs of key-value pairs. The list may be empty (may
       * contain 0 elements).
       * The keys MUST be unique (it is not allowed to have more than one
       * value with the same key).
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef values = 1;</code>
       */
      public opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.Builder addValuesBuilder() {
        return internalGetValuesFieldBuilder().addBuilder(
            opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.getDefaultInstance());
      }
      /**
       * <pre>
       * A collection of key/value pairs of key-value pairs. The list may be empty (may
       * contain 0 elements).
       * The keys MUST be unique (it is not allowed to have more than one
       * value with the same key).
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef values = 1;</code>
       */
      public opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.Builder addValuesBuilder(
          int index) {
        return internalGetValuesFieldBuilder().addBuilder(
            index, opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.getDefaultInstance());
      }
      /**
       * <pre>
       * A collection of key/value pairs of key-value pairs. The list may be empty (may
       * contain 0 elements).
       * The keys MUST be unique (it is not allowed to have more than one
       * value with the same key).
       * </pre>
       *
       * <code>repeated .opentelemetry.proto.mmap.v1.KeyValueRef values = 1;</code>
       */
      public java.util.List<opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.Builder> 
           getValuesBuilderList() {
        return internalGetValuesFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          opentelemetry.proto.mmap.v1.Mmap.KeyValueRef, opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.Builder, opentelemetry.proto.mmap.v1.Mmap.KeyValueRefOrBuilder> 
          internalGetValuesFieldBuilder() {
        if (valuesBuilder_ == null) {
          valuesBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              opentelemetry.proto.mmap.v1.Mmap.KeyValueRef, opentelemetry.proto.mmap.v1.Mmap.KeyValueRef.Builder, opentelemetry.proto.mmap.v1.Mmap.KeyValueRefOrBuilder>(
                  values_,
                  ((bitField0_ & 0x00000001) != 0),
                  getParentForChildren(),
                  isClean());
          values_ = null;
        }
        return valuesBuilder_;
      }

      // @@protoc_insertion_point(builder_scope:opentelemetry.proto.mmap.v1.KeyValueList)
    }

    // @@protoc_insertion_point(class_scope:opentelemetry.proto.mmap.v1.KeyValueList)
    private static final opentelemetry.proto.mmap.v1.Mmap.KeyValueList DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new opentelemetry.proto.mmap.v1.Mmap.KeyValueList();
    }

    public static opentelemetry.proto.mmap.v1.Mmap.KeyValueList getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<KeyValueList>
        PARSER = new com.google.protobuf.AbstractParser<KeyValueList>() {
      @java.lang.Override
      public KeyValueList parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<KeyValueList> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<KeyValueList> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public opentelemetry.proto.mmap.v1.Mmap.KeyValueList getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface SpanContextOrBuilder extends
      // @@protoc_insertion_point(interface_extends:opentelemetry.proto.mmap.v1.SpanContext)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * (Optional) Span ID of the exemplar trace.
     * span_id may be missing if the measurement is not recorded inside a trace
     * or if the trace is not sampled.
     * </pre>
     *
     * <code>bytes span_id = 1;</code>
     * @return The spanId.
     */
    com.google.protobuf.ByteString getSpanId();

    /**
     * <pre>
     * (Optional) Trace ID of the exemplar trace.
     * trace_id may be missing if the measurement is not recorded inside a trace
     * or if the trace is not sampled.
     * </pre>
     *
     * <code>bytes trace_id = 2;</code>
     * @return The traceId.
     */
    com.google.protobuf.ByteString getTraceId();

    /**
     * <pre>
     * Span Flags, a bit field.
     *
     * Bits 0-7 (8 least significant bits) are the trace flags as defined in W3C Trace
     * Context specification. To read the 8-bit W3C trace flag, use
     * `flags &amp; SPAN_FLAGS_TRACE_FLAGS_MASK`.
     *
     * See https://www.w3.org/TR/trace-context-2/#trace-flags for the flag definitions.
     *
     * Bits 8 and 9 represent the 3 states of whether a span's parent
     * is remote. The states are (unknown, is not remote, is remote).
     * To read whether the value is known, use `(flags &amp; SPAN_FLAGS_CONTEXT_HAS_IS_REMOTE_MASK) != 0`.
     * To read whether the span is remote, use `(flags &amp; SPAN_FLAGS_CONTEXT_IS_REMOTE_MASK) != 0`.
     *
     * When creating span messages, if the message is logically forwarded from another source
     * with an equivalent flags fields (i.e., usually another OTLP span message), the field SHOULD
     * be copied as-is. If creating from a source that does not have an equivalent flags field
     * (such as a runtime representation of an OpenTelemetry span), the high 22 bits MUST
     * be set to zero.
     * Readers MUST NOT assume that bits 10-31 (22 most significant bits) will be zero.
     *
     * [Optional].
     * </pre>
     *
     * <code>fixed32 flags = 3;</code>
     * @return The flags.
     */
    int getFlags();
  }
  /**
   * <pre>
   * Shared span-context to use between measurements/events
   * </pre>
   *
   * Protobuf type {@code opentelemetry.proto.mmap.v1.SpanContext}
   */
  public static final class SpanContext extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:opentelemetry.proto.mmap.v1.SpanContext)
      SpanContextOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 33,
        /* patch= */ 0,
        /* suffix= */ "",
        "SpanContext");
    }
    // Use SpanContext.newBuilder() to construct.
    private SpanContext(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private SpanContext() {
      spanId_ = com.google.protobuf.ByteString.EMPTY;
      traceId_ = com.google.protobuf.ByteString.EMPTY;
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_SpanContext_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_SpanContext_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              opentelemetry.proto.mmap.v1.Mmap.SpanContext.class, opentelemetry.proto.mmap.v1.Mmap.SpanContext.Builder.class);
    }

    public static final int SPAN_ID_FIELD_NUMBER = 1;
    private com.google.protobuf.ByteString spanId_ = com.google.protobuf.ByteString.EMPTY;
    /**
     * <pre>
     * (Optional) Span ID of the exemplar trace.
     * span_id may be missing if the measurement is not recorded inside a trace
     * or if the trace is not sampled.
     * </pre>
     *
     * <code>bytes span_id = 1;</code>
     * @return The spanId.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getSpanId() {
      return spanId_;
    }

    public static final int TRACE_ID_FIELD_NUMBER = 2;
    private com.google.protobuf.ByteString traceId_ = com.google.protobuf.ByteString.EMPTY;
    /**
     * <pre>
     * (Optional) Trace ID of the exemplar trace.
     * trace_id may be missing if the measurement is not recorded inside a trace
     * or if the trace is not sampled.
     * </pre>
     *
     * <code>bytes trace_id = 2;</code>
     * @return The traceId.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getTraceId() {
      return traceId_;
    }

    public static final int FLAGS_FIELD_NUMBER = 3;
    private int flags_ = 0;
    /**
     * <pre>
     * Span Flags, a bit field.
     *
     * Bits 0-7 (8 least significant bits) are the trace flags as defined in W3C Trace
     * Context specification. To read the 8-bit W3C trace flag, use
     * `flags &amp; SPAN_FLAGS_TRACE_FLAGS_MASK`.
     *
     * See https://www.w3.org/TR/trace-context-2/#trace-flags for the flag definitions.
     *
     * Bits 8 and 9 represent the 3 states of whether a span's parent
     * is remote. The states are (unknown, is not remote, is remote).
     * To read whether the value is known, use `(flags &amp; SPAN_FLAGS_CONTEXT_HAS_IS_REMOTE_MASK) != 0`.
     * To read whether the span is remote, use `(flags &amp; SPAN_FLAGS_CONTEXT_IS_REMOTE_MASK) != 0`.
     *
     * When creating span messages, if the message is logically forwarded from another source
     * with an equivalent flags fields (i.e., usually another OTLP span message), the field SHOULD
     * be copied as-is. If creating from a source that does not have an equivalent flags field
     * (such as a runtime representation of an OpenTelemetry span), the high 22 bits MUST
     * be set to zero.
     * Readers MUST NOT assume that bits 10-31 (22 most significant bits) will be zero.
     *
     * [Optional].
     * </pre>
     *
     * <code>fixed32 flags = 3;</code>
     * @return The flags.
     */
    @java.lang.Override
    public int getFlags() {
      return flags_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!spanId_.isEmpty()) {
        output.writeBytes(1, spanId_);
      }
      if (!traceId_.isEmpty()) {
        output.writeBytes(2, traceId_);
      }
      if (flags_ != 0) {
        output.writeFixed32(3, flags_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!spanId_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(1, spanId_);
      }
      if (!traceId_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(2, traceId_);
      }
      if (flags_ != 0) {
        size += com.google.protobuf.CodedOutputStream
          .computeFixed32Size(3, flags_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof opentelemetry.proto.mmap.v1.Mmap.SpanContext)) {
        return super.equals(obj);
      }
      opentelemetry.proto.mmap.v1.Mmap.SpanContext other = (opentelemetry.proto.mmap.v1.Mmap.SpanContext) obj;

      if (!getSpanId()
          .equals(other.getSpanId())) return false;
      if (!getTraceId()
          .equals(other.getTraceId())) return false;
      if (getFlags()
          != other.getFlags()) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + SPAN_ID_FIELD_NUMBER;
      hash = (53 * hash) + getSpanId().hashCode();
      hash = (37 * hash) + TRACE_ID_FIELD_NUMBER;
      hash = (53 * hash) + getTraceId().hashCode();
      hash = (37 * hash) + FLAGS_FIELD_NUMBER;
      hash = (53 * hash) + getFlags();
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static opentelemetry.proto.mmap.v1.Mmap.SpanContext parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.SpanContext parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.SpanContext parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.SpanContext parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.SpanContext parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.SpanContext parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.SpanContext parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.SpanContext parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static opentelemetry.proto.mmap.v1.Mmap.SpanContext parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static opentelemetry.proto.mmap.v1.Mmap.SpanContext parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.SpanContext parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static opentelemetry.proto.mmap.v1.Mmap.SpanContext parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(opentelemetry.proto.mmap.v1.Mmap.SpanContext prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Shared span-context to use between measurements/events
     * </pre>
     *
     * Protobuf type {@code opentelemetry.proto.mmap.v1.SpanContext}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:opentelemetry.proto.mmap.v1.SpanContext)
        opentelemetry.proto.mmap.v1.Mmap.SpanContextOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_SpanContext_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_SpanContext_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                opentelemetry.proto.mmap.v1.Mmap.SpanContext.class, opentelemetry.proto.mmap.v1.Mmap.SpanContext.Builder.class);
      }

      // Construct using opentelemetry.proto.mmap.v1.Mmap.SpanContext.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        spanId_ = com.google.protobuf.ByteString.EMPTY;
        traceId_ = com.google.protobuf.ByteString.EMPTY;
        flags_ = 0;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return opentelemetry.proto.mmap.v1.Mmap.internal_static_opentelemetry_proto_mmap_v1_SpanContext_descriptor;
      }

      @java.lang.Override
      public opentelemetry.proto.mmap.v1.Mmap.SpanContext getDefaultInstanceForType() {
        return opentelemetry.proto.mmap.v1.Mmap.SpanContext.getDefaultInstance();
      }

      @java.lang.Override
      public opentelemetry.proto.mmap.v1.Mmap.SpanContext build() {
        opentelemetry.proto.mmap.v1.Mmap.SpanContext result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public opentelemetry.proto.mmap.v1.Mmap.SpanContext buildPartial() {
        opentelemetry.proto.mmap.v1.Mmap.SpanContext result = new opentelemetry.proto.mmap.v1.Mmap.SpanContext(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(opentelemetry.proto.mmap.v1.Mmap.SpanContext result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.spanId_ = spanId_;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.traceId_ = traceId_;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.flags_ = flags_;
        }
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof opentelemetry.proto.mmap.v1.Mmap.SpanContext) {
          return mergeFrom((opentelemetry.proto.mmap.v1.Mmap.SpanContext)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(opentelemetry.proto.mmap.v1.Mmap.SpanContext other) {
        if (other == opentelemetry.proto.mmap.v1.Mmap.SpanContext.getDefaultInstance()) return this;
        if (!other.getSpanId().isEmpty()) {
          setSpanId(other.getSpanId());
        }
        if (!other.getTraceId().isEmpty()) {
          setTraceId(other.getTraceId());
        }
        if (other.getFlags() != 0) {
          setFlags(other.getFlags());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                spanId_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                traceId_ = input.readBytes();
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              case 29: {
                flags_ = input.readFixed32();
                bitField0_ |= 0x00000004;
                break;
              } // case 29
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private com.google.protobuf.ByteString spanId_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       * (Optional) Span ID of the exemplar trace.
       * span_id may be missing if the measurement is not recorded inside a trace
       * or if the trace is not sampled.
       * </pre>
       *
       * <code>bytes span_id = 1;</code>
       * @return The spanId.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getSpanId() {
        return spanId_;
      }
      /**
       * <pre>
       * (Optional) Span ID of the exemplar trace.
       * span_id may be missing if the measurement is not recorded inside a trace
       * or if the trace is not sampled.
       * </pre>
       *
       * <code>bytes span_id = 1;</code>
       * @param value The spanId to set.
       * @return This builder for chaining.
       */
      public Builder setSpanId(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        spanId_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * (Optional) Span ID of the exemplar trace.
       * span_id may be missing if the measurement is not recorded inside a trace
       * or if the trace is not sampled.
       * </pre>
       *
       * <code>bytes span_id = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearSpanId() {
        bitField0_ = (bitField0_ & ~0x00000001);
        spanId_ = getDefaultInstance().getSpanId();
        onChanged();
        return this;
      }

      private com.google.protobuf.ByteString traceId_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       * (Optional) Trace ID of the exemplar trace.
       * trace_id may be missing if the measurement is not recorded inside a trace
       * or if the trace is not sampled.
       * </pre>
       *
       * <code>bytes trace_id = 2;</code>
       * @return The traceId.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getTraceId() {
        return traceId_;
      }
      /**
       * <pre>
       * (Optional) Trace ID of the exemplar trace.
       * trace_id may be missing if the measurement is not recorded inside a trace
       * or if the trace is not sampled.
       * </pre>
       *
       * <code>bytes trace_id = 2;</code>
       * @param value The traceId to set.
       * @return This builder for chaining.
       */
      public Builder setTraceId(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        traceId_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * (Optional) Trace ID of the exemplar trace.
       * trace_id may be missing if the measurement is not recorded inside a trace
       * or if the trace is not sampled.
       * </pre>
       *
       * <code>bytes trace_id = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearTraceId() {
        bitField0_ = (bitField0_ & ~0x00000002);
        traceId_ = getDefaultInstance().getTraceId();
        onChanged();
        return this;
      }

      private int flags_ ;
      /**
       * <pre>
       * Span Flags, a bit field.
       *
       * Bits 0-7 (8 least significant bits) are the trace flags as defined in W3C Trace
       * Context specification. To read the 8-bit W3C trace flag, use
       * `flags &amp; SPAN_FLAGS_TRACE_FLAGS_MASK`.
       *
       * See https://www.w3.org/TR/trace-context-2/#trace-flags for the flag definitions.
       *
       * Bits 8 and 9 represent the 3 states of whether a span's parent
       * is remote. The states are (unknown, is not remote, is remote).
       * To read whether the value is known, use `(flags &amp; SPAN_FLAGS_CONTEXT_HAS_IS_REMOTE_MASK) != 0`.
       * To read whether the span is remote, use `(flags &amp; SPAN_FLAGS_CONTEXT_IS_REMOTE_MASK) != 0`.
       *
       * When creating span messages, if the message is logically forwarded from another source
       * with an equivalent flags fields (i.e., usually another OTLP span message), the field SHOULD
       * be copied as-is. If creating from a source that does not have an equivalent flags field
       * (such as a runtime representation of an OpenTelemetry span), the high 22 bits MUST
       * be set to zero.
       * Readers MUST NOT assume that bits 10-31 (22 most significant bits) will be zero.
       *
       * [Optional].
       * </pre>
       *
       * <code>fixed32 flags = 3;</code>
       * @return The flags.
       */
      @java.lang.Override
      public int getFlags() {
        return flags_;
      }
      /**
       * <pre>
       * Span Flags, a bit field.
       *
       * Bits 0-7 (8 least significant bits) are the trace flags as defined in W3C Trace
       * Context specification. To read the 8-bit W3C trace flag, use
       * `flags &amp; SPAN_FLAGS_TRACE_FLAGS_MASK`.
       *
       * See https://www.w3.org/TR/trace-context-2/#trace-flags for the flag definitions.
       *
       * Bits 8 and 9 represent the 3 states of whether a span's parent
       * is remote. The states are (unknown, is not remote, is remote).
       * To read whether the value is known, use `(flags &amp; SPAN_FLAGS_CONTEXT_HAS_IS_REMOTE_MASK) != 0`.
       * To read whether the span is remote, use `(flags &amp; SPAN_FLAGS_CONTEXT_IS_REMOTE_MASK) != 0`.
       *
       * When creating span messages, if the message is logically forwarded from another source
       * with an equivalent flags fields (i.e., usually another OTLP span message), the field SHOULD
       * be copied as-is. If creating from a source that does not have an equivalent flags field
       * (such as a runtime representation of an OpenTelemetry span), the high 22 bits MUST
       * be set to zero.
       * Readers MUST NOT assume that bits 10-31 (22 most significant bits) will be zero.
       *
       * [Optional].
       * </pre>
       *
       * <code>fixed32 flags = 3;</code>
       * @param value The flags to set.
       * @return This builder for chaining.
       */
      public Builder setFlags(int value) {

        flags_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Span Flags, a bit field.
       *
       * Bits 0-7 (8 least significant bits) are the trace flags as defined in W3C Trace
       * Context specification. To read the 8-bit W3C trace flag, use
       * `flags &amp; SPAN_FLAGS_TRACE_FLAGS_MASK`.
       *
       * See https://www.w3.org/TR/trace-context-2/#trace-flags for the flag definitions.
       *
       * Bits 8 and 9 represent the 3 states of whether a span's parent
       * is remote. The states are (unknown, is not remote, is remote).
       * To read whether the value is known, use `(flags &amp; SPAN_FLAGS_CONTEXT_HAS_IS_REMOTE_MASK) != 0`.
       * To read whether the span is remote, use `(flags &amp; SPAN_FLAGS_CONTEXT_IS_REMOTE_MASK) != 0`.
       *
       * When creating span messages, if the message is logically forwarded from another source
       * with an equivalent flags fields (i.e., usually another OTLP span message), the field SHOULD
       * be copied as-is. If creating from a source that does not have an equivalent flags field
       * (such as a runtime representation of an OpenTelemetry span), the high 22 bits MUST
       * be set to zero.
       * Readers MUST NOT assume that bits 10-31 (22 most significant bits) will be zero.
       *
       * [Optional].
       * </pre>
       *
       * <code>fixed32 flags = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearFlags() {
        bitField0_ = (bitField0_ & ~0x00000004);
        flags_ = 0;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:opentelemetry.proto.mmap.v1.SpanContext)
    }

    // @@protoc_insertion_point(class_scope:opentelemetry.proto.mmap.v1.SpanContext)
    private static final opentelemetry.proto.mmap.v1.Mmap.SpanContext DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new opentelemetry.proto.mmap.v1.Mmap.SpanContext();
    }

    public static opentelemetry.proto.mmap.v1.Mmap.SpanContext getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<SpanContext>
        PARSER = new com.google.protobuf.AbstractParser<SpanContext>() {
      @java.lang.Override
      public SpanContext parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<SpanContext> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<SpanContext> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public opentelemetry.proto.mmap.v1.Mmap.SpanContext getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_opentelemetry_proto_mmap_v1_SpanEvent_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_opentelemetry_proto_mmap_v1_SpanEvent_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_opentelemetry_proto_mmap_v1_SpanEvent_StartSpan_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_opentelemetry_proto_mmap_v1_SpanEvent_StartSpan_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_opentelemetry_proto_mmap_v1_SpanEvent_EndSpan_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_opentelemetry_proto_mmap_v1_SpanEvent_EndSpan_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_opentelemetry_proto_mmap_v1_SpanEvent_ChangeSpanName_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_opentelemetry_proto_mmap_v1_SpanEvent_ChangeSpanName_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_opentelemetry_proto_mmap_v1_SpanEvent_UpdateAttributes_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_opentelemetry_proto_mmap_v1_SpanEvent_UpdateAttributes_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_opentelemetry_proto_mmap_v1_SpanEvent_AddLink_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_opentelemetry_proto_mmap_v1_SpanEvent_AddLink_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_opentelemetry_proto_mmap_v1_SpanEvent_AddLink_Link_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_opentelemetry_proto_mmap_v1_SpanEvent_AddLink_Link_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_opentelemetry_proto_mmap_v1_Status_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_opentelemetry_proto_mmap_v1_Status_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_opentelemetry_proto_mmap_v1_Measurement_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_opentelemetry_proto_mmap_v1_Measurement_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_opentelemetry_proto_mmap_v1_MetricRef_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_opentelemetry_proto_mmap_v1_MetricRef_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_opentelemetry_proto_mmap_v1_MetricRef_Gauge_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_opentelemetry_proto_mmap_v1_MetricRef_Gauge_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_opentelemetry_proto_mmap_v1_MetricRef_Sum_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_opentelemetry_proto_mmap_v1_MetricRef_Sum_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_opentelemetry_proto_mmap_v1_MetricRef_Histogram_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_opentelemetry_proto_mmap_v1_MetricRef_Histogram_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_opentelemetry_proto_mmap_v1_MetricRef_ExponentialHistogram_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_opentelemetry_proto_mmap_v1_MetricRef_ExponentialHistogram_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_opentelemetry_proto_mmap_v1_Event_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_opentelemetry_proto_mmap_v1_Event_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_opentelemetry_proto_mmap_v1_Resource_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_opentelemetry_proto_mmap_v1_Resource_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_opentelemetry_proto_mmap_v1_InstrumentationScope_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_opentelemetry_proto_mmap_v1_InstrumentationScope_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_opentelemetry_proto_mmap_v1_KeyValueRef_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_opentelemetry_proto_mmap_v1_KeyValueRef_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_opentelemetry_proto_mmap_v1_AnyValue_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_opentelemetry_proto_mmap_v1_AnyValue_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_opentelemetry_proto_mmap_v1_ArrayValue_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_opentelemetry_proto_mmap_v1_ArrayValue_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_opentelemetry_proto_mmap_v1_KeyValueList_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_opentelemetry_proto_mmap_v1_KeyValueList_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_opentelemetry_proto_mmap_v1_SpanContext_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_opentelemetry_proto_mmap_v1_SpanContext_fieldAccessorTable;

  public static com.google.protobuf.Descriptors.FileDescriptor
      getDescriptor() {
    return descriptor;
  }
  private static  com.google.protobuf.Descriptors.FileDescriptor
      descriptor;
  static {
    java.lang.String[] descriptorData = {
      "\n\nmmap.proto\022\033opentelemetry.proto.mmap.v" +
      "1\"\364\t\n\tSpanEvent\022\021\n\tscope_ref\030\024 \001(\003\022\020\n\010tr" +
      "ace_id\030\001 \001(\014\022\017\n\007span_id\030\002 \001(\014\022A\n\005start\030\013" +
      " \001(\01320.opentelemetry.proto.mmap.v1.SpanE" +
      "vent.StartSpanH\000\022=\n\003end\030\014 \001(\0132..opentele" +
      "metry.proto.mmap.v1.SpanEvent.EndSpanH\000\022" +
      "E\n\004name\030\r \001(\01325.opentelemetry.proto.mmap" +
      ".v1.SpanEvent.ChangeSpanNameH\000\022M\n\nattrib" +
      "utes\030\016 \001(\01327.opentelemetry.proto.mmap.v1" +
      ".SpanEvent.UpdateAttributesH\000\022>\n\004link\030\017 " +
      "\001(\0132..opentelemetry.proto.mmap.v1.SpanEv" +
      "ent.AddLinkH\000\032\201\003\n\tStartSpan\022\026\n\016parent_sp" +
      "an_id\030\004 \001(\014\022\r\n\005flags\030\020 \001(\007\022\014\n\004name\030\005 \001(\t" +
      "\022G\n\004kind\030\006 \001(\01629.opentelemetry.proto.mma" +
      "p.v1.SpanEvent.StartSpan.SpanKind\022\034\n\024sta" +
      "rt_time_unix_nano\030\007 \001(\006\022<\n\nattributes\030\t " +
      "\003(\0132(.opentelemetry.proto.mmap.v1.KeyVal" +
      "ueRef\"\231\001\n\010SpanKind\022\031\n\025SPAN_KIND_UNSPECIF" +
      "IED\020\000\022\026\n\022SPAN_KIND_INTERNAL\020\001\022\024\n\020SPAN_KI" +
      "ND_SERVER\020\002\022\024\n\020SPAN_KIND_CLIENT\020\003\022\026\n\022SPA" +
      "N_KIND_PRODUCER\020\004\022\026\n\022SPAN_KIND_CONSUMER\020" +
      "\005\032Z\n\007EndSpan\022\032\n\022end_time_unix_nano\030\010 \001(\006" +
      "\0223\n\006status\030\017 \001(\0132#.opentelemetry.proto.m" +
      "map.v1.Status\032\036\n\016ChangeSpanName\022\014\n\004name\030" +
      "\005 \001(\t\032P\n\020UpdateAttributes\022<\n\nattributes\030" +
      "\t \003(\0132(.opentelemetry.proto.mmap.v1.KeyV" +
      "alueRef\032\375\001\n\007AddLink\022B\n\005links\030\r \003(\01323.ope" +
      "ntelemetry.proto.mmap.v1.SpanEvent.AddLi" +
      "nk.Link\032\255\001\n\004Link\022\020\n\010trace_id\030\001 \001(\014\022\017\n\007sp" +
      "an_id\030\002 \001(\014\022\023\n\013trace_state\030\003 \001(\t\022<\n\nattr" +
      "ibutes\030\004 \003(\0132(.opentelemetry.proto.mmap." +
      "v1.KeyValueRef\022 \n\030dropped_attributes_cou" +
      "nt\030\005 \001(\r\022\r\n\005flags\030\006 \001(\007B\007\n\005event\"\255\001\n\006Sta" +
      "tus\022\017\n\007message\030\002 \001(\t\022<\n\004code\030\003 \001(\0162..ope" +
      "ntelemetry.proto.mmap.v1.Status.StatusCo" +
      "de\"N\n\nStatusCode\022\025\n\021STATUS_CODE_UNSET\020\000\022" +
      "\022\n\016STATUS_CODE_OK\020\001\022\025\n\021STATUS_CODE_ERROR" +
      "\020\002J\004\010\001\020\002\"\350\001\n\013Measurement\022\022\n\nmetric_ref\030\001" +
      " \001(\003\022<\n\nattributes\030\002 \003(\0132(.opentelemetry" +
      ".proto.mmap.v1.KeyValueRef\022\026\n\016time_unix_" +
      "nano\030\003 \001(\006\022\021\n\007as_long\030\004 \001(\003H\000\022\023\n\tas_doub" +
      "le\030\005 \001(\001H\000\022>\n\014span_context\030\006 \001(\0132(.opent" +
      "elemetry.proto.mmap.v1.SpanContextB\007\n\005va" +
      "lue\"\220\006\n\tMetricRef\022\014\n\004name\030\001 \001(\t\022\023\n\013descr" +
      "iption\030\002 \001(\t\022\014\n\004unit\030\003 \001(\t\022!\n\031instrument" +
      "ation_scope_ref\030\004 \001(\003\022=\n\005gauge\030\005 \001(\0132,.o" +
      "pentelemetry.proto.mmap.v1.MetricRef.Gau" +
      "geH\000\0229\n\003sum\030\006 \001(\0132*.opentelemetry.proto." +
      "mmap.v1.MetricRef.SumH\000\022E\n\thistogram\030\007 \001" +
      "(\01320.opentelemetry.proto.mmap.v1.MetricR" +
      "ef.HistogramH\000\022O\n\010exp_hist\030\010 \001(\0132;.opent" +
      "elemetry.proto.mmap.v1.MetricRef.Exponen" +
      "tialHistogramH\000\032\007\n\005Gauge\032q\n\003Sum\022T\n\027aggre" +
      "gation_temporality\030\002 \001(\01623.opentelemetry" +
      ".proto.mmap.v1.AggregationTemporality\022\024\n" +
      "\014is_monotonic\030\003 \001(\010\032{\n\tHistogram\022T\n\027aggr" +
      "egation_temporality\030\001 \001(\01623.opentelemetr" +
      "y.proto.mmap.v1.AggregationTemporality\022\030" +
      "\n\020bucket_boundares\030\002 \003(\001\032\224\001\n\024Exponential" +
      "Histogram\022T\n\027aggregation_temporality\030\001 \001" +
      "(\01623.opentelemetry.proto.mmap.v1.Aggrega" +
      "tionTemporality\022\023\n\013max_buckets\030\002 \001(\003\022\021\n\t" +
      "max_scale\030\003 \001(\003B\r\n\013aggregation\"\332\002\n\005Event" +
      "\022\021\n\tscope_ref\030\001 \001(\003\022\026\n\016time_unix_nano\030\002 " +
      "\001(\006\022D\n\017severity_number\030\003 \001(\0162+.opentelem" +
      "etry.proto.mmap.v1.SeverityNumber\022\025\n\rsev" +
      "erity_text\030\004 \001(\t\0223\n\004body\030\005 \001(\0132%.opentel" +
      "emetry.proto.mmap.v1.AnyValue\022\026\n\016event_n" +
      "ame_ref\030\006 \001(\003\022>\n\014span_context\030\007 \001(\0132(.op" +
      "entelemetry.proto.mmap.v1.SpanContext\022<\n" +
      "\nattributes\030\010 \003(\0132(.opentelemetry.proto." +
      "mmap.v1.KeyValueRef\"j\n\010Resource\022<\n\nattri" +
      "butes\030\001 \003(\0132(.opentelemetry.proto.mmap.v" +
      "1.KeyValueRef\022 \n\030dropped_attributes_coun" +
      "t\030\002 \001(\r\"\263\001\n\024InstrumentationScope\022\020\n\010name" +
      "_ref\030\001 \001(\003\022\023\n\013version_ref\030\002 \001(\003\022<\n\nattri" +
      "butes\030\003 \003(\0132(.opentelemetry.proto.mmap.v" +
      "1.KeyValueRef\022 \n\030dropped_attributes_coun" +
      "t\030\004 \001(\r\022\024\n\014resource_ref\030\005 \001(\003\"T\n\013KeyValu" +
      "eRef\022\017\n\007key_ref\030\001 \001(\003\0224\n\005value\030\002 \001(\0132%.o" +
      "pentelemetry.proto.mmap.v1.AnyValue\"\235\002\n\010" +
      "AnyValue\022\026\n\014string_value\030\001 \001(\tH\000\022\024\n\nbool" +
      "_value\030\002 \001(\010H\000\022\023\n\tint_value\030\003 \001(\003H\000\022\026\n\014d" +
      "ouble_value\030\004 \001(\001H\000\022>\n\013array_value\030\005 \001(\013" +
      "2\'.opentelemetry.proto.mmap.v1.ArrayValu" +
      "eH\000\022A\n\014kvlist_value\030\006 \001(\0132).opentelemetr" +
      "y.proto.mmap.v1.KeyValueListH\000\022\025\n\013bytes_" +
      "value\030\007 \001(\014H\000\022\023\n\tvalue_ref\030\010 \001(\003H\000B\007\n\005va" +
      "lue\"C\n\nArrayValue\0225\n\006values\030\001 \003(\0132%.open" +
      "telemetry.proto.mmap.v1.AnyValue\"H\n\014KeyV" +
      "alueList\0228\n\006values\030\001 \003(\0132(.opentelemetry" +
      ".proto.mmap.v1.KeyValueRef\"?\n\013SpanContex" +
      "t\022\017\n\007span_id\030\001 \001(\014\022\020\n\010trace_id\030\002 \001(\014\022\r\n\005" +
      "flags\030\003 \001(\007*\214\001\n\026AggregationTemporality\022\'" +
      "\n#AGGREGATION_TEMPORALITY_UNSPECIFIED\020\000\022" +
      "!\n\035AGGREGATION_TEMPORALITY_DELTA\020\001\022&\n\"AG" +
      "GREGATION_TEMPORALITY_CUMULATIVE\020\002*\303\005\n\016S" +
      "everityNumber\022\037\n\033SEVERITY_NUMBER_UNSPECI" +
      "FIED\020\000\022\031\n\025SEVERITY_NUMBER_TRACE\020\001\022\032\n\026SEV" +
      "ERITY_NUMBER_TRACE2\020\002\022\032\n\026SEVERITY_NUMBER" +
      "_TRACE3\020\003\022\032\n\026SEVERITY_NUMBER_TRACE4\020\004\022\031\n" +
      "\025SEVERITY_NUMBER_DEBUG\020\005\022\032\n\026SEVERITY_NUM" +
      "BER_DEBUG2\020\006\022\032\n\026SEVERITY_NUMBER_DEBUG3\020\007" +
      "\022\032\n\026SEVERITY_NUMBER_DEBUG4\020\010\022\030\n\024SEVERITY" +
      "_NUMBER_INFO\020\t\022\031\n\025SEVERITY_NUMBER_INFO2\020" +
      "\n\022\031\n\025SEVERITY_NUMBER_INFO3\020\013\022\031\n\025SEVERITY" +
      "_NUMBER_INFO4\020\014\022\030\n\024SEVERITY_NUMBER_WARN\020" +
      "\r\022\031\n\025SEVERITY_NUMBER_WARN2\020\016\022\031\n\025SEVERITY" +
      "_NUMBER_WARN3\020\017\022\031\n\025SEVERITY_NUMBER_WARN4" +
      "\020\020\022\031\n\025SEVERITY_NUMBER_ERROR\020\021\022\032\n\026SEVERIT" +
      "Y_NUMBER_ERROR2\020\022\022\032\n\026SEVERITY_NUMBER_ERR" +
      "OR3\020\023\022\032\n\026SEVERITY_NUMBER_ERROR4\020\024\022\031\n\025SEV" +
      "ERITY_NUMBER_FATAL\020\025\022\032\n\026SEVERITY_NUMBER_" +
      "FATAL2\020\026\022\032\n\026SEVERITY_NUMBER_FATAL3\020\027\022\032\n\026" +
      "SEVERITY_NUMBER_FATAL4\020\030b\006proto3"
    };
    descriptor = com.google.protobuf.Descriptors.FileDescriptor
      .internalBuildGeneratedFileFrom(descriptorData,
        new com.google.protobuf.Descriptors.FileDescriptor[] {
        });
    internal_static_opentelemetry_proto_mmap_v1_SpanEvent_descriptor =
      getDescriptor().getMessageType(0);
    internal_static_opentelemetry_proto_mmap_v1_SpanEvent_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_opentelemetry_proto_mmap_v1_SpanEvent_descriptor,
        new java.lang.String[] { "ScopeRef", "TraceId", "SpanId", "Start", "End", "Name", "Attributes", "Link", "Event", });
    internal_static_opentelemetry_proto_mmap_v1_SpanEvent_StartSpan_descriptor =
      internal_static_opentelemetry_proto_mmap_v1_SpanEvent_descriptor.getNestedType(0);
    internal_static_opentelemetry_proto_mmap_v1_SpanEvent_StartSpan_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_opentelemetry_proto_mmap_v1_SpanEvent_StartSpan_descriptor,
        new java.lang.String[] { "ParentSpanId", "Flags", "Name", "Kind", "StartTimeUnixNano", "Attributes", });
    internal_static_opentelemetry_proto_mmap_v1_SpanEvent_EndSpan_descriptor =
      internal_static_opentelemetry_proto_mmap_v1_SpanEvent_descriptor.getNestedType(1);
    internal_static_opentelemetry_proto_mmap_v1_SpanEvent_EndSpan_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_opentelemetry_proto_mmap_v1_SpanEvent_EndSpan_descriptor,
        new java.lang.String[] { "EndTimeUnixNano", "Status", });
    internal_static_opentelemetry_proto_mmap_v1_SpanEvent_ChangeSpanName_descriptor =
      internal_static_opentelemetry_proto_mmap_v1_SpanEvent_descriptor.getNestedType(2);
    internal_static_opentelemetry_proto_mmap_v1_SpanEvent_ChangeSpanName_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_opentelemetry_proto_mmap_v1_SpanEvent_ChangeSpanName_descriptor,
        new java.lang.String[] { "Name", });
    internal_static_opentelemetry_proto_mmap_v1_SpanEvent_UpdateAttributes_descriptor =
      internal_static_opentelemetry_proto_mmap_v1_SpanEvent_descriptor.getNestedType(3);
    internal_static_opentelemetry_proto_mmap_v1_SpanEvent_UpdateAttributes_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_opentelemetry_proto_mmap_v1_SpanEvent_UpdateAttributes_descriptor,
        new java.lang.String[] { "Attributes", });
    internal_static_opentelemetry_proto_mmap_v1_SpanEvent_AddLink_descriptor =
      internal_static_opentelemetry_proto_mmap_v1_SpanEvent_descriptor.getNestedType(4);
    internal_static_opentelemetry_proto_mmap_v1_SpanEvent_AddLink_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_opentelemetry_proto_mmap_v1_SpanEvent_AddLink_descriptor,
        new java.lang.String[] { "Links", });
    internal_static_opentelemetry_proto_mmap_v1_SpanEvent_AddLink_Link_descriptor =
      internal_static_opentelemetry_proto_mmap_v1_SpanEvent_AddLink_descriptor.getNestedType(0);
    internal_static_opentelemetry_proto_mmap_v1_SpanEvent_AddLink_Link_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_opentelemetry_proto_mmap_v1_SpanEvent_AddLink_Link_descriptor,
        new java.lang.String[] { "TraceId", "SpanId", "TraceState", "Attributes", "DroppedAttributesCount", "Flags", });
    internal_static_opentelemetry_proto_mmap_v1_Status_descriptor =
      getDescriptor().getMessageType(1);
    internal_static_opentelemetry_proto_mmap_v1_Status_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_opentelemetry_proto_mmap_v1_Status_descriptor,
        new java.lang.String[] { "Message", "Code", });
    internal_static_opentelemetry_proto_mmap_v1_Measurement_descriptor =
      getDescriptor().getMessageType(2);
    internal_static_opentelemetry_proto_mmap_v1_Measurement_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_opentelemetry_proto_mmap_v1_Measurement_descriptor,
        new java.lang.String[] { "MetricRef", "Attributes", "TimeUnixNano", "AsLong", "AsDouble", "SpanContext", "Value", });
    internal_static_opentelemetry_proto_mmap_v1_MetricRef_descriptor =
      getDescriptor().getMessageType(3);
    internal_static_opentelemetry_proto_mmap_v1_MetricRef_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_opentelemetry_proto_mmap_v1_MetricRef_descriptor,
        new java.lang.String[] { "Name", "Description", "Unit", "InstrumentationScopeRef", "Gauge", "Sum", "Histogram", "ExpHist", "Aggregation", });
    internal_static_opentelemetry_proto_mmap_v1_MetricRef_Gauge_descriptor =
      internal_static_opentelemetry_proto_mmap_v1_MetricRef_descriptor.getNestedType(0);
    internal_static_opentelemetry_proto_mmap_v1_MetricRef_Gauge_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_opentelemetry_proto_mmap_v1_MetricRef_Gauge_descriptor,
        new java.lang.String[] { });
    internal_static_opentelemetry_proto_mmap_v1_MetricRef_Sum_descriptor =
      internal_static_opentelemetry_proto_mmap_v1_MetricRef_descriptor.getNestedType(1);
    internal_static_opentelemetry_proto_mmap_v1_MetricRef_Sum_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_opentelemetry_proto_mmap_v1_MetricRef_Sum_descriptor,
        new java.lang.String[] { "AggregationTemporality", "IsMonotonic", });
    internal_static_opentelemetry_proto_mmap_v1_MetricRef_Histogram_descriptor =
      internal_static_opentelemetry_proto_mmap_v1_MetricRef_descriptor.getNestedType(2);
    internal_static_opentelemetry_proto_mmap_v1_MetricRef_Histogram_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_opentelemetry_proto_mmap_v1_MetricRef_Histogram_descriptor,
        new java.lang.String[] { "AggregationTemporality", "BucketBoundares", });
    internal_static_opentelemetry_proto_mmap_v1_MetricRef_ExponentialHistogram_descriptor =
      internal_static_opentelemetry_proto_mmap_v1_MetricRef_descriptor.getNestedType(3);
    internal_static_opentelemetry_proto_mmap_v1_MetricRef_ExponentialHistogram_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_opentelemetry_proto_mmap_v1_MetricRef_ExponentialHistogram_descriptor,
        new java.lang.String[] { "AggregationTemporality", "MaxBuckets", "MaxScale", });
    internal_static_opentelemetry_proto_mmap_v1_Event_descriptor =
      getDescriptor().getMessageType(4);
    internal_static_opentelemetry_proto_mmap_v1_Event_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_opentelemetry_proto_mmap_v1_Event_descriptor,
        new java.lang.String[] { "ScopeRef", "TimeUnixNano", "SeverityNumber", "SeverityText", "Body", "EventNameRef", "SpanContext", "Attributes", });
    internal_static_opentelemetry_proto_mmap_v1_Resource_descriptor =
      getDescriptor().getMessageType(5);
    internal_static_opentelemetry_proto_mmap_v1_Resource_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_opentelemetry_proto_mmap_v1_Resource_descriptor,
        new java.lang.String[] { "Attributes", "DroppedAttributesCount", });
    internal_static_opentelemetry_proto_mmap_v1_InstrumentationScope_descriptor =
      getDescriptor().getMessageType(6);
    internal_static_opentelemetry_proto_mmap_v1_InstrumentationScope_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_opentelemetry_proto_mmap_v1_InstrumentationScope_descriptor,
        new java.lang.String[] { "NameRef", "VersionRef", "Attributes", "DroppedAttributesCount", "ResourceRef", });
    internal_static_opentelemetry_proto_mmap_v1_KeyValueRef_descriptor =
      getDescriptor().getMessageType(7);
    internal_static_opentelemetry_proto_mmap_v1_KeyValueRef_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_opentelemetry_proto_mmap_v1_KeyValueRef_descriptor,
        new java.lang.String[] { "KeyRef", "Value", });
    internal_static_opentelemetry_proto_mmap_v1_AnyValue_descriptor =
      getDescriptor().getMessageType(8);
    internal_static_opentelemetry_proto_mmap_v1_AnyValue_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_opentelemetry_proto_mmap_v1_AnyValue_descriptor,
        new java.lang.String[] { "StringValue", "BoolValue", "IntValue", "DoubleValue", "ArrayValue", "KvlistValue", "BytesValue", "ValueRef", "Value", });
    internal_static_opentelemetry_proto_mmap_v1_ArrayValue_descriptor =
      getDescriptor().getMessageType(9);
    internal_static_opentelemetry_proto_mmap_v1_ArrayValue_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_opentelemetry_proto_mmap_v1_ArrayValue_descriptor,
        new java.lang.String[] { "Values", });
    internal_static_opentelemetry_proto_mmap_v1_KeyValueList_descriptor =
      getDescriptor().getMessageType(10);
    internal_static_opentelemetry_proto_mmap_v1_KeyValueList_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_opentelemetry_proto_mmap_v1_KeyValueList_descriptor,
        new java.lang.String[] { "Values", });
    internal_static_opentelemetry_proto_mmap_v1_SpanContext_descriptor =
      getDescriptor().getMessageType(11);
    internal_static_opentelemetry_proto_mmap_v1_SpanContext_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_opentelemetry_proto_mmap_v1_SpanContext_descriptor,
        new java.lang.String[] { "SpanId", "TraceId", "Flags", });
    descriptor.resolveAllFeaturesImmutable();
  }

  // @@protoc_insertion_point(outer_class_scope)
}
